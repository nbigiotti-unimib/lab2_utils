// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME G__Core
#define R__NO_DEPRECATION

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Header files passed as explicit arguments
#include "ROOT/TErrorDefaultHandler.hxx"
#include "ROOT/TSequentialExecutor.hxx"
#include "ROOT/StringConv.hxx"
#include "Buttons.h"
#include "Bytes.h"
#include "Byteswap.h"
#include "KeySymbols.h"
#include "MessageTypes.h"
#include "Riostream.h"
#include "Rtypes.h"
#include "TApplication.h"
#include "TAtt3D.h"
#include "TAttAxis.h"
#include "TAttBBox2D.h"
#include "TAttBBox.h"
#include "TAttFill.h"
#include "TAttLine.h"
#include "TAttMarker.h"
#include "TAttPad.h"
#include "TAttText.h"
#include "TBase64.h"
#include "TBenchmark.h"
#include "TBuffer3D.h"
#include "TBuffer3DTypes.h"
#include "TBuffer.h"
#include "TColor.h"
#include "TColorGradient.h"
#include "TDatime.h"
#include "TDirectory.h"
#include "TEnv.h"
#include "TException.h"
#include "TExec.h"
#include "TFileCollection.h"
#include "TFileInfo.h"
#include "TFolder.h"
#include "TInetAddress.h"
#include "TMacro.h"
#include "TMathBase.h"
#include "TMD5.h"
#include "TMemberInspector.h"
#include "TMessageHandler.h"
#include "TNamed.h"
#include "TNotifyLink.h"
#include "TObject.h"
#include "TObjString.h"
#include "TParameter.h"
#include "TPluginManager.h"
#include "TPoint.h"
#include "TPRegexp.h"
#include "TProcessID.h"
#include "TProcessUUID.h"
#include "TQClass.h"
#include "TQCommand.h"
#include "TQConnection.h"
#include "TQObject.h"
#include "TRedirectOutputGuard.h"
#include "TRefCnt.h"
#include "TRef.h"
#include "TRegexp.h"
#include "TRemoteObject.h"
#include "TROOT.h"
#include "TRootIOCtor.h"
#include "TStopwatch.h"
#include "TStorage.h"
#include "TString.h"
#include "TStringLong.h"
#include "TStyle.h"
#include "TSysEvtHandler.h"
#include "TSystemDirectory.h"
#include "TSystemFile.h"
#include "TSystem.h"
#include "TTask.h"
#include "TThreadSlots.h"
#include "TTime.h"
#include "TTimer.h"
#include "TTimeStamp.h"
#include "TUri.h"
#include "TUrl.h"
#include "TUUID.h"
#include "TVersionCheck.h"
#include "TVirtualAuth.h"
#include "TVirtualFFT.h"
#include "TVirtualGL.h"
#include "TVirtualMonitoring.h"
#include "TVirtualMutex.h"
#include "TVirtualPadEditor.h"
#include "TVirtualPad.h"
#include "TVirtualPadPainter.h"
#include "TVirtualPerfStats.h"
#include "TVirtualPS.h"
#include "TVirtualQConnection.h"
#include "TVirtualRWMutex.h"
#include "TVirtualTableInterface.h"
#include "TVirtualViewer3D.h"
#include "TVirtualX.h"
#include "strlcpy.h"
#include "snprintf.h"
#include "strtok.h"
#include "ROOT/TSeq.hxx"
#include "TArrayC.h"
#include "TArrayD.h"
#include "TArrayF.h"
#include "TArray.h"
#include "TArrayI.h"
#include "TArrayL64.h"
#include "TArrayL.h"
#include "TArrayS.h"
#include "TBits.h"
#include "TBtree.h"
#include "TClassTable.h"
#include "TClonesArray.h"
#include "TCollection.h"
#include "TCollectionProxyInfo.h"
#include "TExMap.h"
#include "THashList.h"
#include "THashTable.h"
#include "TIterator.h"
#include "TList.h"
#include "TMap.h"
#include "TObjArray.h"
#include "TObjectTable.h"
#include "TOrdCollection.h"
#include "TRefArray.h"
#include "TRefTable.h"
#include "TSeqCollection.h"
#include "TSortedList.h"
#include "TVirtualCollectionProxy.h"
#include "ESTLType.h"
#include "RStringView.h"
#include "TClassEdit.h"
#include "TError.h"
#include "ROOT/RLogger.hxx"
#include "ROOT/RNotFn.hxx"
#include "ROOT/RRangeCast.hxx"
#include "ROOT/RSpan.hxx"
#include "ROOT/RStringView.hxx"
#include "ROOT/StringUtils.hxx"
#include "ROOT/span.hxx"
#include "ROOT/TypeTraits.hxx"
#include "TUnixSystem.h"
#include "root_std_complex.h"
#include "GuiTypes.h"
#include "TApplicationImp.h"
#include "TBrowser.h"
#include "TBrowserImp.h"
#include "TCanvasImp.h"
#include "TClassMenuItem.h"
#include "TContextMenu.h"
#include "TContextMenuImp.h"
#include "TControlBarImp.h"
#include "TGuiFactory.h"
#include "TInspectorImp.h"
#include "TObjectSpy.h"
#include "TToggleGroup.h"
#include "TToggle.h"
#include "TBaseClass.h"
#include "TClassGenerator.h"
#include "TClass.h"
#include "TClassRef.h"
#include "TClassStreamer.h"
#include "TDataMember.h"
#include "TDataType.h"
#include "TDictAttributeMap.h"
#include "TDictionary.h"
#include "TEnumConstant.h"
#include "TEnum.h"
#include "TFileMergeInfo.h"
#include "TFunction.h"
#include "TFunctionTemplate.h"
#include "TGenericClassInfo.h"
#include "TGlobal.h"
#include "TInterpreter.h"
#include "TInterpreterValue.h"
#include "TIsAProxy.h"
#include "TListOfDataMembers.h"
#include "TListOfEnums.h"
#include "TListOfEnumsWithLock.h"
#include "TListOfFunctions.h"
#include "TListOfFunctionTemplates.h"
#include "TMemberStreamer.h"
#include "TMethodArg.h"
#include "TMethodCall.h"
#include "TMethod.h"
#include "TProtoClass.h"
#include "TRealData.h"
#include "TSchemaHelper.h"
#include "TSchemaRule.h"
#include "TSchemaRuleSet.h"
#include "TStatusBitsChecker.h"
#include "TStreamerElement.h"
#include "TStreamer.h"
#include "TVirtualIsAProxy.h"
#include "TVirtualRefProxy.h"
#include "TVirtualStreamerInfo.h"
#include "TVirtualArray.h"
#include "TVirtualObject.h"
#include "Getline.h"

// Header files passed via #pragma extra_include
#include "vector"
#include "string"
#include "string"
#include "Rpair.h"
#include "Rtypes.h"

// The generated code does not explicitly qualify STL entities
namespace std {} using namespace std;

   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *ROOT_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT", 0 /*version*/, "Rtypes.h", 105,
                     ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),
                     &ROOT_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *ROOT_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }

namespace TMath {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *TMath_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("TMath", 0 /*version*/, "TMathBase.h", 35,
                     ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),
                     &TMath_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *TMath_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOT {
   static TClass *timespec_Dictionary();
   static void timespec_TClassManip(TClass*);
   static void *new_timespec(void *p = nullptr);
   static void *newArray_timespec(Long_t size, void *p);
   static void delete_timespec(void *p);
   static void deleteArray_timespec(void *p);
   static void destruct_timespec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::timespec*)
   {
      ::timespec *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::timespec));
      static ::ROOT::TGenericClassInfo 
         instance("timespec", "sched.h", 10,
                  typeid(::timespec), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &timespec_Dictionary, isa_proxy, 0,
                  sizeof(::timespec) );
      instance.SetNew(&new_timespec);
      instance.SetNewArray(&newArray_timespec);
      instance.SetDelete(&delete_timespec);
      instance.SetDeleteArray(&deleteArray_timespec);
      instance.SetDestructor(&destruct_timespec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::timespec*)
   {
      return GenerateInitInstanceLocal((::timespec*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::timespec*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *timespec_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::timespec*)nullptr)->GetClass();
      timespec_TClassManip(theClass);
   return theClass;
   }

   static void timespec_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOlonggR_Dictionary();
   static void pairlEconstsPlongcOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOlonggR(void *p);
   static void deleteArray_pairlEconstsPlongcOlonggR(void *p);
   static void destruct_pairlEconstsPlongcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,long>*)
   {
      pair<const long,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,long>", "utility", 208,
                  typeid(pair<const long,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,long>) );
      instance.SetNew(&new_pairlEconstsPlongcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPlongcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOlonggR);

      ::ROOT::AddClassAlternate("pair<const long,long>","std::pair<long const, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,long>*)nullptr)->GetClass();
      pairlEconstsPlongcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcOintgR_Dictionary();
   static void pairlEstringcOintgR_TClassManip(TClass*);
   static void *new_pairlEstringcOintgR(void *p = nullptr);
   static void *newArray_pairlEstringcOintgR(Long_t size, void *p);
   static void delete_pairlEstringcOintgR(void *p);
   static void deleteArray_pairlEstringcOintgR(void *p);
   static void destruct_pairlEstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,int>*)
   {
      pair<string,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,int>", "utility", 208,
                  typeid(pair<string,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,int>) );
      instance.SetNew(&new_pairlEstringcOintgR);
      instance.SetNewArray(&newArray_pairlEstringcOintgR);
      instance.SetDelete(&delete_pairlEstringcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOintgR);
      instance.SetDestructor(&destruct_pairlEstringcOintgR);

      ::ROOT::AddClassAlternate("pair<string,int>","pair<std::string,int>");

      ::ROOT::AddClassAlternate("pair<string,int>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,int>*)nullptr)->GetClass();
      pairlEstringcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOintgR_Dictionary();
   static void pairlEintcOintgR_TClassManip(TClass*);
   static void *new_pairlEintcOintgR(void *p = nullptr);
   static void *newArray_pairlEintcOintgR(Long_t size, void *p);
   static void delete_pairlEintcOintgR(void *p);
   static void deleteArray_pairlEintcOintgR(void *p);
   static void destruct_pairlEintcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,int>*)
   {
      pair<int,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,int>", "utility", 208,
                  typeid(pair<int,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,int>) );
      instance.SetNew(&new_pairlEintcOintgR);
      instance.SetNewArray(&newArray_pairlEintcOintgR);
      instance.SetDelete(&delete_pairlEintcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOintgR);
      instance.SetDestructor(&destruct_pairlEintcOintgR);

      ::ROOT::AddClassAlternate("pair<int,int>","std::pair<int, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,int>*)nullptr)->GetClass();
      pairlEintcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOcharmUgR_Dictionary();
   static void pairlEconstsPdoublecOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOcharmUgR(void *p);
   static void destruct_pairlEconstsPdoublecOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,char*>*)
   {
      pair<const double,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,char*>", "utility", 208,
                  typeid(pair<const double,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,char*>) );
      instance.SetNew(&new_pairlEconstsPdoublecOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOcharmUgR);

      ::ROOT::AddClassAlternate("pair<const double,char*>","std::pair<double const, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,char*>*)nullptr)->GetClass();
      pairlEconstsPdoublecOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOvoidmUgR_Dictionary();
   static void pairlEconstsPdoublecOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOvoidmUgR(void *p);
   static void destruct_pairlEconstsPdoublecOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,void*>*)
   {
      pair<const double,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,void*>", "utility", 208,
                  typeid(pair<const double,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,void*>) );
      instance.SetNew(&new_pairlEconstsPdoublecOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const double,void*>","std::pair<double const, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,void*>*)nullptr)->GetClass();
      pairlEconstsPdoublecOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOdoublegR_Dictionary();
   static void pairlEconstsPdoublecOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOdoublegR(void *p);
   static void deleteArray_pairlEconstsPdoublecOdoublegR(void *p);
   static void destruct_pairlEconstsPdoublecOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,double>*)
   {
      pair<const double,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,double>", "utility", 208,
                  typeid(pair<const double,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,double>) );
      instance.SetNew(&new_pairlEconstsPdoublecOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOdoublegR);

      ::ROOT::AddClassAlternate("pair<const double,double>","std::pair<double const, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,double>*)nullptr)->GetClass();
      pairlEconstsPdoublecOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOfloatgR_Dictionary();
   static void pairlEconstsPdoublecOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOfloatgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOfloatgR(void *p);
   static void destruct_pairlEconstsPdoublecOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,float>*)
   {
      pair<const double,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,float>", "utility", 208,
                  typeid(pair<const double,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,float>) );
      instance.SetNew(&new_pairlEconstsPdoublecOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOfloatgR);

      ::ROOT::AddClassAlternate("pair<const double,float>","std::pair<double const, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,float>*)nullptr)->GetClass();
      pairlEconstsPdoublecOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOlonggR_Dictionary();
   static void pairlEconstsPdoublecOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOlonggR(void *p);
   static void deleteArray_pairlEconstsPdoublecOlonggR(void *p);
   static void destruct_pairlEconstsPdoublecOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,long>*)
   {
      pair<const double,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,long>", "utility", 208,
                  typeid(pair<const double,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,long>) );
      instance.SetNew(&new_pairlEconstsPdoublecOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOlonggR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOlonggR);

      ::ROOT::AddClassAlternate("pair<const double,long>","std::pair<double const, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,long>*)nullptr)->GetClass();
      pairlEconstsPdoublecOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPdoublecOintgR_Dictionary();
   static void pairlEconstsPdoublecOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPdoublecOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPdoublecOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOintgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOintgR(void *p);
   static void destruct_pairlEconstsPdoublecOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,int>*)
   {
      pair<const double,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,int>", "utility", 208,
                  typeid(pair<const double,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPdoublecOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,int>) );
      instance.SetNew(&new_pairlEconstsPdoublecOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOintgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOintgR);

      ::ROOT::AddClassAlternate("pair<const double,int>","std::pair<double const, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const double,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPdoublecOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const double,int>*)nullptr)->GetClass();
      pairlEconstsPdoublecOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPdoublecOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOcharmUgR_Dictionary();
   static void pairlEconstsPfloatcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOcharmUgR(void *p);
   static void destruct_pairlEconstsPfloatcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,char*>*)
   {
      pair<const float,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,char*>", "utility", 208,
                  typeid(pair<const float,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,char*>) );
      instance.SetNew(&new_pairlEconstsPfloatcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<const float,char*>","std::pair<float const, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,char*>*)nullptr)->GetClass();
      pairlEconstsPfloatcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOvoidmUgR_Dictionary();
   static void pairlEconstsPfloatcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPfloatcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,void*>*)
   {
      pair<const float,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,void*>", "utility", 208,
                  typeid(pair<const float,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,void*>) );
      instance.SetNew(&new_pairlEconstsPfloatcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const float,void*>","std::pair<float const, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,void*>*)nullptr)->GetClass();
      pairlEconstsPfloatcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOdoublegR_Dictionary();
   static void pairlEconstsPfloatcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPfloatcOdoublegR(void *p);
   static void destruct_pairlEconstsPfloatcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,double>*)
   {
      pair<const float,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,double>", "utility", 208,
                  typeid(pair<const float,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,double>) );
      instance.SetNew(&new_pairlEconstsPfloatcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOdoublegR);

      ::ROOT::AddClassAlternate("pair<const float,double>","std::pair<float const, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,double>*)nullptr)->GetClass();
      pairlEconstsPfloatcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOfloatgR_Dictionary();
   static void pairlEconstsPfloatcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOfloatgR(void *p);
   static void destruct_pairlEconstsPfloatcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,float>*)
   {
      pair<const float,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,float>", "utility", 208,
                  typeid(pair<const float,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,float>) );
      instance.SetNew(&new_pairlEconstsPfloatcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOfloatgR);

      ::ROOT::AddClassAlternate("pair<const float,float>","std::pair<float const, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,float>*)nullptr)->GetClass();
      pairlEconstsPfloatcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOlonggR_Dictionary();
   static void pairlEconstsPfloatcOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOlonggR(void *p);
   static void deleteArray_pairlEconstsPfloatcOlonggR(void *p);
   static void destruct_pairlEconstsPfloatcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,long>*)
   {
      pair<const float,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,long>", "utility", 208,
                  typeid(pair<const float,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,long>) );
      instance.SetNew(&new_pairlEconstsPfloatcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOlonggR);

      ::ROOT::AddClassAlternate("pair<const float,long>","std::pair<float const, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,long>*)nullptr)->GetClass();
      pairlEconstsPfloatcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPfloatcOintgR_Dictionary();
   static void pairlEconstsPfloatcOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPfloatcOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPfloatcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOintgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOintgR(void *p);
   static void destruct_pairlEconstsPfloatcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,int>*)
   {
      pair<const float,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,int>", "utility", 208,
                  typeid(pair<const float,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPfloatcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,int>) );
      instance.SetNew(&new_pairlEconstsPfloatcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOintgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOintgR);

      ::ROOT::AddClassAlternate("pair<const float,int>","std::pair<float const, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const float,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPfloatcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const float,int>*)nullptr)->GetClass();
      pairlEconstsPfloatcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPfloatcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOcharmUgR_Dictionary();
   static void pairlEconstsPlongcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPlongcOcharmUgR(void *p);
   static void destruct_pairlEconstsPlongcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,char*>*)
   {
      pair<const long,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,char*>", "utility", 208,
                  typeid(pair<const long,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,char*>) );
      instance.SetNew(&new_pairlEconstsPlongcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<const long,char*>","std::pair<long const, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,char*>*)nullptr)->GetClass();
      pairlEconstsPlongcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOvoidmUgR_Dictionary();
   static void pairlEconstsPlongcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPlongcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPlongcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,void*>*)
   {
      pair<const long,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,void*>", "utility", 208,
                  typeid(pair<const long,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,void*>) );
      instance.SetNew(&new_pairlEconstsPlongcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const long,void*>","std::pair<long const, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,void*>*)nullptr)->GetClass();
      pairlEconstsPlongcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOdoublegR_Dictionary();
   static void pairlEconstsPlongcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPlongcOdoublegR(void *p);
   static void destruct_pairlEconstsPlongcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,double>*)
   {
      pair<const long,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,double>", "utility", 208,
                  typeid(pair<const long,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,double>) );
      instance.SetNew(&new_pairlEconstsPlongcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPlongcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOdoublegR);

      ::ROOT::AddClassAlternate("pair<const long,double>","std::pair<long const, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,double>*)nullptr)->GetClass();
      pairlEconstsPlongcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOfloatgR_Dictionary();
   static void pairlEconstsPlongcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPlongcOfloatgR(void *p);
   static void destruct_pairlEconstsPlongcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,float>*)
   {
      pair<const long,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,float>", "utility", 208,
                  typeid(pair<const long,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,float>) );
      instance.SetNew(&new_pairlEconstsPlongcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOfloatgR);

      ::ROOT::AddClassAlternate("pair<const long,float>","std::pair<long const, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,float>*)nullptr)->GetClass();
      pairlEconstsPlongcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPlongcOintgR_Dictionary();
   static void pairlEconstsPlongcOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPlongcOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPlongcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOintgR(void *p);
   static void deleteArray_pairlEconstsPlongcOintgR(void *p);
   static void destruct_pairlEconstsPlongcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,int>*)
   {
      pair<const long,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,int>", "utility", 208,
                  typeid(pair<const long,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPlongcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,int>) );
      instance.SetNew(&new_pairlEconstsPlongcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOintgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOintgR);

      ::ROOT::AddClassAlternate("pair<const long,int>","std::pair<long const, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const long,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPlongcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const long,int>*)nullptr)->GetClass();
      pairlEconstsPlongcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPlongcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOcharmUgR_Dictionary();
   static void pairlEconstsPintcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPintcOcharmUgR(void *p);
   static void destruct_pairlEconstsPintcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,char*>*)
   {
      pair<const int,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,char*>", "utility", 208,
                  typeid(pair<const int,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,char*>) );
      instance.SetNew(&new_pairlEconstsPintcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPintcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<const int,char*>","std::pair<int const, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,char*>*)nullptr)->GetClass();
      pairlEconstsPintcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOvoidmUgR_Dictionary();
   static void pairlEconstsPintcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPintcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPintcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,void*>*)
   {
      pair<const int,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,void*>", "utility", 208,
                  typeid(pair<const int,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,void*>) );
      instance.SetNew(&new_pairlEconstsPintcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPintcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const int,void*>","std::pair<int const, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,void*>*)nullptr)->GetClass();
      pairlEconstsPintcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOdoublegR_Dictionary();
   static void pairlEconstsPintcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPintcOdoublegR(void *p);
   static void destruct_pairlEconstsPintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,double>*)
   {
      pair<const int,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,double>", "utility", 208,
                  typeid(pair<const int,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,double>) );
      instance.SetNew(&new_pairlEconstsPintcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOdoublegR);

      ::ROOT::AddClassAlternate("pair<const int,double>","std::pair<int const, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,double>*)nullptr)->GetClass();
      pairlEconstsPintcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOfloatgR_Dictionary();
   static void pairlEconstsPintcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPintcOfloatgR(void *p);
   static void destruct_pairlEconstsPintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,float>*)
   {
      pair<const int,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,float>", "utility", 208,
                  typeid(pair<const int,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,float>) );
      instance.SetNew(&new_pairlEconstsPintcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOfloatgR);

      ::ROOT::AddClassAlternate("pair<const int,float>","std::pair<int const, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,float>*)nullptr)->GetClass();
      pairlEconstsPintcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOlonggR_Dictionary();
   static void pairlEconstsPintcOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOlonggR(void *p);
   static void deleteArray_pairlEconstsPintcOlonggR(void *p);
   static void destruct_pairlEconstsPintcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,long>*)
   {
      pair<const int,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,long>", "utility", 208,
                  typeid(pair<const int,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,long>) );
      instance.SetNew(&new_pairlEconstsPintcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPintcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOlonggR);

      ::ROOT::AddClassAlternate("pair<const int,long>","std::pair<int const, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,long>*)nullptr)->GetClass();
      pairlEconstsPintcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPintcOintgR_Dictionary();
   static void pairlEconstsPintcOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPintcOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPintcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOintgR(void *p);
   static void deleteArray_pairlEconstsPintcOintgR(void *p);
   static void destruct_pairlEconstsPintcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,int>*)
   {
      pair<const int,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,int>", "utility", 208,
                  typeid(pair<const int,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPintcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,int>) );
      instance.SetNew(&new_pairlEconstsPintcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOintgR);
      instance.SetDelete(&delete_pairlEconstsPintcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOintgR);

      ::ROOT::AddClassAlternate("pair<const int,int>","std::pair<int const, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const int,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPintcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const int,int>*)nullptr)->GetClass();
      pairlEconstsPintcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPintcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPstringcOvoidmUgR_Dictionary();
   static void pairlEconstsPstringcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPstringcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPstringcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPstringcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPstringcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,void*>*)
   {
      pair<const string,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,void*>", "utility", 208,
                  typeid(pair<const string,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,void*>) );
      instance.SetNew(&new_pairlEconstsPstringcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const string,void*>","pair<const std::string,void*>");

      ::ROOT::AddClassAlternate("pair<const string,void*>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const string,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPstringcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const string,void*>*)nullptr)->GetClass();
      pairlEconstsPstringcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPstringcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPstringcOdoublegR_Dictionary();
   static void pairlEconstsPstringcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPstringcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPstringcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPstringcOdoublegR(void *p);
   static void destruct_pairlEconstsPstringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,double>*)
   {
      pair<const string,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,double>", "utility", 208,
                  typeid(pair<const string,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,double>) );
      instance.SetNew(&new_pairlEconstsPstringcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPstringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOdoublegR);

      ::ROOT::AddClassAlternate("pair<const string,double>","pair<const std::string,double>");

      ::ROOT::AddClassAlternate("pair<const string,double>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const string,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPstringcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const string,double>*)nullptr)->GetClass();
      pairlEconstsPstringcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPstringcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPstringcOfloatgR_Dictionary();
   static void pairlEconstsPstringcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPstringcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPstringcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPstringcOfloatgR(void *p);
   static void destruct_pairlEconstsPstringcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,float>*)
   {
      pair<const string,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,float>", "utility", 208,
                  typeid(pair<const string,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,float>) );
      instance.SetNew(&new_pairlEconstsPstringcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOfloatgR);

      ::ROOT::AddClassAlternate("pair<const string,float>","pair<const std::string,float>");

      ::ROOT::AddClassAlternate("pair<const string,float>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const string,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPstringcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const string,float>*)nullptr)->GetClass();
      pairlEconstsPstringcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPstringcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPstringcOlonggR_Dictionary();
   static void pairlEconstsPstringcOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPstringcOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPstringcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOlonggR(void *p);
   static void deleteArray_pairlEconstsPstringcOlonggR(void *p);
   static void destruct_pairlEconstsPstringcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,long>*)
   {
      pair<const string,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,long>", "utility", 208,
                  typeid(pair<const string,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,long>) );
      instance.SetNew(&new_pairlEconstsPstringcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPstringcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOlonggR);

      ::ROOT::AddClassAlternate("pair<const string,long>","pair<const std::string,long>");

      ::ROOT::AddClassAlternate("pair<const string,long>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const string,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPstringcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const string,long>*)nullptr)->GetClass();
      pairlEconstsPstringcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPstringcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPstringcOintgR_Dictionary();
   static void pairlEconstsPstringcOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPstringcOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPstringcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOintgR(void *p);
   static void deleteArray_pairlEconstsPstringcOintgR(void *p);
   static void destruct_pairlEconstsPstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,int>*)
   {
      pair<const string,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,int>", "utility", 208,
                  typeid(pair<const string,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPstringcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,int>) );
      instance.SetNew(&new_pairlEconstsPstringcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOintgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOintgR);

      ::ROOT::AddClassAlternate("pair<const string,int>","pair<const std::string,int>");

      ::ROOT::AddClassAlternate("pair<const string,int>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const string,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPstringcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const string,int>*)nullptr)->GetClass();
      pairlEconstsPstringcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPstringcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOcharmUgR_Dictionary();
   static void pairlEconstsPcharmUcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOcharmUgR(void *p);
   static void destruct_pairlEconstsPcharmUcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,char*>*)
   {
      pair<const char*,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,char*>", "utility", 208,
                  typeid(pair<const char*,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,char*>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<const char*,char*>","std::pair<char const*, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,char*>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOvoidmUgR_Dictionary();
   static void pairlEconstsPcharmUcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPcharmUcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,void*>*)
   {
      pair<const char*,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,void*>", "utility", 208,
                  typeid(pair<const char*,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,void*>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<const char*,void*>","std::pair<char const*, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,void*>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOdoublegR_Dictionary();
   static void pairlEconstsPcharmUcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOdoublegR(void *p);
   static void destruct_pairlEconstsPcharmUcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,double>*)
   {
      pair<const char*,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,double>", "utility", 208,
                  typeid(pair<const char*,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,double>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOdoublegR);

      ::ROOT::AddClassAlternate("pair<const char*,double>","std::pair<char const*, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,double>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOfloatgR_Dictionary();
   static void pairlEconstsPcharmUcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOfloatgR(void *p);
   static void destruct_pairlEconstsPcharmUcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,float>*)
   {
      pair<const char*,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,float>", "utility", 208,
                  typeid(pair<const char*,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,float>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOfloatgR);

      ::ROOT::AddClassAlternate("pair<const char*,float>","std::pair<char const*, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,float>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOlonggR_Dictionary();
   static void pairlEconstsPcharmUcOlonggR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOlonggR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOlonggR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOlonggR(void *p);
   static void destruct_pairlEconstsPcharmUcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,long>*)
   {
      pair<const char*,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,long>", "utility", 208,
                  typeid(pair<const char*,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,long>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOlonggR);

      ::ROOT::AddClassAlternate("pair<const char*,long>","std::pair<char const*, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,long>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEconstsPcharmUcOintgR_Dictionary();
   static void pairlEconstsPcharmUcOintgR_TClassManip(TClass*);
   static void *new_pairlEconstsPcharmUcOintgR(void *p = nullptr);
   static void *newArray_pairlEconstsPcharmUcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOintgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOintgR(void *p);
   static void destruct_pairlEconstsPcharmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,int>*)
   {
      pair<const char*,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,int>", "utility", 208,
                  typeid(pair<const char*,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEconstsPcharmUcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,int>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOintgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOintgR);

      ::ROOT::AddClassAlternate("pair<const char*,int>","std::pair<char const*, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<const char*,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEconstsPcharmUcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<const char*,int>*)nullptr)->GetClass();
      pairlEconstsPcharmUcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEconstsPcharmUcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOcharmUgR_Dictionary();
   static void pairlEdoublecOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEdoublecOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEdoublecOcharmUgR(Long_t size, void *p);
   static void delete_pairlEdoublecOcharmUgR(void *p);
   static void deleteArray_pairlEdoublecOcharmUgR(void *p);
   static void destruct_pairlEdoublecOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,char*>*)
   {
      pair<double,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,char*>", "utility", 208,
                  typeid(pair<double,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,char*>) );
      instance.SetNew(&new_pairlEdoublecOcharmUgR);
      instance.SetNewArray(&newArray_pairlEdoublecOcharmUgR);
      instance.SetDelete(&delete_pairlEdoublecOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOcharmUgR);
      instance.SetDestructor(&destruct_pairlEdoublecOcharmUgR);

      ::ROOT::AddClassAlternate("pair<double,char*>","std::pair<double, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,char*>*)nullptr)->GetClass();
      pairlEdoublecOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOvoidmUgR_Dictionary();
   static void pairlEdoublecOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEdoublecOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEdoublecOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEdoublecOvoidmUgR(void *p);
   static void deleteArray_pairlEdoublecOvoidmUgR(void *p);
   static void destruct_pairlEdoublecOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,void*>*)
   {
      pair<double,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,void*>", "utility", 208,
                  typeid(pair<double,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,void*>) );
      instance.SetNew(&new_pairlEdoublecOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEdoublecOvoidmUgR);
      instance.SetDelete(&delete_pairlEdoublecOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEdoublecOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<double,void*>","std::pair<double, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,void*>*)nullptr)->GetClass();
      pairlEdoublecOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOdoublegR_Dictionary();
   static void pairlEdoublecOdoublegR_TClassManip(TClass*);
   static void *new_pairlEdoublecOdoublegR(void *p = nullptr);
   static void *newArray_pairlEdoublecOdoublegR(Long_t size, void *p);
   static void delete_pairlEdoublecOdoublegR(void *p);
   static void deleteArray_pairlEdoublecOdoublegR(void *p);
   static void destruct_pairlEdoublecOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,double>*)
   {
      pair<double,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,double>", "utility", 208,
                  typeid(pair<double,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,double>) );
      instance.SetNew(&new_pairlEdoublecOdoublegR);
      instance.SetNewArray(&newArray_pairlEdoublecOdoublegR);
      instance.SetDelete(&delete_pairlEdoublecOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOdoublegR);
      instance.SetDestructor(&destruct_pairlEdoublecOdoublegR);

      ::ROOT::AddClassAlternate("pair<double,double>","std::pair<double, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,double>*)nullptr)->GetClass();
      pairlEdoublecOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOfloatgR_Dictionary();
   static void pairlEdoublecOfloatgR_TClassManip(TClass*);
   static void *new_pairlEdoublecOfloatgR(void *p = nullptr);
   static void *newArray_pairlEdoublecOfloatgR(Long_t size, void *p);
   static void delete_pairlEdoublecOfloatgR(void *p);
   static void deleteArray_pairlEdoublecOfloatgR(void *p);
   static void destruct_pairlEdoublecOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,float>*)
   {
      pair<double,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,float>", "utility", 208,
                  typeid(pair<double,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,float>) );
      instance.SetNew(&new_pairlEdoublecOfloatgR);
      instance.SetNewArray(&newArray_pairlEdoublecOfloatgR);
      instance.SetDelete(&delete_pairlEdoublecOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOfloatgR);
      instance.SetDestructor(&destruct_pairlEdoublecOfloatgR);

      ::ROOT::AddClassAlternate("pair<double,float>","std::pair<double, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,float>*)nullptr)->GetClass();
      pairlEdoublecOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOlonggR_Dictionary();
   static void pairlEdoublecOlonggR_TClassManip(TClass*);
   static void *new_pairlEdoublecOlonggR(void *p = nullptr);
   static void *newArray_pairlEdoublecOlonggR(Long_t size, void *p);
   static void delete_pairlEdoublecOlonggR(void *p);
   static void deleteArray_pairlEdoublecOlonggR(void *p);
   static void destruct_pairlEdoublecOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,long>*)
   {
      pair<double,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,long>", "utility", 208,
                  typeid(pair<double,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,long>) );
      instance.SetNew(&new_pairlEdoublecOlonggR);
      instance.SetNewArray(&newArray_pairlEdoublecOlonggR);
      instance.SetDelete(&delete_pairlEdoublecOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOlonggR);
      instance.SetDestructor(&destruct_pairlEdoublecOlonggR);

      ::ROOT::AddClassAlternate("pair<double,long>","std::pair<double, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,long>*)nullptr)->GetClass();
      pairlEdoublecOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEdoublecOintgR_Dictionary();
   static void pairlEdoublecOintgR_TClassManip(TClass*);
   static void *new_pairlEdoublecOintgR(void *p = nullptr);
   static void *newArray_pairlEdoublecOintgR(Long_t size, void *p);
   static void delete_pairlEdoublecOintgR(void *p);
   static void deleteArray_pairlEdoublecOintgR(void *p);
   static void destruct_pairlEdoublecOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,int>*)
   {
      pair<double,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,int>", "utility", 208,
                  typeid(pair<double,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEdoublecOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,int>) );
      instance.SetNew(&new_pairlEdoublecOintgR);
      instance.SetNewArray(&newArray_pairlEdoublecOintgR);
      instance.SetDelete(&delete_pairlEdoublecOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOintgR);
      instance.SetDestructor(&destruct_pairlEdoublecOintgR);

      ::ROOT::AddClassAlternate("pair<double,int>","std::pair<double, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<double,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEdoublecOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<double,int>*)nullptr)->GetClass();
      pairlEdoublecOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEdoublecOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOcharmUgR_Dictionary();
   static void pairlEfloatcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEfloatcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEfloatcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEfloatcOcharmUgR(void *p);
   static void deleteArray_pairlEfloatcOcharmUgR(void *p);
   static void destruct_pairlEfloatcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,char*>*)
   {
      pair<float,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,char*>", "utility", 208,
                  typeid(pair<float,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,char*>) );
      instance.SetNew(&new_pairlEfloatcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEfloatcOcharmUgR);
      instance.SetDelete(&delete_pairlEfloatcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEfloatcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<float,char*>","std::pair<float, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,char*>*)nullptr)->GetClass();
      pairlEfloatcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOvoidmUgR_Dictionary();
   static void pairlEfloatcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEfloatcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEfloatcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEfloatcOvoidmUgR(void *p);
   static void deleteArray_pairlEfloatcOvoidmUgR(void *p);
   static void destruct_pairlEfloatcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,void*>*)
   {
      pair<float,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,void*>", "utility", 208,
                  typeid(pair<float,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,void*>) );
      instance.SetNew(&new_pairlEfloatcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEfloatcOvoidmUgR);
      instance.SetDelete(&delete_pairlEfloatcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEfloatcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<float,void*>","std::pair<float, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,void*>*)nullptr)->GetClass();
      pairlEfloatcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOdoublegR_Dictionary();
   static void pairlEfloatcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEfloatcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEfloatcOdoublegR(Long_t size, void *p);
   static void delete_pairlEfloatcOdoublegR(void *p);
   static void deleteArray_pairlEfloatcOdoublegR(void *p);
   static void destruct_pairlEfloatcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,double>*)
   {
      pair<float,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,double>", "utility", 208,
                  typeid(pair<float,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,double>) );
      instance.SetNew(&new_pairlEfloatcOdoublegR);
      instance.SetNewArray(&newArray_pairlEfloatcOdoublegR);
      instance.SetDelete(&delete_pairlEfloatcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOdoublegR);
      instance.SetDestructor(&destruct_pairlEfloatcOdoublegR);

      ::ROOT::AddClassAlternate("pair<float,double>","std::pair<float, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,double>*)nullptr)->GetClass();
      pairlEfloatcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOfloatgR_Dictionary();
   static void pairlEfloatcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEfloatcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEfloatcOfloatgR(Long_t size, void *p);
   static void delete_pairlEfloatcOfloatgR(void *p);
   static void deleteArray_pairlEfloatcOfloatgR(void *p);
   static void destruct_pairlEfloatcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,float>*)
   {
      pair<float,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,float>", "utility", 208,
                  typeid(pair<float,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,float>) );
      instance.SetNew(&new_pairlEfloatcOfloatgR);
      instance.SetNewArray(&newArray_pairlEfloatcOfloatgR);
      instance.SetDelete(&delete_pairlEfloatcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOfloatgR);
      instance.SetDestructor(&destruct_pairlEfloatcOfloatgR);

      ::ROOT::AddClassAlternate("pair<float,float>","std::pair<float, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,float>*)nullptr)->GetClass();
      pairlEfloatcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOlonggR_Dictionary();
   static void pairlEfloatcOlonggR_TClassManip(TClass*);
   static void *new_pairlEfloatcOlonggR(void *p = nullptr);
   static void *newArray_pairlEfloatcOlonggR(Long_t size, void *p);
   static void delete_pairlEfloatcOlonggR(void *p);
   static void deleteArray_pairlEfloatcOlonggR(void *p);
   static void destruct_pairlEfloatcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,long>*)
   {
      pair<float,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,long>", "utility", 208,
                  typeid(pair<float,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,long>) );
      instance.SetNew(&new_pairlEfloatcOlonggR);
      instance.SetNewArray(&newArray_pairlEfloatcOlonggR);
      instance.SetDelete(&delete_pairlEfloatcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOlonggR);
      instance.SetDestructor(&destruct_pairlEfloatcOlonggR);

      ::ROOT::AddClassAlternate("pair<float,long>","std::pair<float, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,long>*)nullptr)->GetClass();
      pairlEfloatcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEfloatcOintgR_Dictionary();
   static void pairlEfloatcOintgR_TClassManip(TClass*);
   static void *new_pairlEfloatcOintgR(void *p = nullptr);
   static void *newArray_pairlEfloatcOintgR(Long_t size, void *p);
   static void delete_pairlEfloatcOintgR(void *p);
   static void deleteArray_pairlEfloatcOintgR(void *p);
   static void destruct_pairlEfloatcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,int>*)
   {
      pair<float,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,int>", "utility", 208,
                  typeid(pair<float,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEfloatcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,int>) );
      instance.SetNew(&new_pairlEfloatcOintgR);
      instance.SetNewArray(&newArray_pairlEfloatcOintgR);
      instance.SetDelete(&delete_pairlEfloatcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOintgR);
      instance.SetDestructor(&destruct_pairlEfloatcOintgR);

      ::ROOT::AddClassAlternate("pair<float,int>","std::pair<float, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<float,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEfloatcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<float,int>*)nullptr)->GetClass();
      pairlEfloatcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEfloatcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOcharmUgR_Dictionary();
   static void pairlElongcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlElongcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlElongcOcharmUgR(Long_t size, void *p);
   static void delete_pairlElongcOcharmUgR(void *p);
   static void deleteArray_pairlElongcOcharmUgR(void *p);
   static void destruct_pairlElongcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,char*>*)
   {
      pair<long,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,char*>", "utility", 208,
                  typeid(pair<long,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,char*>) );
      instance.SetNew(&new_pairlElongcOcharmUgR);
      instance.SetNewArray(&newArray_pairlElongcOcharmUgR);
      instance.SetDelete(&delete_pairlElongcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOcharmUgR);
      instance.SetDestructor(&destruct_pairlElongcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<long,char*>","std::pair<long, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,char*>*)nullptr)->GetClass();
      pairlElongcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOvoidmUgR_Dictionary();
   static void pairlElongcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlElongcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlElongcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlElongcOvoidmUgR(void *p);
   static void deleteArray_pairlElongcOvoidmUgR(void *p);
   static void destruct_pairlElongcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,void*>*)
   {
      pair<long,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,void*>", "utility", 208,
                  typeid(pair<long,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,void*>) );
      instance.SetNew(&new_pairlElongcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlElongcOvoidmUgR);
      instance.SetDelete(&delete_pairlElongcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlElongcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<long,void*>","std::pair<long, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,void*>*)nullptr)->GetClass();
      pairlElongcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOdoublegR_Dictionary();
   static void pairlElongcOdoublegR_TClassManip(TClass*);
   static void *new_pairlElongcOdoublegR(void *p = nullptr);
   static void *newArray_pairlElongcOdoublegR(Long_t size, void *p);
   static void delete_pairlElongcOdoublegR(void *p);
   static void deleteArray_pairlElongcOdoublegR(void *p);
   static void destruct_pairlElongcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,double>*)
   {
      pair<long,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,double>", "utility", 208,
                  typeid(pair<long,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,double>) );
      instance.SetNew(&new_pairlElongcOdoublegR);
      instance.SetNewArray(&newArray_pairlElongcOdoublegR);
      instance.SetDelete(&delete_pairlElongcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOdoublegR);
      instance.SetDestructor(&destruct_pairlElongcOdoublegR);

      ::ROOT::AddClassAlternate("pair<long,double>","std::pair<long, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,double>*)nullptr)->GetClass();
      pairlElongcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOfloatgR_Dictionary();
   static void pairlElongcOfloatgR_TClassManip(TClass*);
   static void *new_pairlElongcOfloatgR(void *p = nullptr);
   static void *newArray_pairlElongcOfloatgR(Long_t size, void *p);
   static void delete_pairlElongcOfloatgR(void *p);
   static void deleteArray_pairlElongcOfloatgR(void *p);
   static void destruct_pairlElongcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,float>*)
   {
      pair<long,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,float>", "utility", 208,
                  typeid(pair<long,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,float>) );
      instance.SetNew(&new_pairlElongcOfloatgR);
      instance.SetNewArray(&newArray_pairlElongcOfloatgR);
      instance.SetDelete(&delete_pairlElongcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOfloatgR);
      instance.SetDestructor(&destruct_pairlElongcOfloatgR);

      ::ROOT::AddClassAlternate("pair<long,float>","std::pair<long, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,float>*)nullptr)->GetClass();
      pairlElongcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOlonggR_Dictionary();
   static void pairlElongcOlonggR_TClassManip(TClass*);
   static void *new_pairlElongcOlonggR(void *p = nullptr);
   static void *newArray_pairlElongcOlonggR(Long_t size, void *p);
   static void delete_pairlElongcOlonggR(void *p);
   static void deleteArray_pairlElongcOlonggR(void *p);
   static void destruct_pairlElongcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,long>*)
   {
      pair<long,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,long>", "utility", 208,
                  typeid(pair<long,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,long>) );
      instance.SetNew(&new_pairlElongcOlonggR);
      instance.SetNewArray(&newArray_pairlElongcOlonggR);
      instance.SetDelete(&delete_pairlElongcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOlonggR);
      instance.SetDestructor(&destruct_pairlElongcOlonggR);

      ::ROOT::AddClassAlternate("pair<long,long>","std::pair<long, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,long>*)nullptr)->GetClass();
      pairlElongcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlElongcOintgR_Dictionary();
   static void pairlElongcOintgR_TClassManip(TClass*);
   static void *new_pairlElongcOintgR(void *p = nullptr);
   static void *newArray_pairlElongcOintgR(Long_t size, void *p);
   static void delete_pairlElongcOintgR(void *p);
   static void deleteArray_pairlElongcOintgR(void *p);
   static void destruct_pairlElongcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,int>*)
   {
      pair<long,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,int>", "utility", 208,
                  typeid(pair<long,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlElongcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,int>) );
      instance.SetNew(&new_pairlElongcOintgR);
      instance.SetNewArray(&newArray_pairlElongcOintgR);
      instance.SetDelete(&delete_pairlElongcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOintgR);
      instance.SetDestructor(&destruct_pairlElongcOintgR);

      ::ROOT::AddClassAlternate("pair<long,int>","std::pair<long, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<long,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlElongcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<long,int>*)nullptr)->GetClass();
      pairlElongcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlElongcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOcharmUgR_Dictionary();
   static void pairlEintcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEintcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEintcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEintcOcharmUgR(void *p);
   static void deleteArray_pairlEintcOcharmUgR(void *p);
   static void destruct_pairlEintcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,char*>*)
   {
      pair<int,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,char*>", "utility", 208,
                  typeid(pair<int,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,char*>) );
      instance.SetNew(&new_pairlEintcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEintcOcharmUgR);
      instance.SetDelete(&delete_pairlEintcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEintcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<int,char*>","std::pair<int, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,char*>*)nullptr)->GetClass();
      pairlEintcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOvoidmUgR_Dictionary();
   static void pairlEintcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEintcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEintcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEintcOvoidmUgR(void *p);
   static void deleteArray_pairlEintcOvoidmUgR(void *p);
   static void destruct_pairlEintcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,void*>*)
   {
      pair<int,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,void*>", "utility", 208,
                  typeid(pair<int,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,void*>) );
      instance.SetNew(&new_pairlEintcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEintcOvoidmUgR);
      instance.SetDelete(&delete_pairlEintcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEintcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<int,void*>","std::pair<int, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,void*>*)nullptr)->GetClass();
      pairlEintcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOdoublegR_Dictionary();
   static void pairlEintcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEintcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEintcOdoublegR(Long_t size, void *p);
   static void delete_pairlEintcOdoublegR(void *p);
   static void deleteArray_pairlEintcOdoublegR(void *p);
   static void destruct_pairlEintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,double>*)
   {
      pair<int,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,double>", "utility", 208,
                  typeid(pair<int,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,double>) );
      instance.SetNew(&new_pairlEintcOdoublegR);
      instance.SetNewArray(&newArray_pairlEintcOdoublegR);
      instance.SetDelete(&delete_pairlEintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOdoublegR);
      instance.SetDestructor(&destruct_pairlEintcOdoublegR);

      ::ROOT::AddClassAlternate("pair<int,double>","std::pair<int, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,double>*)nullptr)->GetClass();
      pairlEintcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOfloatgR_Dictionary();
   static void pairlEintcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEintcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEintcOfloatgR(Long_t size, void *p);
   static void delete_pairlEintcOfloatgR(void *p);
   static void deleteArray_pairlEintcOfloatgR(void *p);
   static void destruct_pairlEintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,float>*)
   {
      pair<int,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,float>", "utility", 208,
                  typeid(pair<int,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,float>) );
      instance.SetNew(&new_pairlEintcOfloatgR);
      instance.SetNewArray(&newArray_pairlEintcOfloatgR);
      instance.SetDelete(&delete_pairlEintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOfloatgR);
      instance.SetDestructor(&destruct_pairlEintcOfloatgR);

      ::ROOT::AddClassAlternate("pair<int,float>","std::pair<int, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,float>*)nullptr)->GetClass();
      pairlEintcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEintcOlonggR_Dictionary();
   static void pairlEintcOlonggR_TClassManip(TClass*);
   static void *new_pairlEintcOlonggR(void *p = nullptr);
   static void *newArray_pairlEintcOlonggR(Long_t size, void *p);
   static void delete_pairlEintcOlonggR(void *p);
   static void deleteArray_pairlEintcOlonggR(void *p);
   static void destruct_pairlEintcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,long>*)
   {
      pair<int,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,long>", "utility", 208,
                  typeid(pair<int,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,long>) );
      instance.SetNew(&new_pairlEintcOlonggR);
      instance.SetNewArray(&newArray_pairlEintcOlonggR);
      instance.SetDelete(&delete_pairlEintcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOlonggR);
      instance.SetDestructor(&destruct_pairlEintcOlonggR);

      ::ROOT::AddClassAlternate("pair<int,long>","std::pair<int, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,long>*)nullptr)->GetClass();
      pairlEintcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcOvoidmUgR_Dictionary();
   static void pairlEstringcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEstringcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEstringcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEstringcOvoidmUgR(void *p);
   static void deleteArray_pairlEstringcOvoidmUgR(void *p);
   static void destruct_pairlEstringcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,void*>*)
   {
      pair<string,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,void*>", "utility", 208,
                  typeid(pair<string,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,void*>) );
      instance.SetNew(&new_pairlEstringcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEstringcOvoidmUgR);
      instance.SetDelete(&delete_pairlEstringcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEstringcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<string,void*>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,void*>*)nullptr)->GetClass();
      pairlEstringcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcOdoublegR_Dictionary();
   static void pairlEstringcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEstringcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEstringcOdoublegR(Long_t size, void *p);
   static void delete_pairlEstringcOdoublegR(void *p);
   static void deleteArray_pairlEstringcOdoublegR(void *p);
   static void destruct_pairlEstringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,double>*)
   {
      pair<string,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,double>", "utility", 208,
                  typeid(pair<string,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,double>) );
      instance.SetNew(&new_pairlEstringcOdoublegR);
      instance.SetNewArray(&newArray_pairlEstringcOdoublegR);
      instance.SetDelete(&delete_pairlEstringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOdoublegR);
      instance.SetDestructor(&destruct_pairlEstringcOdoublegR);

      ::ROOT::AddClassAlternate("pair<string,double>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,double>*)nullptr)->GetClass();
      pairlEstringcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcOfloatgR_Dictionary();
   static void pairlEstringcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEstringcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEstringcOfloatgR(Long_t size, void *p);
   static void delete_pairlEstringcOfloatgR(void *p);
   static void deleteArray_pairlEstringcOfloatgR(void *p);
   static void destruct_pairlEstringcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,float>*)
   {
      pair<string,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,float>", "utility", 208,
                  typeid(pair<string,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,float>) );
      instance.SetNew(&new_pairlEstringcOfloatgR);
      instance.SetNewArray(&newArray_pairlEstringcOfloatgR);
      instance.SetDelete(&delete_pairlEstringcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOfloatgR);
      instance.SetDestructor(&destruct_pairlEstringcOfloatgR);

      ::ROOT::AddClassAlternate("pair<string,float>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,float>*)nullptr)->GetClass();
      pairlEstringcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcOlonggR_Dictionary();
   static void pairlEstringcOlonggR_TClassManip(TClass*);
   static void *new_pairlEstringcOlonggR(void *p = nullptr);
   static void *newArray_pairlEstringcOlonggR(Long_t size, void *p);
   static void delete_pairlEstringcOlonggR(void *p);
   static void deleteArray_pairlEstringcOlonggR(void *p);
   static void destruct_pairlEstringcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,long>*)
   {
      pair<string,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,long>", "utility", 208,
                  typeid(pair<string,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,long>) );
      instance.SetNew(&new_pairlEstringcOlonggR);
      instance.SetNewArray(&newArray_pairlEstringcOlonggR);
      instance.SetDelete(&delete_pairlEstringcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOlonggR);
      instance.SetDestructor(&destruct_pairlEstringcOlonggR);

      ::ROOT::AddClassAlternate("pair<string,long>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,long>*)nullptr)->GetClass();
      pairlEstringcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOcharmUgR_Dictionary();
   static void pairlEcharmUcOcharmUgR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOcharmUgR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOcharmUgR(void *p);
   static void deleteArray_pairlEcharmUcOcharmUgR(void *p);
   static void destruct_pairlEcharmUcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,char*>*)
   {
      pair<char*,char*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,char*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,char*>", "utility", 208,
                  typeid(pair<char*,char*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,char*>) );
      instance.SetNew(&new_pairlEcharmUcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOcharmUgR);
      instance.SetDelete(&delete_pairlEcharmUcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOcharmUgR);

      ::ROOT::AddClassAlternate("pair<char*,char*>","std::pair<char*, char*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,char*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOcharmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,char*>*)nullptr)->GetClass();
      pairlEcharmUcOcharmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOcharmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOvoidmUgR_Dictionary();
   static void pairlEcharmUcOvoidmUgR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOvoidmUgR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOvoidmUgR(void *p);
   static void deleteArray_pairlEcharmUcOvoidmUgR(void *p);
   static void destruct_pairlEcharmUcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,void*>*)
   {
      pair<char*,void*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,void*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,void*>", "utility", 208,
                  typeid(pair<char*,void*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,void*>) );
      instance.SetNew(&new_pairlEcharmUcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOvoidmUgR);
      instance.SetDelete(&delete_pairlEcharmUcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOvoidmUgR);

      ::ROOT::AddClassAlternate("pair<char*,void*>","std::pair<char*, void*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,void*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOvoidmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,void*>*)nullptr)->GetClass();
      pairlEcharmUcOvoidmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOvoidmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOdoublegR_Dictionary();
   static void pairlEcharmUcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOdoublegR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOdoublegR(Long_t size, void *p);
   static void delete_pairlEcharmUcOdoublegR(void *p);
   static void deleteArray_pairlEcharmUcOdoublegR(void *p);
   static void destruct_pairlEcharmUcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,double>*)
   {
      pair<char*,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,double>", "utility", 208,
                  typeid(pair<char*,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,double>) );
      instance.SetNew(&new_pairlEcharmUcOdoublegR);
      instance.SetNewArray(&newArray_pairlEcharmUcOdoublegR);
      instance.SetDelete(&delete_pairlEcharmUcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOdoublegR);
      instance.SetDestructor(&destruct_pairlEcharmUcOdoublegR);

      ::ROOT::AddClassAlternate("pair<char*,double>","std::pair<char*, double>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,double>*)nullptr)->GetClass();
      pairlEcharmUcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOfloatgR_Dictionary();
   static void pairlEcharmUcOfloatgR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOfloatgR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOfloatgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOfloatgR(void *p);
   static void deleteArray_pairlEcharmUcOfloatgR(void *p);
   static void destruct_pairlEcharmUcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,float>*)
   {
      pair<char*,float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,float>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,float>", "utility", 208,
                  typeid(pair<char*,float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,float>) );
      instance.SetNew(&new_pairlEcharmUcOfloatgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOfloatgR);
      instance.SetDelete(&delete_pairlEcharmUcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOfloatgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOfloatgR);

      ::ROOT::AddClassAlternate("pair<char*,float>","std::pair<char*, float>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,float>*)nullptr)->GetClass();
      pairlEcharmUcOfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOlonggR_Dictionary();
   static void pairlEcharmUcOlonggR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOlonggR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOlonggR(Long_t size, void *p);
   static void delete_pairlEcharmUcOlonggR(void *p);
   static void deleteArray_pairlEcharmUcOlonggR(void *p);
   static void destruct_pairlEcharmUcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,long>*)
   {
      pair<char*,long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,long>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,long>", "utility", 208,
                  typeid(pair<char*,long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,long>) );
      instance.SetNew(&new_pairlEcharmUcOlonggR);
      instance.SetNewArray(&newArray_pairlEcharmUcOlonggR);
      instance.SetDelete(&delete_pairlEcharmUcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOlonggR);
      instance.SetDestructor(&destruct_pairlEcharmUcOlonggR);

      ::ROOT::AddClassAlternate("pair<char*,long>","std::pair<char*, long>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,long>*)nullptr)->GetClass();
      pairlEcharmUcOlonggR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcharmUcOintgR_Dictionary();
   static void pairlEcharmUcOintgR_TClassManip(TClass*);
   static void *new_pairlEcharmUcOintgR(void *p = nullptr);
   static void *newArray_pairlEcharmUcOintgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOintgR(void *p);
   static void deleteArray_pairlEcharmUcOintgR(void *p);
   static void destruct_pairlEcharmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,int>*)
   {
      pair<char*,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,int>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,int>", "utility", 208,
                  typeid(pair<char*,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcharmUcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,int>) );
      instance.SetNew(&new_pairlEcharmUcOintgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOintgR);
      instance.SetDelete(&delete_pairlEcharmUcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOintgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOintgR);

      ::ROOT::AddClassAlternate("pair<char*,int>","std::pair<char*, int>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<char*,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcharmUcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<char*,int>*)nullptr)->GetClass();
      pairlEcharmUcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcharmUcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_Dictionary();
   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p = nullptr);
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(Long_t size, void *p);
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p);
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p);
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >*)
   {
      ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >));
      static ::ROOT::TGenericClassInfo 
         instance("reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >", "algorithm", 105,
                  typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >) );
      instance.SetNew(&new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR);
      instance.SetNewArray(&newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR);
      instance.SetDelete(&delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR);
      instance.SetDestructor(&destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR);

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >","vector<TString>::reverse_iterator");

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >","std::reverse_iterator<__gnu_cxx::__normal_iterator<TString*, std::vector<TString, std::allocator<TString> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >*)nullptr)->GetClass();
      reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_Dictionary();
   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p = nullptr);
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(Long_t size, void *p);
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p);
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p);
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >*)
   {
      ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >", "algorithm", 105,
                  typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >) );
      instance.SetNew(&new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR);
      instance.SetNewArray(&newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR);
      instance.SetDelete(&delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR);

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >","vector<Int_t>::reverse_iterator");

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >","std::reverse_iterator<__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >*)nullptr)->GetClass();
      reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_Dictionary();
   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p = nullptr);
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(Long_t size, void *p);
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >*)
   {
      ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >", "algorithm", 105,
                  typeid(::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >) );
      instance.SetNew(&new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR);
      instance.SetNewArray(&newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR);
      instance.SetDelete(&delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR);

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >","vector<string>::reverse_iterator");

      ::ROOT::AddClassAlternate("reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >","std::reverse_iterator<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >*)nullptr)->GetClass();
      reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<char*,string>*)
   {
      ::__gnu_cxx::__normal_iterator<char*,string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<char*,string>));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<char*,string>", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<char*,string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<char*,string>) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<char*,string>","string::iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<char*,string>","__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<char*,string>*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<char*,string>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<char*,string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<char*,string>*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const char*,string>*)
   {
      ::__gnu_cxx::__normal_iterator<const char*,string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const char*,string>));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const char*,string>", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<const char*,string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const char*,string>) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const char*,string>","string::const_iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const char*,string>","__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const char*,string>*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const char*,string>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const char*,string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const char*,string>*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)
   {
      ::__gnu_cxx::__normal_iterator<TString*,vector<TString> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<TString*,vector<TString> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<TString*,vector<TString> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<TString*,vector<TString> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<TString*,vector<TString> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<TString*,vector<TString> >","vector<TString>::iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<TString*,vector<TString> >","__gnu_cxx::__normal_iterator<TString*, std::vector<TString, std::allocator<TString> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)
   {
      ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const TString*,vector<TString> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const TString*,vector<TString> >","vector<TString>::const_iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const TString*,vector<TString> >","__gnu_cxx::__normal_iterator<TString const*, std::vector<TString, std::allocator<TString> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)
   {
      ::__gnu_cxx::__normal_iterator<const int*,vector<int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const int*,vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const int*,vector<int> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<const int*,vector<int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const int*,vector<int> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const int*,vector<int> >","vector<Int_t>::const_iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const int*,vector<int> >","__gnu_cxx::__normal_iterator<int const*, std::vector<int, std::allocator<int> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<int*,vector<int> >*)
   {
      ::__gnu_cxx::__normal_iterator<int*,vector<int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<int*,vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<int*,vector<int> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<int*,vector<int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<int*,vector<int> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<int*,vector<int> >","vector<Int_t>::iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<int*,vector<int> >","__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<int*,vector<int> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<int*,vector<int> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<int*,vector<int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<int*,vector<int> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)
   {
      ::__gnu_cxx::__normal_iterator<const string*,vector<string> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const string*,vector<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const string*,vector<string> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<const string*,vector<string> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const string*,vector<string> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const string*,vector<string> >","vector<string>::const_iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const string*,vector<string> >","__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p = nullptr);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<string*,vector<string> >*)
   {
      ::__gnu_cxx::__normal_iterator<string*,vector<string> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<string*,vector<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<string*,vector<string> >", "algorithm", 787,
                  typeid(::__gnu_cxx::__normal_iterator<string*,vector<string> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<string*,vector<string> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR);

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<string*,vector<string> >","vector<string>::iterator");

      ::ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<string*,vector<string> >","__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<string*,vector<string> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<string*,vector<string> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<string*,vector<string> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<string*,vector<string> >*)nullptr)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TVirtualIsAProxy_Dictionary();
   static void TVirtualIsAProxy_TClassManip(TClass*);
   static void delete_TVirtualIsAProxy(void *p);
   static void deleteArray_TVirtualIsAProxy(void *p);
   static void destruct_TVirtualIsAProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualIsAProxy*)
   {
      ::TVirtualIsAProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TVirtualIsAProxy));
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualIsAProxy", "TVirtualIsAProxy.h", 27,
                  typeid(::TVirtualIsAProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TVirtualIsAProxy_Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualIsAProxy) );
      instance.SetDelete(&delete_TVirtualIsAProxy);
      instance.SetDeleteArray(&deleteArray_TVirtualIsAProxy);
      instance.SetDestructor(&destruct_TVirtualIsAProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualIsAProxy*)
   {
      return GenerateInitInstanceLocal((::TVirtualIsAProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualIsAProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TVirtualIsAProxy_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TVirtualIsAProxy*)nullptr)->GetClass();
      TVirtualIsAProxy_TClassManip(theClass);
   return theClass;
   }

   static void TVirtualIsAProxy_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TIsAProxy_Dictionary();
   static void TIsAProxy_TClassManip(TClass*);
   static void delete_TIsAProxy(void *p);
   static void deleteArray_TIsAProxy(void *p);
   static void destruct_TIsAProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TIsAProxy*)
   {
      ::TIsAProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TIsAProxy));
      static ::ROOT::TGenericClassInfo 
         instance("TIsAProxy", "TIsAProxy.h", 27,
                  typeid(::TIsAProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TIsAProxy_Dictionary, isa_proxy, 0,
                  sizeof(::TIsAProxy) );
      instance.SetDelete(&delete_TIsAProxy);
      instance.SetDeleteArray(&deleteArray_TIsAProxy);
      instance.SetDestructor(&destruct_TIsAProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TIsAProxy*)
   {
      return GenerateInitInstanceLocal((::TIsAProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TIsAProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TIsAProxy_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TIsAProxy*)nullptr)->GetClass();
      TIsAProxy_TClassManip(theClass);
   return theClass;
   }

   static void TIsAProxy_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TStorage(void *p = nullptr);
   static void *newArray_TStorage(Long_t size, void *p);
   static void delete_TStorage(void *p);
   static void deleteArray_TStorage(void *p);
   static void destruct_TStorage(void *p);
   static void streamer_TStorage(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStorage*)
   {
      ::TStorage *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStorage >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStorage", ::TStorage::Class_Version(), "TStorage.h", 33,
                  typeid(::TStorage), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStorage::Dictionary, isa_proxy, 16,
                  sizeof(::TStorage) );
      instance.SetNew(&new_TStorage);
      instance.SetNewArray(&newArray_TStorage);
      instance.SetDelete(&delete_TStorage);
      instance.SetDeleteArray(&deleteArray_TStorage);
      instance.SetDestructor(&destruct_TStorage);
      instance.SetStreamerFunc(&streamer_TStorage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStorage*)
   {
      return GenerateInitInstanceLocal((::TStorage*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStorage*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TObject(void *p = nullptr);
   static void *newArray_TObject(Long_t size, void *p);
   static void delete_TObject(void *p);
   static void deleteArray_TObject(void *p);
   static void destruct_TObject(void *p);
   static void streamer_TObject(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObject*)
   {
      ::TObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObject", ::TObject::Class_Version(), "TObject.h", 37,
                  typeid(::TObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObject::Dictionary, isa_proxy, 17,
                  sizeof(::TObject) );
      instance.SetNew(&new_TObject);
      instance.SetNewArray(&newArray_TObject);
      instance.SetDelete(&delete_TObject);
      instance.SetDeleteArray(&deleteArray_TObject);
      instance.SetDestructor(&destruct_TObject);
      instance.SetStreamerFunc(&streamer_TObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObject*)
   {
      return GenerateInitInstanceLocal((::TObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TIterator(void *p);
   static void deleteArray_TIterator(void *p);
   static void destruct_TIterator(void *p);
   static void streamer_TIterator(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TIterator*)
   {
      ::TIterator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TIterator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TIterator", ::TIterator::Class_Version(), "TIterator.h", 30,
                  typeid(::TIterator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TIterator::Dictionary, isa_proxy, 16,
                  sizeof(::TIterator) );
      instance.SetDelete(&delete_TIterator);
      instance.SetDeleteArray(&deleteArray_TIterator);
      instance.SetDestructor(&destruct_TIterator);
      instance.SetStreamerFunc(&streamer_TIterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TIterator*)
   {
      return GenerateInitInstanceLocal((::TIterator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TIterator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TSubString_Dictionary();
   static void TSubString_TClassManip(TClass*);
   static void delete_TSubString(void *p);
   static void deleteArray_TSubString(void *p);
   static void destruct_TSubString(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSubString*)
   {
      ::TSubString *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TSubString));
      static ::ROOT::TGenericClassInfo 
         instance("TSubString", "TString.h", 82,
                  typeid(::TSubString), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TSubString_Dictionary, isa_proxy, 0,
                  sizeof(::TSubString) );
      instance.SetDelete(&delete_TSubString);
      instance.SetDeleteArray(&deleteArray_TSubString);
      instance.SetDestructor(&destruct_TSubString);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSubString*)
   {
      return GenerateInitInstanceLocal((::TSubString*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSubString*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TSubString_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TSubString*)nullptr)->GetClass();
      TSubString_TClassManip(theClass);
   return theClass;
   }

   static void TSubString_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TString(void *p = nullptr);
   static void *newArray_TString(Long_t size, void *p);
   static void delete_TString(void *p);
   static void deleteArray_TString(void *p);
   static void destruct_TString(void *p);
   static void streamer_TString(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TString*)
   {
      ::TString *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TString >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TString", ::TString::Class_Version(), "TString.h", 136,
                  typeid(::TString), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TString::Dictionary, isa_proxy, 19,
                  sizeof(::TString) );
      instance.SetNew(&new_TString);
      instance.SetNewArray(&newArray_TString);
      instance.SetDelete(&delete_TString);
      instance.SetDeleteArray(&deleteArray_TString);
      instance.SetDestructor(&destruct_TString);
      instance.SetStreamerFunc(&streamer_TString);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TString*)
   {
      return GenerateInitInstanceLocal((::TString*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TString*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualMutex(void *p);
   static void deleteArray_TVirtualMutex(void *p);
   static void destruct_TVirtualMutex(void *p);
   static void streamer_TVirtualMutex(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMutex*)
   {
      ::TVirtualMutex *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMutex >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMutex", ::TVirtualMutex::Class_Version(), "TVirtualMutex.h", 32,
                  typeid(::TVirtualMutex), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualMutex::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualMutex) );
      instance.SetDelete(&delete_TVirtualMutex);
      instance.SetDeleteArray(&deleteArray_TVirtualMutex);
      instance.SetDestructor(&destruct_TVirtualMutex);
      instance.SetStreamerFunc(&streamer_TVirtualMutex);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMutex*)
   {
      return GenerateInitInstanceLocal((::TVirtualMutex*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualMutex*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TLockGuard(void *p);
   static void deleteArray_TLockGuard(void *p);
   static void destruct_TLockGuard(void *p);
   static void streamer_TLockGuard(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TLockGuard*)
   {
      ::TLockGuard *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TLockGuard >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TLockGuard", ::TLockGuard::Class_Version(), "TVirtualMutex.h", 70,
                  typeid(::TLockGuard), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TLockGuard::Dictionary, isa_proxy, 16,
                  sizeof(::TLockGuard) );
      instance.SetDelete(&delete_TLockGuard);
      instance.SetDeleteArray(&deleteArray_TLockGuard);
      instance.SetDestructor(&destruct_TLockGuard);
      instance.SetStreamerFunc(&streamer_TLockGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TLockGuard*)
   {
      return GenerateInitInstanceLocal((::TLockGuard*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TLockGuard*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_ROOTcLcLTVirtualRWMutex(void *p);
   static void deleteArray_ROOTcLcLTVirtualRWMutex(void *p);
   static void destruct_ROOTcLcLTVirtualRWMutex(void *p);
   static void streamer_ROOTcLcLTVirtualRWMutex(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::TVirtualRWMutex*)
   {
      ::ROOT::TVirtualRWMutex *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::TVirtualRWMutex >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::TVirtualRWMutex", ::ROOT::TVirtualRWMutex::Class_Version(), "TVirtualRWMutex.h", 39,
                  typeid(::ROOT::TVirtualRWMutex), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::TVirtualRWMutex::Dictionary, isa_proxy, 16,
                  sizeof(::ROOT::TVirtualRWMutex) );
      instance.SetDelete(&delete_ROOTcLcLTVirtualRWMutex);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLTVirtualRWMutex);
      instance.SetDestructor(&destruct_ROOTcLcLTVirtualRWMutex);
      instance.SetStreamerFunc(&streamer_ROOTcLcLTVirtualRWMutex);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::TVirtualRWMutex*)
   {
      return GenerateInitInstanceLocal((::ROOT::TVirtualRWMutex*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::TVirtualRWMutex*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_ROOTcLcLTReadLockGuard(void *p);
   static void deleteArray_ROOTcLcLTReadLockGuard(void *p);
   static void destruct_ROOTcLcLTReadLockGuard(void *p);
   static void streamer_ROOTcLcLTReadLockGuard(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::TReadLockGuard*)
   {
      ::ROOT::TReadLockGuard *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::TReadLockGuard >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::TReadLockGuard", ::ROOT::TReadLockGuard::Class_Version(), "TVirtualRWMutex.h", 112,
                  typeid(::ROOT::TReadLockGuard), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::TReadLockGuard::Dictionary, isa_proxy, 16,
                  sizeof(::ROOT::TReadLockGuard) );
      instance.SetDelete(&delete_ROOTcLcLTReadLockGuard);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLTReadLockGuard);
      instance.SetDestructor(&destruct_ROOTcLcLTReadLockGuard);
      instance.SetStreamerFunc(&streamer_ROOTcLcLTReadLockGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::TReadLockGuard*)
   {
      return GenerateInitInstanceLocal((::ROOT::TReadLockGuard*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::TReadLockGuard*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_ROOTcLcLTWriteLockGuard(void *p);
   static void deleteArray_ROOTcLcLTWriteLockGuard(void *p);
   static void destruct_ROOTcLcLTWriteLockGuard(void *p);
   static void streamer_ROOTcLcLTWriteLockGuard(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::TWriteLockGuard*)
   {
      ::ROOT::TWriteLockGuard *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::TWriteLockGuard >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::TWriteLockGuard", ::ROOT::TWriteLockGuard::Class_Version(), "TVirtualRWMutex.h", 131,
                  typeid(::ROOT::TWriteLockGuard), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::TWriteLockGuard::Dictionary, isa_proxy, 16,
                  sizeof(::ROOT::TWriteLockGuard) );
      instance.SetDelete(&delete_ROOTcLcLTWriteLockGuard);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLTWriteLockGuard);
      instance.SetDestructor(&destruct_ROOTcLcLTWriteLockGuard);
      instance.SetStreamerFunc(&streamer_ROOTcLcLTWriteLockGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::TWriteLockGuard*)
   {
      return GenerateInitInstanceLocal((::ROOT::TWriteLockGuard*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::TWriteLockGuard*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TCollection(void *p);
   static void deleteArray_TCollection(void *p);
   static void destruct_TCollection(void *p);
   static void streamer_TCollection(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TCollection*)
   {
      ::TCollection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TCollection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TCollection", ::TCollection::Class_Version(), "TCollection.h", 65,
                  typeid(::TCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TCollection::Dictionary, isa_proxy, 17,
                  sizeof(::TCollection) );
      instance.SetDelete(&delete_TCollection);
      instance.SetDeleteArray(&deleteArray_TCollection);
      instance.SetDestructor(&destruct_TCollection);
      instance.SetStreamerFunc(&streamer_TCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TCollection*)
   {
      return GenerateInitInstanceLocal((::TCollection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TCollection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TIter(void *p);
   static void deleteArray_TIter(void *p);
   static void destruct_TIter(void *p);
   static void streamer_TIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TIter*)
   {
      ::TIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TIter", ::TIter::Class_Version(), "TCollection.h", 235,
                  typeid(::TIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TIter::Dictionary, isa_proxy, 16,
                  sizeof(::TIter) );
      instance.SetDelete(&delete_TIter);
      instance.SetDeleteArray(&deleteArray_TIter);
      instance.SetDestructor(&destruct_TIter);
      instance.SetStreamerFunc(&streamer_TIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TIter*)
   {
      return GenerateInitInstanceLocal((::TIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TSeqCollection(void *p);
   static void deleteArray_TSeqCollection(void *p);
   static void destruct_TSeqCollection(void *p);
   static void streamer_TSeqCollection(TBuffer &buf, void *obj);
   static Long64_t merge_TSeqCollection(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSeqCollection*)
   {
      ::TSeqCollection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSeqCollection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSeqCollection", ::TSeqCollection::Class_Version(), "TSeqCollection.h", 28,
                  typeid(::TSeqCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSeqCollection::Dictionary, isa_proxy, 16,
                  sizeof(::TSeqCollection) );
      instance.SetDelete(&delete_TSeqCollection);
      instance.SetDeleteArray(&deleteArray_TSeqCollection);
      instance.SetDestructor(&destruct_TSeqCollection);
      instance.SetStreamerFunc(&streamer_TSeqCollection);
      instance.SetMerge(&merge_TSeqCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSeqCollection*)
   {
      return GenerateInitInstanceLocal((::TSeqCollection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSeqCollection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TList(void *p = nullptr);
   static void *newArray_TList(Long_t size, void *p);
   static void delete_TList(void *p);
   static void deleteArray_TList(void *p);
   static void destruct_TList(void *p);
   static void streamer_TList(TBuffer &buf, void *obj);
   static Long64_t merge_TList(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TList*)
   {
      ::TList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TList", ::TList::Class_Version(), "TList.h", 44,
                  typeid(::TList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TList::Dictionary, isa_proxy, 17,
                  sizeof(::TList) );
      instance.SetNew(&new_TList);
      instance.SetNewArray(&newArray_TList);
      instance.SetDelete(&delete_TList);
      instance.SetDeleteArray(&deleteArray_TList);
      instance.SetDestructor(&destruct_TList);
      instance.SetStreamerFunc(&streamer_TList);
      instance.SetMerge(&merge_TList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TList*)
   {
      return GenerateInitInstanceLocal((::TList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListIter(void *p);
   static void deleteArray_TListIter(void *p);
   static void destruct_TListIter(void *p);
   static void streamer_TListIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListIter*)
   {
      ::TListIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListIter", ::TListIter::Class_Version(), "TList.h", 197,
                  typeid(::TListIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListIter::Dictionary, isa_proxy, 16,
                  sizeof(::TListIter) );
      instance.SetDelete(&delete_TListIter);
      instance.SetDeleteArray(&deleteArray_TListIter);
      instance.SetDestructor(&destruct_TListIter);
      instance.SetStreamerFunc(&streamer_TListIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListIter*)
   {
      return GenerateInitInstanceLocal((::TListIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *SetWindowAttributes_t_Dictionary();
   static void SetWindowAttributes_t_TClassManip(TClass*);
   static void *new_SetWindowAttributes_t(void *p = nullptr);
   static void *newArray_SetWindowAttributes_t(Long_t size, void *p);
   static void delete_SetWindowAttributes_t(void *p);
   static void deleteArray_SetWindowAttributes_t(void *p);
   static void destruct_SetWindowAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SetWindowAttributes_t*)
   {
      ::SetWindowAttributes_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SetWindowAttributes_t));
      static ::ROOT::TGenericClassInfo 
         instance("SetWindowAttributes_t", "GuiTypes.h", 93,
                  typeid(::SetWindowAttributes_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &SetWindowAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::SetWindowAttributes_t) );
      instance.SetNew(&new_SetWindowAttributes_t);
      instance.SetNewArray(&newArray_SetWindowAttributes_t);
      instance.SetDelete(&delete_SetWindowAttributes_t);
      instance.SetDeleteArray(&deleteArray_SetWindowAttributes_t);
      instance.SetDestructor(&destruct_SetWindowAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SetWindowAttributes_t*)
   {
      return GenerateInitInstanceLocal((::SetWindowAttributes_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::SetWindowAttributes_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SetWindowAttributes_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SetWindowAttributes_t*)nullptr)->GetClass();
      SetWindowAttributes_t_TClassManip(theClass);
   return theClass;
   }

   static void SetWindowAttributes_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *WindowAttributes_t_Dictionary();
   static void WindowAttributes_t_TClassManip(TClass*);
   static void *new_WindowAttributes_t(void *p = nullptr);
   static void *newArray_WindowAttributes_t(Long_t size, void *p);
   static void delete_WindowAttributes_t(void *p);
   static void deleteArray_WindowAttributes_t(void *p);
   static void destruct_WindowAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::WindowAttributes_t*)
   {
      ::WindowAttributes_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::WindowAttributes_t));
      static ::ROOT::TGenericClassInfo 
         instance("WindowAttributes_t", "GuiTypes.h", 114,
                  typeid(::WindowAttributes_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &WindowAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::WindowAttributes_t) );
      instance.SetNew(&new_WindowAttributes_t);
      instance.SetNewArray(&newArray_WindowAttributes_t);
      instance.SetDelete(&delete_WindowAttributes_t);
      instance.SetDeleteArray(&deleteArray_WindowAttributes_t);
      instance.SetDestructor(&destruct_WindowAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::WindowAttributes_t*)
   {
      return GenerateInitInstanceLocal((::WindowAttributes_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::WindowAttributes_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *WindowAttributes_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::WindowAttributes_t*)nullptr)->GetClass();
      WindowAttributes_t_TClassManip(theClass);
   return theClass;
   }

   static void WindowAttributes_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Event_t_Dictionary();
   static void Event_t_TClassManip(TClass*);
   static void *new_Event_t(void *p = nullptr);
   static void *newArray_Event_t(Long_t size, void *p);
   static void delete_Event_t(void *p);
   static void deleteArray_Event_t(void *p);
   static void destruct_Event_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Event_t*)
   {
      ::Event_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Event_t));
      static ::ROOT::TGenericClassInfo 
         instance("Event_t", "GuiTypes.h", 174,
                  typeid(::Event_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &Event_t_Dictionary, isa_proxy, 0,
                  sizeof(::Event_t) );
      instance.SetNew(&new_Event_t);
      instance.SetNewArray(&newArray_Event_t);
      instance.SetDelete(&delete_Event_t);
      instance.SetDeleteArray(&deleteArray_Event_t);
      instance.SetDestructor(&destruct_Event_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Event_t*)
   {
      return GenerateInitInstanceLocal((::Event_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Event_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Event_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Event_t*)nullptr)->GetClass();
      Event_t_TClassManip(theClass);
   return theClass;
   }

   static void Event_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GCValues_t_Dictionary();
   static void GCValues_t_TClassManip(TClass*);
   static void *new_GCValues_t(void *p = nullptr);
   static void *newArray_GCValues_t(Long_t size, void *p);
   static void delete_GCValues_t(void *p);
   static void deleteArray_GCValues_t(void *p);
   static void destruct_GCValues_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GCValues_t*)
   {
      ::GCValues_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GCValues_t));
      static ::ROOT::TGenericClassInfo 
         instance("GCValues_t", "GuiTypes.h", 224,
                  typeid(::GCValues_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &GCValues_t_Dictionary, isa_proxy, 0,
                  sizeof(::GCValues_t) );
      instance.SetNew(&new_GCValues_t);
      instance.SetNewArray(&newArray_GCValues_t);
      instance.SetDelete(&delete_GCValues_t);
      instance.SetDeleteArray(&deleteArray_GCValues_t);
      instance.SetDestructor(&destruct_GCValues_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GCValues_t*)
   {
      return GenerateInitInstanceLocal((::GCValues_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::GCValues_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GCValues_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GCValues_t*)nullptr)->GetClass();
      GCValues_t_TClassManip(theClass);
   return theClass;
   }

   static void GCValues_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *ColorStruct_t_Dictionary();
   static void ColorStruct_t_TClassManip(TClass*);
   static void *new_ColorStruct_t(void *p = nullptr);
   static void *newArray_ColorStruct_t(Long_t size, void *p);
   static void delete_ColorStruct_t(void *p);
   static void deleteArray_ColorStruct_t(void *p);
   static void destruct_ColorStruct_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ColorStruct_t*)
   {
      ::ColorStruct_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ColorStruct_t));
      static ::ROOT::TGenericClassInfo 
         instance("ColorStruct_t", "GuiTypes.h", 310,
                  typeid(::ColorStruct_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &ColorStruct_t_Dictionary, isa_proxy, 0,
                  sizeof(::ColorStruct_t) );
      instance.SetNew(&new_ColorStruct_t);
      instance.SetNewArray(&newArray_ColorStruct_t);
      instance.SetDelete(&delete_ColorStruct_t);
      instance.SetDeleteArray(&deleteArray_ColorStruct_t);
      instance.SetDestructor(&destruct_ColorStruct_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ColorStruct_t*)
   {
      return GenerateInitInstanceLocal((::ColorStruct_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ColorStruct_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ColorStruct_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ColorStruct_t*)nullptr)->GetClass();
      ColorStruct_t_TClassManip(theClass);
   return theClass;
   }

   static void ColorStruct_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PictureAttributes_t_Dictionary();
   static void PictureAttributes_t_TClassManip(TClass*);
   static void *new_PictureAttributes_t(void *p = nullptr);
   static void *newArray_PictureAttributes_t(Long_t size, void *p);
   static void delete_PictureAttributes_t(void *p);
   static void deleteArray_PictureAttributes_t(void *p);
   static void destruct_PictureAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PictureAttributes_t*)
   {
      ::PictureAttributes_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PictureAttributes_t));
      static ::ROOT::TGenericClassInfo 
         instance("PictureAttributes_t", "GuiTypes.h", 323,
                  typeid(::PictureAttributes_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &PictureAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::PictureAttributes_t) );
      instance.SetNew(&new_PictureAttributes_t);
      instance.SetNewArray(&newArray_PictureAttributes_t);
      instance.SetDelete(&delete_PictureAttributes_t);
      instance.SetDeleteArray(&deleteArray_PictureAttributes_t);
      instance.SetDestructor(&destruct_PictureAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PictureAttributes_t*)
   {
      return GenerateInitInstanceLocal((::PictureAttributes_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::PictureAttributes_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PictureAttributes_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PictureAttributes_t*)nullptr)->GetClass();
      PictureAttributes_t_TClassManip(theClass);
   return theClass;
   }

   static void PictureAttributes_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Segment_t_Dictionary();
   static void Segment_t_TClassManip(TClass*);
   static void *new_Segment_t(void *p = nullptr);
   static void *newArray_Segment_t(Long_t size, void *p);
   static void delete_Segment_t(void *p);
   static void deleteArray_Segment_t(void *p);
   static void destruct_Segment_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Segment_t*)
   {
      ::Segment_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Segment_t));
      static ::ROOT::TGenericClassInfo 
         instance("Segment_t", "GuiTypes.h", 351,
                  typeid(::Segment_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &Segment_t_Dictionary, isa_proxy, 0,
                  sizeof(::Segment_t) );
      instance.SetNew(&new_Segment_t);
      instance.SetNewArray(&newArray_Segment_t);
      instance.SetDelete(&delete_Segment_t);
      instance.SetDeleteArray(&deleteArray_Segment_t);
      instance.SetDestructor(&destruct_Segment_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Segment_t*)
   {
      return GenerateInitInstanceLocal((::Segment_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Segment_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Segment_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Segment_t*)nullptr)->GetClass();
      Segment_t_TClassManip(theClass);
   return theClass;
   }

   static void Segment_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Point_t_Dictionary();
   static void Point_t_TClassManip(TClass*);
   static void *new_Point_t(void *p = nullptr);
   static void *newArray_Point_t(Long_t size, void *p);
   static void delete_Point_t(void *p);
   static void deleteArray_Point_t(void *p);
   static void destruct_Point_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Point_t*)
   {
      ::Point_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Point_t));
      static ::ROOT::TGenericClassInfo 
         instance("Point_t", "GuiTypes.h", 356,
                  typeid(::Point_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &Point_t_Dictionary, isa_proxy, 0,
                  sizeof(::Point_t) );
      instance.SetNew(&new_Point_t);
      instance.SetNewArray(&newArray_Point_t);
      instance.SetDelete(&delete_Point_t);
      instance.SetDeleteArray(&deleteArray_Point_t);
      instance.SetDestructor(&destruct_Point_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Point_t*)
   {
      return GenerateInitInstanceLocal((::Point_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Point_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Point_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Point_t*)nullptr)->GetClass();
      Point_t_TClassManip(theClass);
   return theClass;
   }

   static void Point_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Rectangle_t_Dictionary();
   static void Rectangle_t_TClassManip(TClass*);
   static void *new_Rectangle_t(void *p = nullptr);
   static void *newArray_Rectangle_t(Long_t size, void *p);
   static void delete_Rectangle_t(void *p);
   static void deleteArray_Rectangle_t(void *p);
   static void destruct_Rectangle_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Rectangle_t*)
   {
      ::Rectangle_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Rectangle_t));
      static ::ROOT::TGenericClassInfo 
         instance("Rectangle_t", "GuiTypes.h", 361,
                  typeid(::Rectangle_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &Rectangle_t_Dictionary, isa_proxy, 0,
                  sizeof(::Rectangle_t) );
      instance.SetNew(&new_Rectangle_t);
      instance.SetNewArray(&newArray_Rectangle_t);
      instance.SetDelete(&delete_Rectangle_t);
      instance.SetDeleteArray(&deleteArray_Rectangle_t);
      instance.SetDestructor(&destruct_Rectangle_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Rectangle_t*)
   {
      return GenerateInitInstanceLocal((::Rectangle_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Rectangle_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Rectangle_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Rectangle_t*)nullptr)->GetClass();
      Rectangle_t_TClassManip(theClass);
   return theClass;
   }

   static void Rectangle_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TNamed(void *p = nullptr);
   static void *newArray_TNamed(Long_t size, void *p);
   static void delete_TNamed(void *p);
   static void deleteArray_TNamed(void *p);
   static void destruct_TNamed(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TNamed*)
   {
      ::TNamed *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TNamed >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TNamed", ::TNamed::Class_Version(), "TNamed.h", 29,
                  typeid(::TNamed), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TNamed::Dictionary, isa_proxy, 4,
                  sizeof(::TNamed) );
      instance.SetNew(&new_TNamed);
      instance.SetNewArray(&newArray_TNamed);
      instance.SetDelete(&delete_TNamed);
      instance.SetDeleteArray(&deleteArray_TNamed);
      instance.SetDestructor(&destruct_TNamed);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TNamed*)
   {
      return GenerateInitInstanceLocal((::TNamed*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TNamed*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TDictionary(void *p);
   static void deleteArray_TDictionary(void *p);
   static void destruct_TDictionary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDictionary*)
   {
      ::TDictionary *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDictionary >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDictionary", ::TDictionary::Class_Version(), "TDictionary.h", 167,
                  typeid(::TDictionary), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDictionary::Dictionary, isa_proxy, 4,
                  sizeof(::TDictionary) );
      instance.SetDelete(&delete_TDictionary);
      instance.SetDeleteArray(&deleteArray_TDictionary);
      instance.SetDestructor(&destruct_TDictionary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDictionary*)
   {
      return GenerateInitInstanceLocal((::TDictionary*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDictionary*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TDataType(void *p = nullptr);
   static void *newArray_TDataType(Long_t size, void *p);
   static void delete_TDataType(void *p);
   static void deleteArray_TDataType(void *p);
   static void destruct_TDataType(void *p);
   static void streamer_TDataType(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDataType*)
   {
      ::TDataType *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDataType >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDataType", ::TDataType::Class_Version(), "TDataType.h", 44,
                  typeid(::TDataType), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDataType::Dictionary, isa_proxy, 16,
                  sizeof(::TDataType) );
      instance.SetNew(&new_TDataType);
      instance.SetNewArray(&newArray_TDataType);
      instance.SetDelete(&delete_TDataType);
      instance.SetDeleteArray(&deleteArray_TDataType);
      instance.SetDestructor(&destruct_TDataType);
      instance.SetStreamerFunc(&streamer_TDataType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDataType*)
   {
      return GenerateInitInstanceLocal((::TDataType*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDataType*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TInterpreter(void *p);
   static void deleteArray_TInterpreter(void *p);
   static void destruct_TInterpreter(void *p);
   static void streamer_TInterpreter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TInterpreter*)
   {
      ::TInterpreter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TInterpreter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TInterpreter", ::TInterpreter::Class_Version(), "TInterpreter.h", 64,
                  typeid(::TInterpreter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TInterpreter::Dictionary, isa_proxy, 16,
                  sizeof(::TInterpreter) );
      instance.SetDelete(&delete_TInterpreter);
      instance.SetDeleteArray(&deleteArray_TInterpreter);
      instance.SetDestructor(&destruct_TInterpreter);
      instance.SetStreamerFunc(&streamer_TInterpreter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TInterpreter*)
   {
      return GenerateInitInstanceLocal((::TInterpreter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TInterpreter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TQObject(void *p = nullptr);
   static void *newArray_TQObject(Long_t size, void *p);
   static void delete_TQObject(void *p);
   static void deleteArray_TQObject(void *p);
   static void destruct_TQObject(void *p);
   static void streamer_TQObject(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQObject*)
   {
      ::TQObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQObject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQObject", ::TQObject::Class_Version(), "TQObject.h", 48,
                  typeid(::TQObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQObject::Dictionary, isa_proxy, 17,
                  sizeof(::TQObject) );
      instance.SetNew(&new_TQObject);
      instance.SetNewArray(&newArray_TQObject);
      instance.SetDelete(&delete_TQObject);
      instance.SetDeleteArray(&deleteArray_TQObject);
      instance.SetDestructor(&destruct_TQObject);
      instance.SetStreamerFunc(&streamer_TQObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQObject*)
   {
      return GenerateInitInstanceLocal((::TQObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TQObjSender(void *p = nullptr);
   static void *newArray_TQObjSender(Long_t size, void *p);
   static void delete_TQObjSender(void *p);
   static void deleteArray_TQObjSender(void *p);
   static void destruct_TQObjSender(void *p);
   static void streamer_TQObjSender(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQObjSender*)
   {
      ::TQObjSender *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQObjSender >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQObjSender", ::TQObjSender::Class_Version(), "TQObject.h", 232,
                  typeid(::TQObjSender), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQObjSender::Dictionary, isa_proxy, 16,
                  sizeof(::TQObjSender) );
      instance.SetNew(&new_TQObjSender);
      instance.SetNewArray(&newArray_TQObjSender);
      instance.SetDelete(&delete_TQObjSender);
      instance.SetDeleteArray(&deleteArray_TQObjSender);
      instance.SetDestructor(&destruct_TQObjSender);
      instance.SetStreamerFunc(&streamer_TQObjSender);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQObjSender*)
   {
      return GenerateInitInstanceLocal((::TQObjSender*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQObjSender*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TApplicationImp(void *p = nullptr);
   static void *newArray_TApplicationImp(Long_t size, void *p);
   static void delete_TApplicationImp(void *p);
   static void deleteArray_TApplicationImp(void *p);
   static void destruct_TApplicationImp(void *p);
   static void streamer_TApplicationImp(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TApplicationImp*)
   {
      ::TApplicationImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TApplicationImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TApplicationImp", ::TApplicationImp::Class_Version(), "TApplicationImp.h", 29,
                  typeid(::TApplicationImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TApplicationImp::Dictionary, isa_proxy, 16,
                  sizeof(::TApplicationImp) );
      instance.SetNew(&new_TApplicationImp);
      instance.SetNewArray(&newArray_TApplicationImp);
      instance.SetDelete(&delete_TApplicationImp);
      instance.SetDeleteArray(&deleteArray_TApplicationImp);
      instance.SetDestructor(&destruct_TApplicationImp);
      instance.SetStreamerFunc(&streamer_TApplicationImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TApplicationImp*)
   {
      return GenerateInitInstanceLocal((::TApplicationImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TApplicationImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TApplication(void *p);
   static void deleteArray_TApplication(void *p);
   static void destruct_TApplication(void *p);
   static void streamer_TApplication(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TApplication*)
   {
      ::TApplication *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TApplication >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TApplication", ::TApplication::Class_Version(), "TApplication.h", 39,
                  typeid(::TApplication), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TApplication::Dictionary, isa_proxy, 16,
                  sizeof(::TApplication) );
      instance.SetDelete(&delete_TApplication);
      instance.SetDeleteArray(&deleteArray_TApplication);
      instance.SetDestructor(&destruct_TApplication);
      instance.SetStreamerFunc(&streamer_TApplication);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TApplication*)
   {
      return GenerateInitInstanceLocal((::TApplication*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TApplication*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAtt3D(void *p = nullptr);
   static void *newArray_TAtt3D(Long_t size, void *p);
   static void delete_TAtt3D(void *p);
   static void deleteArray_TAtt3D(void *p);
   static void destruct_TAtt3D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAtt3D*)
   {
      ::TAtt3D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAtt3D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAtt3D", ::TAtt3D::Class_Version(), "TAtt3D.h", 19,
                  typeid(::TAtt3D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAtt3D::Dictionary, isa_proxy, 4,
                  sizeof(::TAtt3D) );
      instance.SetNew(&new_TAtt3D);
      instance.SetNewArray(&newArray_TAtt3D);
      instance.SetDelete(&delete_TAtt3D);
      instance.SetDeleteArray(&deleteArray_TAtt3D);
      instance.SetDestructor(&destruct_TAtt3D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAtt3D*)
   {
      return GenerateInitInstanceLocal((::TAtt3D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAtt3D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttAxis(void *p = nullptr);
   static void *newArray_TAttAxis(Long_t size, void *p);
   static void delete_TAttAxis(void *p);
   static void deleteArray_TAttAxis(void *p);
   static void destruct_TAttAxis(void *p);
   static void streamer_TAttAxis(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttAxis*)
   {
      ::TAttAxis *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttAxis >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttAxis", ::TAttAxis::Class_Version(), "TAttAxis.h", 18,
                  typeid(::TAttAxis), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttAxis::Dictionary, isa_proxy, 17,
                  sizeof(::TAttAxis) );
      instance.SetNew(&new_TAttAxis);
      instance.SetNewArray(&newArray_TAttAxis);
      instance.SetDelete(&delete_TAttAxis);
      instance.SetDeleteArray(&deleteArray_TAttAxis);
      instance.SetDestructor(&destruct_TAttAxis);
      instance.SetStreamerFunc(&streamer_TAttAxis);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttAxis*)
   {
      return GenerateInitInstanceLocal((::TAttAxis*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttAxis*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TAttBBox2D(void *p);
   static void deleteArray_TAttBBox2D(void *p);
   static void destruct_TAttBBox2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttBBox2D*)
   {
      ::TAttBBox2D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttBBox2D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttBBox2D", ::TAttBBox2D::Class_Version(), "TAttBBox2D.h", 19,
                  typeid(::TAttBBox2D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttBBox2D::Dictionary, isa_proxy, 4,
                  sizeof(::TAttBBox2D) );
      instance.SetDelete(&delete_TAttBBox2D);
      instance.SetDeleteArray(&deleteArray_TAttBBox2D);
      instance.SetDestructor(&destruct_TAttBBox2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttBBox2D*)
   {
      return GenerateInitInstanceLocal((::TAttBBox2D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttBBox2D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TAttBBox(void *p);
   static void deleteArray_TAttBBox(void *p);
   static void destruct_TAttBBox(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttBBox*)
   {
      ::TAttBBox *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttBBox >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttBBox", ::TAttBBox::Class_Version(), "TAttBBox.h", 17,
                  typeid(::TAttBBox), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttBBox::Dictionary, isa_proxy, 4,
                  sizeof(::TAttBBox) );
      instance.SetDelete(&delete_TAttBBox);
      instance.SetDeleteArray(&deleteArray_TAttBBox);
      instance.SetDestructor(&destruct_TAttBBox);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttBBox*)
   {
      return GenerateInitInstanceLocal((::TAttBBox*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttBBox*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttFill(void *p = nullptr);
   static void *newArray_TAttFill(Long_t size, void *p);
   static void delete_TAttFill(void *p);
   static void deleteArray_TAttFill(void *p);
   static void destruct_TAttFill(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttFill*)
   {
      ::TAttFill *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttFill >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttFill", ::TAttFill::Class_Version(), "TAttFill.h", 19,
                  typeid(::TAttFill), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttFill::Dictionary, isa_proxy, 4,
                  sizeof(::TAttFill) );
      instance.SetNew(&new_TAttFill);
      instance.SetNewArray(&newArray_TAttFill);
      instance.SetDelete(&delete_TAttFill);
      instance.SetDeleteArray(&deleteArray_TAttFill);
      instance.SetDestructor(&destruct_TAttFill);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttFill*)
   {
      return GenerateInitInstanceLocal((::TAttFill*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttFill*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttLine(void *p = nullptr);
   static void *newArray_TAttLine(Long_t size, void *p);
   static void delete_TAttLine(void *p);
   static void deleteArray_TAttLine(void *p);
   static void destruct_TAttLine(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttLine*)
   {
      ::TAttLine *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttLine >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttLine", ::TAttLine::Class_Version(), "TAttLine.h", 18,
                  typeid(::TAttLine), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttLine::Dictionary, isa_proxy, 4,
                  sizeof(::TAttLine) );
      instance.SetNew(&new_TAttLine);
      instance.SetNewArray(&newArray_TAttLine);
      instance.SetDelete(&delete_TAttLine);
      instance.SetDeleteArray(&deleteArray_TAttLine);
      instance.SetDestructor(&destruct_TAttLine);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttLine*)
   {
      return GenerateInitInstanceLocal((::TAttLine*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttLine*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttMarker(void *p = nullptr);
   static void *newArray_TAttMarker(Long_t size, void *p);
   static void delete_TAttMarker(void *p);
   static void deleteArray_TAttMarker(void *p);
   static void destruct_TAttMarker(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttMarker*)
   {
      ::TAttMarker *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttMarker >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttMarker", ::TAttMarker::Class_Version(), "TAttMarker.h", 19,
                  typeid(::TAttMarker), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttMarker::Dictionary, isa_proxy, 4,
                  sizeof(::TAttMarker) );
      instance.SetNew(&new_TAttMarker);
      instance.SetNewArray(&newArray_TAttMarker);
      instance.SetDelete(&delete_TAttMarker);
      instance.SetDeleteArray(&deleteArray_TAttMarker);
      instance.SetDestructor(&destruct_TAttMarker);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttMarker*)
   {
      return GenerateInitInstanceLocal((::TAttMarker*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttMarker*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttPad(void *p = nullptr);
   static void *newArray_TAttPad(Long_t size, void *p);
   static void delete_TAttPad(void *p);
   static void deleteArray_TAttPad(void *p);
   static void destruct_TAttPad(void *p);
   static void streamer_TAttPad(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttPad*)
   {
      ::TAttPad *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttPad >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttPad", ::TAttPad::Class_Version(), "TAttPad.h", 19,
                  typeid(::TAttPad), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttPad::Dictionary, isa_proxy, 17,
                  sizeof(::TAttPad) );
      instance.SetNew(&new_TAttPad);
      instance.SetNewArray(&newArray_TAttPad);
      instance.SetDelete(&delete_TAttPad);
      instance.SetDeleteArray(&deleteArray_TAttPad);
      instance.SetDestructor(&destruct_TAttPad);
      instance.SetStreamerFunc(&streamer_TAttPad);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttPad*)
   {
      return GenerateInitInstanceLocal((::TAttPad*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttPad*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TAttText(void *p = nullptr);
   static void *newArray_TAttText(Long_t size, void *p);
   static void delete_TAttText(void *p);
   static void deleteArray_TAttText(void *p);
   static void destruct_TAttText(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TAttText*)
   {
      ::TAttText *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TAttText >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TAttText", ::TAttText::Class_Version(), "TAttText.h", 18,
                  typeid(::TAttText), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TAttText::Dictionary, isa_proxy, 4,
                  sizeof(::TAttText) );
      instance.SetNew(&new_TAttText);
      instance.SetNewArray(&newArray_TAttText);
      instance.SetDelete(&delete_TAttText);
      instance.SetDeleteArray(&deleteArray_TAttText);
      instance.SetDestructor(&destruct_TAttText);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TAttText*)
   {
      return GenerateInitInstanceLocal((::TAttText*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TAttText*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBase64(void *p = nullptr);
   static void *newArray_TBase64(Long_t size, void *p);
   static void delete_TBase64(void *p);
   static void deleteArray_TBase64(void *p);
   static void destruct_TBase64(void *p);
   static void streamer_TBase64(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBase64*)
   {
      ::TBase64 *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBase64 >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBase64", ::TBase64::Class_Version(), "TBase64.h", 29,
                  typeid(::TBase64), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBase64::Dictionary, isa_proxy, 16,
                  sizeof(::TBase64) );
      instance.SetNew(&new_TBase64);
      instance.SetNewArray(&newArray_TBase64);
      instance.SetDelete(&delete_TBase64);
      instance.SetDeleteArray(&deleteArray_TBase64);
      instance.SetDestructor(&destruct_TBase64);
      instance.SetStreamerFunc(&streamer_TBase64);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBase64*)
   {
      return GenerateInitInstanceLocal((::TBase64*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBase64*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStopwatch(void *p = nullptr);
   static void *newArray_TStopwatch(Long_t size, void *p);
   static void delete_TStopwatch(void *p);
   static void deleteArray_TStopwatch(void *p);
   static void destruct_TStopwatch(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStopwatch*)
   {
      ::TStopwatch *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStopwatch >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStopwatch", ::TStopwatch::Class_Version(), "TStopwatch.h", 28,
                  typeid(::TStopwatch), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStopwatch::Dictionary, isa_proxy, 4,
                  sizeof(::TStopwatch) );
      instance.SetNew(&new_TStopwatch);
      instance.SetNewArray(&newArray_TStopwatch);
      instance.SetDelete(&delete_TStopwatch);
      instance.SetDeleteArray(&deleteArray_TStopwatch);
      instance.SetDestructor(&destruct_TStopwatch);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStopwatch*)
   {
      return GenerateInitInstanceLocal((::TStopwatch*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStopwatch*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBenchmark(void *p = nullptr);
   static void *newArray_TBenchmark(Long_t size, void *p);
   static void delete_TBenchmark(void *p);
   static void deleteArray_TBenchmark(void *p);
   static void destruct_TBenchmark(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBenchmark*)
   {
      ::TBenchmark *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBenchmark >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBenchmark", ::TBenchmark::Class_Version(), "TBenchmark.h", 29,
                  typeid(::TBenchmark), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBenchmark::Dictionary, isa_proxy, 4,
                  sizeof(::TBenchmark) );
      instance.SetNew(&new_TBenchmark);
      instance.SetNewArray(&newArray_TBenchmark);
      instance.SetDelete(&delete_TBenchmark);
      instance.SetDeleteArray(&deleteArray_TBenchmark);
      instance.SetDestructor(&destruct_TBenchmark);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBenchmark*)
   {
      return GenerateInitInstanceLocal((::TBenchmark*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBenchmark*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TBuffer3D(void *p);
   static void deleteArray_TBuffer3D(void *p);
   static void destruct_TBuffer3D(void *p);
   static void streamer_TBuffer3D(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBuffer3D*)
   {
      ::TBuffer3D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBuffer3D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBuffer3D", ::TBuffer3D::Class_Version(), "TBuffer3D.h", 17,
                  typeid(::TBuffer3D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBuffer3D::Dictionary, isa_proxy, 16,
                  sizeof(::TBuffer3D) );
      instance.SetDelete(&delete_TBuffer3D);
      instance.SetDeleteArray(&deleteArray_TBuffer3D);
      instance.SetDestructor(&destruct_TBuffer3D);
      instance.SetStreamerFunc(&streamer_TBuffer3D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBuffer3D*)
   {
      return GenerateInitInstanceLocal((::TBuffer3D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBuffer3D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TObjArray(void *p = nullptr);
   static void *newArray_TObjArray(Long_t size, void *p);
   static void delete_TObjArray(void *p);
   static void deleteArray_TObjArray(void *p);
   static void destruct_TObjArray(void *p);
   static void streamer_TObjArray(TBuffer &buf, void *obj);
   static Long64_t merge_TObjArray(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjArray*)
   {
      ::TObjArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjArray >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjArray", ::TObjArray::Class_Version(), "TObjArray.h", 37,
                  typeid(::TObjArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjArray::Dictionary, isa_proxy, 17,
                  sizeof(::TObjArray) );
      instance.SetNew(&new_TObjArray);
      instance.SetNewArray(&newArray_TObjArray);
      instance.SetDelete(&delete_TObjArray);
      instance.SetDeleteArray(&deleteArray_TObjArray);
      instance.SetDestructor(&destruct_TObjArray);
      instance.SetStreamerFunc(&streamer_TObjArray);
      instance.SetMerge(&merge_TObjArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjArray*)
   {
      return GenerateInitInstanceLocal((::TObjArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TObjArrayIter(void *p);
   static void deleteArray_TObjArrayIter(void *p);
   static void destruct_TObjArrayIter(void *p);
   static void streamer_TObjArrayIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjArrayIter*)
   {
      ::TObjArrayIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjArrayIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjArrayIter", ::TObjArrayIter::Class_Version(), "TObjArray.h", 123,
                  typeid(::TObjArrayIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjArrayIter::Dictionary, isa_proxy, 16,
                  sizeof(::TObjArrayIter) );
      instance.SetDelete(&delete_TObjArrayIter);
      instance.SetDeleteArray(&deleteArray_TObjArrayIter);
      instance.SetDestructor(&destruct_TObjArrayIter);
      instance.SetStreamerFunc(&streamer_TObjArrayIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjArrayIter*)
   {
      return GenerateInitInstanceLocal((::TObjArrayIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjArrayIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TClass(void *p = nullptr);
   static void *newArray_TClass(Long_t size, void *p);
   static void delete_TClass(void *p);
   static void deleteArray_TClass(void *p);
   static void destruct_TClass(void *p);
   static void streamer_TClass(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClass*)
   {
      ::TClass *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TClass >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TClass", ::TClass::Class_Version(), "TClass.h", 80,
                  typeid(::TClass), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TClass::Dictionary, isa_proxy, 16,
                  sizeof(::TClass) );
      instance.SetNew(&new_TClass);
      instance.SetNewArray(&newArray_TClass);
      instance.SetDelete(&delete_TClass);
      instance.SetDeleteArray(&deleteArray_TClass);
      instance.SetDestructor(&destruct_TClass);
      instance.SetStreamerFunc(&streamer_TClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClass*)
   {
      return GenerateInitInstanceLocal((::TClass*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClass*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TBuffer(void *p);
   static void deleteArray_TBuffer(void *p);
   static void destruct_TBuffer(void *p);
   static void streamer_TBuffer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBuffer*)
   {
      ::TBuffer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBuffer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBuffer", ::TBuffer::Class_Version(), "TBuffer.h", 43,
                  typeid(::TBuffer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBuffer::Dictionary, isa_proxy, 16,
                  sizeof(::TBuffer) );
      instance.SetDelete(&delete_TBuffer);
      instance.SetDeleteArray(&deleteArray_TBuffer);
      instance.SetDestructor(&destruct_TBuffer);
      instance.SetStreamerFunc(&streamer_TBuffer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBuffer*)
   {
      return GenerateInitInstanceLocal((::TBuffer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBuffer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TColor(void *p = nullptr);
   static void *newArray_TColor(Long_t size, void *p);
   static void delete_TColor(void *p);
   static void deleteArray_TColor(void *p);
   static void destruct_TColor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TColor*)
   {
      ::TColor *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TColor >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TColor", ::TColor::Class_Version(), "TColor.h", 19,
                  typeid(::TColor), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TColor::Dictionary, isa_proxy, 4,
                  sizeof(::TColor) );
      instance.SetNew(&new_TColor);
      instance.SetNewArray(&newArray_TColor);
      instance.SetDelete(&delete_TColor);
      instance.SetDeleteArray(&deleteArray_TColor);
      instance.SetDestructor(&destruct_TColor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TColor*)
   {
      return GenerateInitInstanceLocal((::TColor*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TColor*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TColorGradient(void *p);
   static void deleteArray_TColorGradient(void *p);
   static void destruct_TColorGradient(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TColorGradient*)
   {
      ::TColorGradient *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TColorGradient >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TColorGradient", ::TColorGradient::Class_Version(), "TColorGradient.h", 35,
                  typeid(::TColorGradient), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TColorGradient::Dictionary, isa_proxy, 4,
                  sizeof(::TColorGradient) );
      instance.SetDelete(&delete_TColorGradient);
      instance.SetDeleteArray(&deleteArray_TColorGradient);
      instance.SetDestructor(&destruct_TColorGradient);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TColorGradient*)
   {
      return GenerateInitInstanceLocal((::TColorGradient*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TColorGradient*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TLinearGradient(void *p = nullptr);
   static void *newArray_TLinearGradient(Long_t size, void *p);
   static void delete_TLinearGradient(void *p);
   static void deleteArray_TLinearGradient(void *p);
   static void destruct_TLinearGradient(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TLinearGradient*)
   {
      ::TLinearGradient *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TLinearGradient >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TLinearGradient", ::TLinearGradient::Class_Version(), "TColorGradient.h", 99,
                  typeid(::TLinearGradient), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TLinearGradient::Dictionary, isa_proxy, 4,
                  sizeof(::TLinearGradient) );
      instance.SetNew(&new_TLinearGradient);
      instance.SetNewArray(&newArray_TLinearGradient);
      instance.SetDelete(&delete_TLinearGradient);
      instance.SetDeleteArray(&deleteArray_TLinearGradient);
      instance.SetDestructor(&destruct_TLinearGradient);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TLinearGradient*)
   {
      return GenerateInitInstanceLocal((::TLinearGradient*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TLinearGradient*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TRadialGradient(void *p = nullptr);
   static void *newArray_TRadialGradient(Long_t size, void *p);
   static void delete_TRadialGradient(void *p);
   static void deleteArray_TRadialGradient(void *p);
   static void destruct_TRadialGradient(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRadialGradient*)
   {
      ::TRadialGradient *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRadialGradient >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRadialGradient", ::TRadialGradient::Class_Version(), "TColorGradient.h", 128,
                  typeid(::TRadialGradient), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRadialGradient::Dictionary, isa_proxy, 4,
                  sizeof(::TRadialGradient) );
      instance.SetNew(&new_TRadialGradient);
      instance.SetNewArray(&newArray_TRadialGradient);
      instance.SetDelete(&delete_TRadialGradient);
      instance.SetDeleteArray(&deleteArray_TRadialGradient);
      instance.SetDestructor(&destruct_TRadialGradient);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRadialGradient*)
   {
      return GenerateInitInstanceLocal((::TRadialGradient*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRadialGradient*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TDatime(void *p = nullptr);
   static void *newArray_TDatime(Long_t size, void *p);
   static void delete_TDatime(void *p);
   static void deleteArray_TDatime(void *p);
   static void destruct_TDatime(void *p);
   static void streamer_TDatime(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDatime*)
   {
      ::TDatime *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDatime >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDatime", ::TDatime::Class_Version(), "TDatime.h", 37,
                  typeid(::TDatime), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDatime::Dictionary, isa_proxy, 17,
                  sizeof(::TDatime) );
      instance.SetNew(&new_TDatime);
      instance.SetNewArray(&newArray_TDatime);
      instance.SetDelete(&delete_TDatime);
      instance.SetDeleteArray(&deleteArray_TDatime);
      instance.SetDestructor(&destruct_TDatime);
      instance.SetStreamerFunc(&streamer_TDatime);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDatime*)
   {
      return GenerateInitInstanceLocal((::TDatime*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDatime*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TUUID(void *p = nullptr);
   static void *newArray_TUUID(Long_t size, void *p);
   static void delete_TUUID(void *p);
   static void deleteArray_TUUID(void *p);
   static void destruct_TUUID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUUID*)
   {
      ::TUUID *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUUID >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TUUID", ::TUUID::Class_Version(), "TUUID.h", 42,
                  typeid(::TUUID), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TUUID::Dictionary, isa_proxy, 4,
                  sizeof(::TUUID) );
      instance.SetNew(&new_TUUID);
      instance.SetNewArray(&newArray_TUUID);
      instance.SetDelete(&delete_TUUID);
      instance.SetDeleteArray(&deleteArray_TUUID);
      instance.SetDestructor(&destruct_TUUID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUUID*)
   {
      return GenerateInitInstanceLocal((::TUUID*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TUUID*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TDirectory(void *p = nullptr);
   static void *newArray_TDirectory(Long_t size, void *p);
   static void delete_TDirectory(void *p);
   static void deleteArray_TDirectory(void *p);
   static void destruct_TDirectory(void *p);
   static void streamer_TDirectory(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDirectory*)
   {
      ::TDirectory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDirectory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDirectory", ::TDirectory::Class_Version(), "TDirectory.h", 45,
                  typeid(::TDirectory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDirectory::Dictionary, isa_proxy, 17,
                  sizeof(::TDirectory) );
      instance.SetNew(&new_TDirectory);
      instance.SetNewArray(&newArray_TDirectory);
      instance.SetDelete(&delete_TDirectory);
      instance.SetDeleteArray(&deleteArray_TDirectory);
      instance.SetDestructor(&destruct_TDirectory);
      instance.SetStreamerFunc(&streamer_TDirectory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDirectory*)
   {
      return GenerateInitInstanceLocal((::TDirectory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDirectory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TEnvRec(void *p = nullptr);
   static void *newArray_TEnvRec(Long_t size, void *p);
   static void delete_TEnvRec(void *p);
   static void deleteArray_TEnvRec(void *p);
   static void destruct_TEnvRec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TEnvRec*)
   {
      ::TEnvRec *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TEnvRec >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TEnvRec", ::TEnvRec::Class_Version(), "TEnv.h", 86,
                  typeid(::TEnvRec), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TEnvRec::Dictionary, isa_proxy, 4,
                  sizeof(::TEnvRec) );
      instance.SetNew(&new_TEnvRec);
      instance.SetNewArray(&newArray_TEnvRec);
      instance.SetDelete(&delete_TEnvRec);
      instance.SetDeleteArray(&deleteArray_TEnvRec);
      instance.SetDestructor(&destruct_TEnvRec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TEnvRec*)
   {
      return GenerateInitInstanceLocal((::TEnvRec*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TEnvRec*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TEnv(void *p = nullptr);
   static void *newArray_TEnv(Long_t size, void *p);
   static void delete_TEnv(void *p);
   static void deleteArray_TEnv(void *p);
   static void destruct_TEnv(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TEnv*)
   {
      ::TEnv *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TEnv >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TEnv", ::TEnv::Class_Version(), "TEnv.h", 124,
                  typeid(::TEnv), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TEnv::Dictionary, isa_proxy, 4,
                  sizeof(::TEnv) );
      instance.SetNew(&new_TEnv);
      instance.SetNewArray(&newArray_TEnv);
      instance.SetDelete(&delete_TEnv);
      instance.SetDeleteArray(&deleteArray_TEnv);
      instance.SetDestructor(&destruct_TEnv);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TEnv*)
   {
      return GenerateInitInstanceLocal((::TEnv*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TEnv*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TExec(void *p = nullptr);
   static void *newArray_TExec(Long_t size, void *p);
   static void delete_TExec(void *p);
   static void deleteArray_TExec(void *p);
   static void destruct_TExec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TExec*)
   {
      ::TExec *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TExec >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TExec", ::TExec::Class_Version(), "TExec.h", 28,
                  typeid(::TExec), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TExec::Dictionary, isa_proxy, 4,
                  sizeof(::TExec) );
      instance.SetNew(&new_TExec);
      instance.SetNewArray(&newArray_TExec);
      instance.SetDelete(&delete_TExec);
      instance.SetDeleteArray(&deleteArray_TExec);
      instance.SetDestructor(&destruct_TExec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TExec*)
   {
      return GenerateInitInstanceLocal((::TExec*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TExec*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TFileCollection(void *p = nullptr);
   static void *newArray_TFileCollection(Long_t size, void *p);
   static void delete_TFileCollection(void *p);
   static void deleteArray_TFileCollection(void *p);
   static void destruct_TFileCollection(void *p);
   static Long64_t merge_TFileCollection(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileCollection*)
   {
      ::TFileCollection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileCollection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFileCollection", ::TFileCollection::Class_Version(), "TFileCollection.h", 39,
                  typeid(::TFileCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFileCollection::Dictionary, isa_proxy, 4,
                  sizeof(::TFileCollection) );
      instance.SetNew(&new_TFileCollection);
      instance.SetNewArray(&newArray_TFileCollection);
      instance.SetDelete(&delete_TFileCollection);
      instance.SetDeleteArray(&deleteArray_TFileCollection);
      instance.SetDestructor(&destruct_TFileCollection);
      instance.SetMerge(&merge_TFileCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileCollection*)
   {
      return GenerateInitInstanceLocal((::TFileCollection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFileCollection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TUrl(void *p = nullptr);
   static void *newArray_TUrl(Long_t size, void *p);
   static void delete_TUrl(void *p);
   static void deleteArray_TUrl(void *p);
   static void destruct_TUrl(void *p);
   static void streamer_TUrl(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUrl*)
   {
      ::TUrl *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUrl >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TUrl", ::TUrl::Class_Version(), "TUrl.h", 33,
                  typeid(::TUrl), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TUrl::Dictionary, isa_proxy, 16,
                  sizeof(::TUrl) );
      instance.SetNew(&new_TUrl);
      instance.SetNewArray(&newArray_TUrl);
      instance.SetDelete(&delete_TUrl);
      instance.SetDeleteArray(&deleteArray_TUrl);
      instance.SetDestructor(&destruct_TUrl);
      instance.SetStreamerFunc(&streamer_TUrl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUrl*)
   {
      return GenerateInitInstanceLocal((::TUrl*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TUrl*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TMD5(void *p = nullptr);
   static void *newArray_TMD5(Long_t size, void *p);
   static void delete_TMD5(void *p);
   static void deleteArray_TMD5(void *p);
   static void destruct_TMD5(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMD5*)
   {
      ::TMD5 *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMD5 >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMD5", ::TMD5::Class_Version(), "TMD5.h", 44,
                  typeid(::TMD5), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMD5::Dictionary, isa_proxy, 4,
                  sizeof(::TMD5) );
      instance.SetNew(&new_TMD5);
      instance.SetNewArray(&newArray_TMD5);
      instance.SetDelete(&delete_TMD5);
      instance.SetDeleteArray(&deleteArray_TMD5);
      instance.SetDestructor(&destruct_TMD5);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMD5*)
   {
      return GenerateInitInstanceLocal((::TMD5*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMD5*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TFileInfo(void *p = nullptr);
   static void *newArray_TFileInfo(Long_t size, void *p);
   static void delete_TFileInfo(void *p);
   static void deleteArray_TFileInfo(void *p);
   static void destruct_TFileInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileInfo*)
   {
      ::TFileInfo *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileInfo >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFileInfo", ::TFileInfo::Class_Version(), "TFileInfo.h", 39,
                  typeid(::TFileInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFileInfo::Dictionary, isa_proxy, 4,
                  sizeof(::TFileInfo) );
      instance.SetNew(&new_TFileInfo);
      instance.SetNewArray(&newArray_TFileInfo);
      instance.SetDelete(&delete_TFileInfo);
      instance.SetDeleteArray(&deleteArray_TFileInfo);
      instance.SetDestructor(&destruct_TFileInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileInfo*)
   {
      return GenerateInitInstanceLocal((::TFileInfo*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFileInfo*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TFileInfoMeta(void *p = nullptr);
   static void *newArray_TFileInfoMeta(Long_t size, void *p);
   static void delete_TFileInfoMeta(void *p);
   static void deleteArray_TFileInfoMeta(void *p);
   static void destruct_TFileInfoMeta(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileInfoMeta*)
   {
      ::TFileInfoMeta *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileInfoMeta >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFileInfoMeta", ::TFileInfoMeta::Class_Version(), "TFileInfo.h", 108,
                  typeid(::TFileInfoMeta), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFileInfoMeta::Dictionary, isa_proxy, 4,
                  sizeof(::TFileInfoMeta) );
      instance.SetNew(&new_TFileInfoMeta);
      instance.SetNewArray(&newArray_TFileInfoMeta);
      instance.SetDelete(&delete_TFileInfoMeta);
      instance.SetDeleteArray(&deleteArray_TFileInfoMeta);
      instance.SetDestructor(&destruct_TFileInfoMeta);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileInfoMeta*)
   {
      return GenerateInitInstanceLocal((::TFileInfoMeta*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFileInfoMeta*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TFolder(void *p = nullptr);
   static void *newArray_TFolder(Long_t size, void *p);
   static void delete_TFolder(void *p);
   static void deleteArray_TFolder(void *p);
   static void destruct_TFolder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFolder*)
   {
      ::TFolder *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFolder >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFolder", ::TFolder::Class_Version(), "TFolder.h", 30,
                  typeid(::TFolder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFolder::Dictionary, isa_proxy, 4,
                  sizeof(::TFolder) );
      instance.SetNew(&new_TFolder);
      instance.SetNewArray(&newArray_TFolder);
      instance.SetDelete(&delete_TFolder);
      instance.SetDeleteArray(&deleteArray_TFolder);
      instance.SetDestructor(&destruct_TFolder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFolder*)
   {
      return GenerateInitInstanceLocal((::TFolder*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFolder*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TInetAddress(void *p = nullptr);
   static void *newArray_TInetAddress(Long_t size, void *p);
   static void delete_TInetAddress(void *p);
   static void deleteArray_TInetAddress(void *p);
   static void destruct_TInetAddress(void *p);
   static void streamer_TInetAddress(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TInetAddress*)
   {
      ::TInetAddress *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TInetAddress >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TInetAddress", ::TInetAddress::Class_Version(), "TInetAddress.h", 36,
                  typeid(::TInetAddress), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TInetAddress::Dictionary, isa_proxy, 17,
                  sizeof(::TInetAddress) );
      instance.SetNew(&new_TInetAddress);
      instance.SetNewArray(&newArray_TInetAddress);
      instance.SetDelete(&delete_TInetAddress);
      instance.SetDeleteArray(&deleteArray_TInetAddress);
      instance.SetDestructor(&destruct_TInetAddress);
      instance.SetStreamerFunc(&streamer_TInetAddress);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TInetAddress*)
   {
      return GenerateInitInstanceLocal((::TInetAddress*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TInetAddress*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TMacro(void *p = nullptr);
   static void *newArray_TMacro(Long_t size, void *p);
   static void delete_TMacro(void *p);
   static void deleteArray_TMacro(void *p);
   static void destruct_TMacro(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMacro*)
   {
      ::TMacro *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMacro >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMacro", ::TMacro::Class_Version(), "TMacro.h", 31,
                  typeid(::TMacro), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMacro::Dictionary, isa_proxy, 4,
                  sizeof(::TMacro) );
      instance.SetNew(&new_TMacro);
      instance.SetNewArray(&newArray_TMacro);
      instance.SetDelete(&delete_TMacro);
      instance.SetDeleteArray(&deleteArray_TMacro);
      instance.SetDestructor(&destruct_TMacro);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMacro*)
   {
      return GenerateInitInstanceLocal((::TMacro*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMacro*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TMemberInspector(void *p = nullptr);
   static void *newArray_TMemberInspector(Long_t size, void *p);
   static void delete_TMemberInspector(void *p);
   static void deleteArray_TMemberInspector(void *p);
   static void destruct_TMemberInspector(void *p);
   static void streamer_TMemberInspector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMemberInspector*)
   {
      ::TMemberInspector *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMemberInspector >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMemberInspector", ::TMemberInspector::Class_Version(), "TMemberInspector.h", 31,
                  typeid(::TMemberInspector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMemberInspector::Dictionary, isa_proxy, 16,
                  sizeof(::TMemberInspector) );
      instance.SetNew(&new_TMemberInspector);
      instance.SetNewArray(&newArray_TMemberInspector);
      instance.SetDelete(&delete_TMemberInspector);
      instance.SetDeleteArray(&deleteArray_TMemberInspector);
      instance.SetDestructor(&destruct_TMemberInspector);
      instance.SetStreamerFunc(&streamer_TMemberInspector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMemberInspector*)
   {
      return GenerateInitInstanceLocal((::TMemberInspector*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMemberInspector*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TMessageHandler(void *p);
   static void deleteArray_TMessageHandler(void *p);
   static void destruct_TMessageHandler(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMessageHandler*)
   {
      ::TMessageHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMessageHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMessageHandler", ::TMessageHandler::Class_Version(), "TMessageHandler.h", 34,
                  typeid(::TMessageHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMessageHandler::Dictionary, isa_proxy, 4,
                  sizeof(::TMessageHandler) );
      instance.SetDelete(&delete_TMessageHandler);
      instance.SetDeleteArray(&deleteArray_TMessageHandler);
      instance.SetDestructor(&destruct_TMessageHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMessageHandler*)
   {
      return GenerateInitInstanceLocal((::TMessageHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMessageHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TNotifyLinkBase(void *p = nullptr);
   static void *newArray_TNotifyLinkBase(Long_t size, void *p);
   static void delete_TNotifyLinkBase(void *p);
   static void deleteArray_TNotifyLinkBase(void *p);
   static void destruct_TNotifyLinkBase(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TNotifyLinkBase*)
   {
      ::TNotifyLinkBase *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TNotifyLinkBase >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TNotifyLinkBase", ::TNotifyLinkBase::Class_Version(), "TNotifyLink.h", 32,
                  typeid(::TNotifyLinkBase), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TNotifyLinkBase::Dictionary, isa_proxy, 4,
                  sizeof(::TNotifyLinkBase) );
      instance.SetNew(&new_TNotifyLinkBase);
      instance.SetNewArray(&newArray_TNotifyLinkBase);
      instance.SetDelete(&delete_TNotifyLinkBase);
      instance.SetDeleteArray(&deleteArray_TNotifyLinkBase);
      instance.SetDestructor(&destruct_TNotifyLinkBase);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TNotifyLinkBase*)
   {
      return GenerateInitInstanceLocal((::TNotifyLinkBase*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TNotifyLinkBase*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TObjString(void *p = nullptr);
   static void *newArray_TObjString(Long_t size, void *p);
   static void delete_TObjString(void *p);
   static void deleteArray_TObjString(void *p);
   static void destruct_TObjString(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjString*)
   {
      ::TObjString *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjString >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjString", ::TObjString::Class_Version(), "TObjString.h", 28,
                  typeid(::TObjString), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjString::Dictionary, isa_proxy, 4,
                  sizeof(::TObjString) );
      instance.SetNew(&new_TObjString);
      instance.SetNewArray(&newArray_TObjString);
      instance.SetDelete(&delete_TObjString);
      instance.SetDeleteArray(&deleteArray_TObjString);
      instance.SetDestructor(&destruct_TObjString);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjString*)
   {
      return GenerateInitInstanceLocal((::TObjString*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjString*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TROOT(void *p);
   static void deleteArray_TROOT(void *p);
   static void destruct_TROOT(void *p);
   static void streamer_TROOT(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TROOT*)
   {
      ::TROOT *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TROOT >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TROOT", ::TROOT::Class_Version(), "TROOT.h", 94,
                  typeid(::TROOT), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TROOT::Dictionary, isa_proxy, 16,
                  sizeof(::TROOT) );
      instance.SetDelete(&delete_TROOT);
      instance.SetDeleteArray(&deleteArray_TROOT);
      instance.SetDestructor(&destruct_TROOT);
      instance.SetStreamerFunc(&streamer_TROOT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TROOT*)
   {
      return GenerateInitInstanceLocal((::TROOT*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TROOT*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlEboolgR_Dictionary();
   static void TParameterlEboolgR_TClassManip(TClass*);
   static void *new_TParameterlEboolgR(void *p = nullptr);
   static void *newArray_TParameterlEboolgR(Long_t size, void *p);
   static void delete_TParameterlEboolgR(void *p);
   static void deleteArray_TParameterlEboolgR(void *p);
   static void destruct_TParameterlEboolgR(void *p);
   static Long64_t merge_TParameterlEboolgR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<bool>*)
   {
      ::TParameter<bool> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<bool> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<bool>", ::TParameter<bool>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<bool>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlEboolgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<bool>) );
      instance.SetNew(&new_TParameterlEboolgR);
      instance.SetNewArray(&newArray_TParameterlEboolgR);
      instance.SetDelete(&delete_TParameterlEboolgR);
      instance.SetDeleteArray(&deleteArray_TParameterlEboolgR);
      instance.SetDestructor(&destruct_TParameterlEboolgR);
      instance.SetMerge(&merge_TParameterlEboolgR);

      ::ROOT::AddClassAlternate("TParameter<bool>","TParameter<Bool_t>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<bool>*)
   {
      return GenerateInitInstanceLocal((::TParameter<bool>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlEboolgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr)->GetClass();
      TParameterlEboolgR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlEboolgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlELong64_tgR_Dictionary();
   static void TParameterlELong64_tgR_TClassManip(TClass*);
   static void *new_TParameterlELong64_tgR(void *p = nullptr);
   static void *newArray_TParameterlELong64_tgR(Long_t size, void *p);
   static void delete_TParameterlELong64_tgR(void *p);
   static void deleteArray_TParameterlELong64_tgR(void *p);
   static void destruct_TParameterlELong64_tgR(void *p);
   static Long64_t merge_TParameterlELong64_tgR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<Long64_t>*)
   {
      ::TParameter<Long64_t> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<Long64_t> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<Long64_t>", ::TParameter<Long64_t>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<Long64_t>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlELong64_tgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<Long64_t>) );
      instance.SetNew(&new_TParameterlELong64_tgR);
      instance.SetNewArray(&newArray_TParameterlELong64_tgR);
      instance.SetDelete(&delete_TParameterlELong64_tgR);
      instance.SetDeleteArray(&deleteArray_TParameterlELong64_tgR);
      instance.SetDestructor(&destruct_TParameterlELong64_tgR);
      instance.SetMerge(&merge_TParameterlELong64_tgR);

      ::ROOT::AddClassAlternate("TParameter<Long64_t>","TParameter<long long>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<Long64_t>*)
   {
      return GenerateInitInstanceLocal((::TParameter<Long64_t>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlELong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr)->GetClass();
      TParameterlELong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlELong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlElonggR_Dictionary();
   static void TParameterlElonggR_TClassManip(TClass*);
   static void *new_TParameterlElonggR(void *p = nullptr);
   static void *newArray_TParameterlElonggR(Long_t size, void *p);
   static void delete_TParameterlElonggR(void *p);
   static void deleteArray_TParameterlElonggR(void *p);
   static void destruct_TParameterlElonggR(void *p);
   static Long64_t merge_TParameterlElonggR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<long>*)
   {
      ::TParameter<long> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<long> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<long>", ::TParameter<long>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlElonggR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<long>) );
      instance.SetNew(&new_TParameterlElonggR);
      instance.SetNewArray(&newArray_TParameterlElonggR);
      instance.SetDelete(&delete_TParameterlElonggR);
      instance.SetDeleteArray(&deleteArray_TParameterlElonggR);
      instance.SetDestructor(&destruct_TParameterlElonggR);
      instance.SetMerge(&merge_TParameterlElonggR);

      ::ROOT::AddClassAlternate("TParameter<long>","TParameter<Long_t>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<long>*)
   {
      return GenerateInitInstanceLocal((::TParameter<long>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlElonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr)->GetClass();
      TParameterlElonggR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlElonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlEintgR_Dictionary();
   static void TParameterlEintgR_TClassManip(TClass*);
   static void *new_TParameterlEintgR(void *p = nullptr);
   static void *newArray_TParameterlEintgR(Long_t size, void *p);
   static void delete_TParameterlEintgR(void *p);
   static void deleteArray_TParameterlEintgR(void *p);
   static void destruct_TParameterlEintgR(void *p);
   static Long64_t merge_TParameterlEintgR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<int>*)
   {
      ::TParameter<int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<int> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<int>", ::TParameter<int>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlEintgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<int>) );
      instance.SetNew(&new_TParameterlEintgR);
      instance.SetNewArray(&newArray_TParameterlEintgR);
      instance.SetDelete(&delete_TParameterlEintgR);
      instance.SetDeleteArray(&deleteArray_TParameterlEintgR);
      instance.SetDestructor(&destruct_TParameterlEintgR);
      instance.SetMerge(&merge_TParameterlEintgR);

      ::ROOT::AddClassAlternate("TParameter<int>","TParameter<Int_t>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<int>*)
   {
      return GenerateInitInstanceLocal((::TParameter<int>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr)->GetClass();
      TParameterlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlEdoublegR_Dictionary();
   static void TParameterlEdoublegR_TClassManip(TClass*);
   static void *new_TParameterlEdoublegR(void *p = nullptr);
   static void *newArray_TParameterlEdoublegR(Long_t size, void *p);
   static void delete_TParameterlEdoublegR(void *p);
   static void deleteArray_TParameterlEdoublegR(void *p);
   static void destruct_TParameterlEdoublegR(void *p);
   static Long64_t merge_TParameterlEdoublegR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<double>*)
   {
      ::TParameter<double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<double> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<double>", ::TParameter<double>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<double>) );
      instance.SetNew(&new_TParameterlEdoublegR);
      instance.SetNewArray(&newArray_TParameterlEdoublegR);
      instance.SetDelete(&delete_TParameterlEdoublegR);
      instance.SetDeleteArray(&deleteArray_TParameterlEdoublegR);
      instance.SetDestructor(&destruct_TParameterlEdoublegR);
      instance.SetMerge(&merge_TParameterlEdoublegR);

      ::ROOT::AddClassAlternate("TParameter<double>","TParameter<Double_t>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<double>*)
   {
      return GenerateInitInstanceLocal((::TParameter<double>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr)->GetClass();
      TParameterlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TParameterlEfloatgR_Dictionary();
   static void TParameterlEfloatgR_TClassManip(TClass*);
   static void *new_TParameterlEfloatgR(void *p = nullptr);
   static void *newArray_TParameterlEfloatgR(Long_t size, void *p);
   static void delete_TParameterlEfloatgR(void *p);
   static void deleteArray_TParameterlEfloatgR(void *p);
   static void destruct_TParameterlEfloatgR(void *p);
   static Long64_t merge_TParameterlEfloatgR(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<float>*)
   {
      ::TParameter<float> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<float> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<float>", ::TParameter<float>::Class_Version(), "TParameter.h", 35,
                  typeid(::TParameter<float>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TParameterlEfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<float>) );
      instance.SetNew(&new_TParameterlEfloatgR);
      instance.SetNewArray(&newArray_TParameterlEfloatgR);
      instance.SetDelete(&delete_TParameterlEfloatgR);
      instance.SetDeleteArray(&deleteArray_TParameterlEfloatgR);
      instance.SetDestructor(&destruct_TParameterlEfloatgR);
      instance.SetMerge(&merge_TParameterlEfloatgR);

      ::ROOT::AddClassAlternate("TParameter<float>","TParameter<Float_t>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<float>*)
   {
      return GenerateInitInstanceLocal((::TParameter<float>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TParameterlEfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr)->GetClass();
      TParameterlEfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void TParameterlEfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TMethodCall(void *p = nullptr);
   static void *newArray_TMethodCall(Long_t size, void *p);
   static void delete_TMethodCall(void *p);
   static void deleteArray_TMethodCall(void *p);
   static void destruct_TMethodCall(void *p);
   static void streamer_TMethodCall(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMethodCall*)
   {
      ::TMethodCall *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMethodCall >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMethodCall", ::TMethodCall::Class_Version(), "TMethodCall.h", 37,
                  typeid(::TMethodCall), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMethodCall::Dictionary, isa_proxy, 16,
                  sizeof(::TMethodCall) );
      instance.SetNew(&new_TMethodCall);
      instance.SetNewArray(&newArray_TMethodCall);
      instance.SetDelete(&delete_TMethodCall);
      instance.SetDeleteArray(&deleteArray_TMethodCall);
      instance.SetDestructor(&destruct_TMethodCall);
      instance.SetStreamerFunc(&streamer_TMethodCall);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMethodCall*)
   {
      return GenerateInitInstanceLocal((::TMethodCall*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMethodCall*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void streamer_TPluginHandler(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPluginHandler*)
   {
      ::TPluginHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TPluginHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TPluginHandler", ::TPluginHandler::Class_Version(), "TPluginManager.h", 101,
                  typeid(::TPluginHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TPluginHandler::Dictionary, isa_proxy, 16,
                  sizeof(::TPluginHandler) );
      instance.SetStreamerFunc(&streamer_TPluginHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPluginHandler*)
   {
      return GenerateInitInstanceLocal((::TPluginHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPluginHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TPluginManager(void *p = nullptr);
   static void *newArray_TPluginManager(Long_t size, void *p);
   static void delete_TPluginManager(void *p);
   static void deleteArray_TPluginManager(void *p);
   static void destruct_TPluginManager(void *p);
   static void streamer_TPluginManager(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPluginManager*)
   {
      ::TPluginManager *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TPluginManager >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TPluginManager", ::TPluginManager::Class_Version(), "TPluginManager.h", 181,
                  typeid(::TPluginManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TPluginManager::Dictionary, isa_proxy, 16,
                  sizeof(::TPluginManager) );
      instance.SetNew(&new_TPluginManager);
      instance.SetNewArray(&newArray_TPluginManager);
      instance.SetDelete(&delete_TPluginManager);
      instance.SetDeleteArray(&deleteArray_TPluginManager);
      instance.SetDestructor(&destruct_TPluginManager);
      instance.SetStreamerFunc(&streamer_TPluginManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPluginManager*)
   {
      return GenerateInitInstanceLocal((::TPluginManager*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPluginManager*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TPoint_Dictionary();
   static void TPoint_TClassManip(TClass*);
   static void *new_TPoint(void *p = nullptr);
   static void *newArray_TPoint(Long_t size, void *p);
   static void delete_TPoint(void *p);
   static void deleteArray_TPoint(void *p);
   static void destruct_TPoint(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPoint*)
   {
      ::TPoint *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TPoint));
      static ::ROOT::TGenericClassInfo 
         instance("TPoint", "TPoint.h", 31,
                  typeid(::TPoint), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TPoint_Dictionary, isa_proxy, 0,
                  sizeof(::TPoint) );
      instance.SetNew(&new_TPoint);
      instance.SetNewArray(&newArray_TPoint);
      instance.SetDelete(&delete_TPoint);
      instance.SetDeleteArray(&deleteArray_TPoint);
      instance.SetDestructor(&destruct_TPoint);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPoint*)
   {
      return GenerateInitInstanceLocal((::TPoint*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPoint*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TPoint_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TPoint*)nullptr)->GetClass();
      TPoint_TClassManip(theClass);
   return theClass;
   }

   static void TPoint_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_TArray(void *p);
   static void deleteArray_TArray(void *p);
   static void destruct_TArray(void *p);
   static void streamer_TArray(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArray*)
   {
      ::TArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArray >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArray", ::TArray::Class_Version(), "TArray.h", 31,
                  typeid(::TArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArray::Dictionary, isa_proxy, 18,
                  sizeof(::TArray) );
      instance.SetDelete(&delete_TArray);
      instance.SetDeleteArray(&deleteArray_TArray);
      instance.SetDestructor(&destruct_TArray);
      instance.SetStreamerFunc(&streamer_TArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArray*)
   {
      return GenerateInitInstanceLocal((::TArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayI(void *p = nullptr);
   static void *newArray_TArrayI(Long_t size, void *p);
   static void delete_TArrayI(void *p);
   static void deleteArray_TArrayI(void *p);
   static void destruct_TArrayI(void *p);
   static void streamer_TArrayI(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayI*)
   {
      ::TArrayI *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayI >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayI", ::TArrayI::Class_Version(), "TArrayI.h", 27,
                  typeid(::TArrayI), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayI::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayI) );
      instance.SetNew(&new_TArrayI);
      instance.SetNewArray(&newArray_TArrayI);
      instance.SetDelete(&delete_TArrayI);
      instance.SetDeleteArray(&deleteArray_TArrayI);
      instance.SetDestructor(&destruct_TArrayI);
      instance.SetStreamerFunc(&streamer_TArrayI);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayI*)
   {
      return GenerateInitInstanceLocal((::TArrayI*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayI*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TPRegexp(void *p = nullptr);
   static void *newArray_TPRegexp(Long_t size, void *p);
   static void delete_TPRegexp(void *p);
   static void deleteArray_TPRegexp(void *p);
   static void destruct_TPRegexp(void *p);
   static void streamer_TPRegexp(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPRegexp*)
   {
      ::TPRegexp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TPRegexp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TPRegexp", ::TPRegexp::Class_Version(), "TPRegexp.h", 36,
                  typeid(::TPRegexp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TPRegexp::Dictionary, isa_proxy, 16,
                  sizeof(::TPRegexp) );
      instance.SetNew(&new_TPRegexp);
      instance.SetNewArray(&newArray_TPRegexp);
      instance.SetDelete(&delete_TPRegexp);
      instance.SetDeleteArray(&deleteArray_TPRegexp);
      instance.SetDestructor(&destruct_TPRegexp);
      instance.SetStreamerFunc(&streamer_TPRegexp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPRegexp*)
   {
      return GenerateInitInstanceLocal((::TPRegexp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPRegexp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TPMERegexp(void *p = nullptr);
   static void *newArray_TPMERegexp(Long_t size, void *p);
   static void delete_TPMERegexp(void *p);
   static void deleteArray_TPMERegexp(void *p);
   static void destruct_TPMERegexp(void *p);
   static void streamer_TPMERegexp(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPMERegexp*)
   {
      ::TPMERegexp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TPMERegexp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TPMERegexp", ::TPMERegexp::Class_Version(), "TPRegexp.h", 97,
                  typeid(::TPMERegexp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TPMERegexp::Dictionary, isa_proxy, 16,
                  sizeof(::TPMERegexp) );
      instance.SetNew(&new_TPMERegexp);
      instance.SetNewArray(&newArray_TPMERegexp);
      instance.SetDelete(&delete_TPMERegexp);
      instance.SetDeleteArray(&deleteArray_TPMERegexp);
      instance.SetDestructor(&destruct_TPMERegexp);
      instance.SetStreamerFunc(&streamer_TPMERegexp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPMERegexp*)
   {
      return GenerateInitInstanceLocal((::TPMERegexp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPMERegexp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TStringToken(void *p);
   static void deleteArray_TStringToken(void *p);
   static void destruct_TStringToken(void *p);
   static void streamer_TStringToken(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStringToken*)
   {
      ::TStringToken *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStringToken >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStringToken", ::TStringToken::Class_Version(), "TPRegexp.h", 143,
                  typeid(::TStringToken), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStringToken::Dictionary, isa_proxy, 16,
                  sizeof(::TStringToken) );
      instance.SetDelete(&delete_TStringToken);
      instance.SetDeleteArray(&deleteArray_TStringToken);
      instance.SetDestructor(&destruct_TStringToken);
      instance.SetStreamerFunc(&streamer_TStringToken);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStringToken*)
   {
      return GenerateInitInstanceLocal((::TStringToken*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStringToken*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TProcessID(void *p = nullptr);
   static void *newArray_TProcessID(Long_t size, void *p);
   static void delete_TProcessID(void *p);
   static void deleteArray_TProcessID(void *p);
   static void destruct_TProcessID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TProcessID*)
   {
      ::TProcessID *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TProcessID >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TProcessID", ::TProcessID::Class_Version(), "TProcessID.h", 74,
                  typeid(::TProcessID), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TProcessID::Dictionary, isa_proxy, 4,
                  sizeof(::TProcessID) );
      instance.SetNew(&new_TProcessID);
      instance.SetNewArray(&newArray_TProcessID);
      instance.SetDelete(&delete_TProcessID);
      instance.SetDeleteArray(&deleteArray_TProcessID);
      instance.SetDestructor(&destruct_TProcessID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TProcessID*)
   {
      return GenerateInitInstanceLocal((::TProcessID*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TProcessID*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TProcessUUID(void *p = nullptr);
   static void *newArray_TProcessUUID(Long_t size, void *p);
   static void delete_TProcessUUID(void *p);
   static void deleteArray_TProcessUUID(void *p);
   static void destruct_TProcessUUID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TProcessUUID*)
   {
      ::TProcessUUID *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TProcessUUID >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TProcessUUID", ::TProcessUUID::Class_Version(), "TProcessUUID.h", 32,
                  typeid(::TProcessUUID), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TProcessUUID::Dictionary, isa_proxy, 4,
                  sizeof(::TProcessUUID) );
      instance.SetNew(&new_TProcessUUID);
      instance.SetNewArray(&newArray_TProcessUUID);
      instance.SetDelete(&delete_TProcessUUID);
      instance.SetDeleteArray(&deleteArray_TProcessUUID);
      instance.SetDestructor(&destruct_TProcessUUID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TProcessUUID*)
   {
      return GenerateInitInstanceLocal((::TProcessUUID*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TProcessUUID*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TQClass(void *p);
   static void deleteArray_TQClass(void *p);
   static void destruct_TQClass(void *p);
   static void streamer_TQClass(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQClass*)
   {
      ::TQClass *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQClass >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQClass", ::TQClass::Class_Version(), "TQClass.h", 33,
                  typeid(::TQClass), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQClass::Dictionary, isa_proxy, 16,
                  sizeof(::TQClass) );
      instance.SetDelete(&delete_TQClass);
      instance.SetDeleteArray(&deleteArray_TQClass);
      instance.SetDestructor(&destruct_TQClass);
      instance.SetStreamerFunc(&streamer_TQClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQClass*)
   {
      return GenerateInitInstanceLocal((::TQClass*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQClass*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TQCommand(void *p = nullptr);
   static void *newArray_TQCommand(Long_t size, void *p);
   static void delete_TQCommand(void *p);
   static void deleteArray_TQCommand(void *p);
   static void destruct_TQCommand(void *p);
   static void streamer_TQCommand(TBuffer &buf, void *obj);
   static Long64_t merge_TQCommand(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQCommand*)
   {
      ::TQCommand *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQCommand >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQCommand", ::TQCommand::Class_Version(), "TQCommand.h", 27,
                  typeid(::TQCommand), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQCommand::Dictionary, isa_proxy, 16,
                  sizeof(::TQCommand) );
      instance.SetNew(&new_TQCommand);
      instance.SetNewArray(&newArray_TQCommand);
      instance.SetDelete(&delete_TQCommand);
      instance.SetDeleteArray(&deleteArray_TQCommand);
      instance.SetDestructor(&destruct_TQCommand);
      instance.SetStreamerFunc(&streamer_TQCommand);
      instance.SetMerge(&merge_TQCommand);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQCommand*)
   {
      return GenerateInitInstanceLocal((::TQCommand*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQCommand*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TQUndoManager(void *p = nullptr);
   static void *newArray_TQUndoManager(Long_t size, void *p);
   static void delete_TQUndoManager(void *p);
   static void deleteArray_TQUndoManager(void *p);
   static void destruct_TQUndoManager(void *p);
   static void streamer_TQUndoManager(TBuffer &buf, void *obj);
   static Long64_t merge_TQUndoManager(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQUndoManager*)
   {
      ::TQUndoManager *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQUndoManager >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQUndoManager", ::TQUndoManager::Class_Version(), "TQCommand.h", 103,
                  typeid(::TQUndoManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQUndoManager::Dictionary, isa_proxy, 16,
                  sizeof(::TQUndoManager) );
      instance.SetNew(&new_TQUndoManager);
      instance.SetNewArray(&newArray_TQUndoManager);
      instance.SetDelete(&delete_TQUndoManager);
      instance.SetDeleteArray(&deleteArray_TQUndoManager);
      instance.SetDestructor(&destruct_TQUndoManager);
      instance.SetStreamerFunc(&streamer_TQUndoManager);
      instance.SetMerge(&merge_TQUndoManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQUndoManager*)
   {
      return GenerateInitInstanceLocal((::TQUndoManager*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQUndoManager*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TQConnection(void *p = nullptr);
   static void *newArray_TQConnection(Long_t size, void *p);
   static void delete_TQConnection(void *p);
   static void deleteArray_TQConnection(void *p);
   static void destruct_TQConnection(void *p);
   static void streamer_TQConnection(TBuffer &buf, void *obj);
   static Long64_t merge_TQConnection(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TQConnection*)
   {
      ::TQConnection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TQConnection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TQConnection", ::TQConnection::Class_Version(), "TQConnection.h", 37,
                  typeid(::TQConnection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TQConnection::Dictionary, isa_proxy, 16,
                  sizeof(::TQConnection) );
      instance.SetNew(&new_TQConnection);
      instance.SetNewArray(&newArray_TQConnection);
      instance.SetDelete(&delete_TQConnection);
      instance.SetDeleteArray(&deleteArray_TQConnection);
      instance.SetDestructor(&destruct_TQConnection);
      instance.SetStreamerFunc(&streamer_TQConnection);
      instance.SetMerge(&merge_TQConnection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TQConnection*)
   {
      return GenerateInitInstanceLocal((::TQConnection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TQConnection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TSysEvtHandler(void *p);
   static void deleteArray_TSysEvtHandler(void *p);
   static void destruct_TSysEvtHandler(void *p);
   static void streamer_TSysEvtHandler(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSysEvtHandler*)
   {
      ::TSysEvtHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSysEvtHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSysEvtHandler", ::TSysEvtHandler::Class_Version(), "TSysEvtHandler.h", 28,
                  typeid(::TSysEvtHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSysEvtHandler::Dictionary, isa_proxy, 16,
                  sizeof(::TSysEvtHandler) );
      instance.SetDelete(&delete_TSysEvtHandler);
      instance.SetDeleteArray(&deleteArray_TSysEvtHandler);
      instance.SetDestructor(&destruct_TSysEvtHandler);
      instance.SetStreamerFunc(&streamer_TSysEvtHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSysEvtHandler*)
   {
      return GenerateInitInstanceLocal((::TSysEvtHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSysEvtHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TFileHandler(void *p);
   static void deleteArray_TFileHandler(void *p);
   static void destruct_TFileHandler(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileHandler*)
   {
      ::TFileHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFileHandler", ::TFileHandler::Class_Version(), "TSysEvtHandler.h", 65,
                  typeid(::TFileHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFileHandler::Dictionary, isa_proxy, 4,
                  sizeof(::TFileHandler) );
      instance.SetDelete(&delete_TFileHandler);
      instance.SetDeleteArray(&deleteArray_TFileHandler);
      instance.SetDestructor(&destruct_TFileHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileHandler*)
   {
      return GenerateInitInstanceLocal((::TFileHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFileHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TSignalHandler(void *p);
   static void deleteArray_TSignalHandler(void *p);
   static void destruct_TSignalHandler(void *p);
   static void streamer_TSignalHandler(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSignalHandler*)
   {
      ::TSignalHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSignalHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSignalHandler", ::TSignalHandler::Class_Version(), "TSysEvtHandler.h", 127,
                  typeid(::TSignalHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSignalHandler::Dictionary, isa_proxy, 16,
                  sizeof(::TSignalHandler) );
      instance.SetDelete(&delete_TSignalHandler);
      instance.SetDeleteArray(&deleteArray_TSignalHandler);
      instance.SetDestructor(&destruct_TSignalHandler);
      instance.SetStreamerFunc(&streamer_TSignalHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSignalHandler*)
   {
      return GenerateInitInstanceLocal((::TSignalHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSignalHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TStdExceptionHandler(void *p);
   static void deleteArray_TStdExceptionHandler(void *p);
   static void destruct_TStdExceptionHandler(void *p);
   static void streamer_TStdExceptionHandler(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStdExceptionHandler*)
   {
      ::TStdExceptionHandler *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStdExceptionHandler >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStdExceptionHandler", ::TStdExceptionHandler::Class_Version(), "TSysEvtHandler.h", 172,
                  typeid(::TStdExceptionHandler), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStdExceptionHandler::Dictionary, isa_proxy, 16,
                  sizeof(::TStdExceptionHandler) );
      instance.SetDelete(&delete_TStdExceptionHandler);
      instance.SetDeleteArray(&deleteArray_TStdExceptionHandler);
      instance.SetDestructor(&destruct_TStdExceptionHandler);
      instance.SetStreamerFunc(&streamer_TStdExceptionHandler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStdExceptionHandler*)
   {
      return GenerateInitInstanceLocal((::TStdExceptionHandler*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStdExceptionHandler*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TTime(void *p = nullptr);
   static void *newArray_TTime(Long_t size, void *p);
   static void delete_TTime(void *p);
   static void deleteArray_TTime(void *p);
   static void destruct_TTime(void *p);
   static void streamer_TTime(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TTime*)
   {
      ::TTime *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TTime >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TTime", ::TTime::Class_Version(), "TTime.h", 27,
                  typeid(::TTime), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TTime::Dictionary, isa_proxy, 16,
                  sizeof(::TTime) );
      instance.SetNew(&new_TTime);
      instance.SetNewArray(&newArray_TTime);
      instance.SetDelete(&delete_TTime);
      instance.SetDeleteArray(&deleteArray_TTime);
      instance.SetDestructor(&destruct_TTime);
      instance.SetStreamerFunc(&streamer_TTime);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TTime*)
   {
      return GenerateInitInstanceLocal((::TTime*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TTime*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TTimer(void *p = nullptr);
   static void *newArray_TTimer(Long_t size, void *p);
   static void delete_TTimer(void *p);
   static void deleteArray_TTimer(void *p);
   static void destruct_TTimer(void *p);
   static void streamer_TTimer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TTimer*)
   {
      ::TTimer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TTimer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TTimer", ::TTimer::Class_Version(), "TTimer.h", 51,
                  typeid(::TTimer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TTimer::Dictionary, isa_proxy, 16,
                  sizeof(::TTimer) );
      instance.SetNew(&new_TTimer);
      instance.SetNewArray(&newArray_TTimer);
      instance.SetDelete(&delete_TTimer);
      instance.SetDeleteArray(&deleteArray_TTimer);
      instance.SetDestructor(&destruct_TTimer);
      instance.SetStreamerFunc(&streamer_TTimer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TTimer*)
   {
      return GenerateInitInstanceLocal((::TTimer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TTimer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *FileStat_t_Dictionary();
   static void FileStat_t_TClassManip(TClass*);
   static void *new_FileStat_t(void *p = nullptr);
   static void *newArray_FileStat_t(Long_t size, void *p);
   static void delete_FileStat_t(void *p);
   static void deleteArray_FileStat_t(void *p);
   static void destruct_FileStat_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FileStat_t*)
   {
      ::FileStat_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FileStat_t));
      static ::ROOT::TGenericClassInfo 
         instance("FileStat_t", "TSystem.h", 124,
                  typeid(::FileStat_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &FileStat_t_Dictionary, isa_proxy, 0,
                  sizeof(::FileStat_t) );
      instance.SetNew(&new_FileStat_t);
      instance.SetNewArray(&newArray_FileStat_t);
      instance.SetDelete(&delete_FileStat_t);
      instance.SetDeleteArray(&deleteArray_FileStat_t);
      instance.SetDestructor(&destruct_FileStat_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FileStat_t*)
   {
      return GenerateInitInstanceLocal((::FileStat_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::FileStat_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *FileStat_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::FileStat_t*)nullptr)->GetClass();
      FileStat_t_TClassManip(theClass);
   return theClass;
   }

   static void FileStat_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *UserGroup_t_Dictionary();
   static void UserGroup_t_TClassManip(TClass*);
   static void *new_UserGroup_t(void *p = nullptr);
   static void *newArray_UserGroup_t(Long_t size, void *p);
   static void delete_UserGroup_t(void *p);
   static void deleteArray_UserGroup_t(void *p);
   static void destruct_UserGroup_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::UserGroup_t*)
   {
      ::UserGroup_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::UserGroup_t));
      static ::ROOT::TGenericClassInfo 
         instance("UserGroup_t", "TSystem.h", 138,
                  typeid(::UserGroup_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &UserGroup_t_Dictionary, isa_proxy, 0,
                  sizeof(::UserGroup_t) );
      instance.SetNew(&new_UserGroup_t);
      instance.SetNewArray(&newArray_UserGroup_t);
      instance.SetDelete(&delete_UserGroup_t);
      instance.SetDeleteArray(&deleteArray_UserGroup_t);
      instance.SetDestructor(&destruct_UserGroup_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::UserGroup_t*)
   {
      return GenerateInitInstanceLocal((::UserGroup_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::UserGroup_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *UserGroup_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::UserGroup_t*)nullptr)->GetClass();
      UserGroup_t_TClassManip(theClass);
   return theClass;
   }

   static void UserGroup_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_SysInfo_t(void *p = nullptr);
   static void *newArray_SysInfo_t(Long_t size, void *p);
   static void delete_SysInfo_t(void *p);
   static void deleteArray_SysInfo_t(void *p);
   static void destruct_SysInfo_t(void *p);
   static void streamer_SysInfo_t(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SysInfo_t*)
   {
      ::SysInfo_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::SysInfo_t >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("SysInfo_t", ::SysInfo_t::Class_Version(), "TSystem.h", 150,
                  typeid(::SysInfo_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::SysInfo_t::Dictionary, isa_proxy, 16,
                  sizeof(::SysInfo_t) );
      instance.SetNew(&new_SysInfo_t);
      instance.SetNewArray(&newArray_SysInfo_t);
      instance.SetDelete(&delete_SysInfo_t);
      instance.SetDeleteArray(&deleteArray_SysInfo_t);
      instance.SetDestructor(&destruct_SysInfo_t);
      instance.SetStreamerFunc(&streamer_SysInfo_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SysInfo_t*)
   {
      return GenerateInitInstanceLocal((::SysInfo_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::SysInfo_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_CpuInfo_t(void *p = nullptr);
   static void *newArray_CpuInfo_t(Long_t size, void *p);
   static void delete_CpuInfo_t(void *p);
   static void deleteArray_CpuInfo_t(void *p);
   static void destruct_CpuInfo_t(void *p);
   static void streamer_CpuInfo_t(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::CpuInfo_t*)
   {
      ::CpuInfo_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::CpuInfo_t >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("CpuInfo_t", ::CpuInfo_t::Class_Version(), "TSystem.h", 165,
                  typeid(::CpuInfo_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::CpuInfo_t::Dictionary, isa_proxy, 16,
                  sizeof(::CpuInfo_t) );
      instance.SetNew(&new_CpuInfo_t);
      instance.SetNewArray(&newArray_CpuInfo_t);
      instance.SetDelete(&delete_CpuInfo_t);
      instance.SetDeleteArray(&deleteArray_CpuInfo_t);
      instance.SetDestructor(&destruct_CpuInfo_t);
      instance.SetStreamerFunc(&streamer_CpuInfo_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::CpuInfo_t*)
   {
      return GenerateInitInstanceLocal((::CpuInfo_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::CpuInfo_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_MemInfo_t(void *p = nullptr);
   static void *newArray_MemInfo_t(Long_t size, void *p);
   static void delete_MemInfo_t(void *p);
   static void deleteArray_MemInfo_t(void *p);
   static void destruct_MemInfo_t(void *p);
   static void streamer_MemInfo_t(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::MemInfo_t*)
   {
      ::MemInfo_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::MemInfo_t >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("MemInfo_t", ::MemInfo_t::Class_Version(), "TSystem.h", 179,
                  typeid(::MemInfo_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::MemInfo_t::Dictionary, isa_proxy, 16,
                  sizeof(::MemInfo_t) );
      instance.SetNew(&new_MemInfo_t);
      instance.SetNewArray(&newArray_MemInfo_t);
      instance.SetDelete(&delete_MemInfo_t);
      instance.SetDeleteArray(&deleteArray_MemInfo_t);
      instance.SetDestructor(&destruct_MemInfo_t);
      instance.SetStreamerFunc(&streamer_MemInfo_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::MemInfo_t*)
   {
      return GenerateInitInstanceLocal((::MemInfo_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::MemInfo_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_ProcInfo_t(void *p = nullptr);
   static void *newArray_ProcInfo_t(Long_t size, void *p);
   static void delete_ProcInfo_t(void *p);
   static void deleteArray_ProcInfo_t(void *p);
   static void destruct_ProcInfo_t(void *p);
   static void streamer_ProcInfo_t(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ProcInfo_t*)
   {
      ::ProcInfo_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ProcInfo_t >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ProcInfo_t", ::ProcInfo_t::Class_Version(), "TSystem.h", 192,
                  typeid(::ProcInfo_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ProcInfo_t::Dictionary, isa_proxy, 16,
                  sizeof(::ProcInfo_t) );
      instance.SetNew(&new_ProcInfo_t);
      instance.SetNewArray(&newArray_ProcInfo_t);
      instance.SetDelete(&delete_ProcInfo_t);
      instance.SetDeleteArray(&deleteArray_ProcInfo_t);
      instance.SetDestructor(&destruct_ProcInfo_t);
      instance.SetStreamerFunc(&streamer_ProcInfo_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ProcInfo_t*)
   {
      return GenerateInitInstanceLocal((::ProcInfo_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ProcInfo_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RedirectHandle_t_Dictionary();
   static void RedirectHandle_t_TClassManip(TClass*);
   static void *new_RedirectHandle_t(void *p = nullptr);
   static void *newArray_RedirectHandle_t(Long_t size, void *p);
   static void delete_RedirectHandle_t(void *p);
   static void deleteArray_RedirectHandle_t(void *p);
   static void destruct_RedirectHandle_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RedirectHandle_t*)
   {
      ::RedirectHandle_t *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RedirectHandle_t));
      static ::ROOT::TGenericClassInfo 
         instance("RedirectHandle_t", "TSystem.h", 203,
                  typeid(::RedirectHandle_t), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RedirectHandle_t_Dictionary, isa_proxy, 0,
                  sizeof(::RedirectHandle_t) );
      instance.SetNew(&new_RedirectHandle_t);
      instance.SetNewArray(&newArray_RedirectHandle_t);
      instance.SetDelete(&delete_RedirectHandle_t);
      instance.SetDeleteArray(&deleteArray_RedirectHandle_t);
      instance.SetDestructor(&destruct_RedirectHandle_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RedirectHandle_t*)
   {
      return GenerateInitInstanceLocal((::RedirectHandle_t*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RedirectHandle_t*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RedirectHandle_t_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RedirectHandle_t*)nullptr)->GetClass();
      RedirectHandle_t_TClassManip(theClass);
   return theClass;
   }

   static void RedirectHandle_t_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_TProcessEventTimer(void *p);
   static void deleteArray_TProcessEventTimer(void *p);
   static void destruct_TProcessEventTimer(void *p);
   static void streamer_TProcessEventTimer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TProcessEventTimer*)
   {
      ::TProcessEventTimer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TProcessEventTimer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TProcessEventTimer", ::TProcessEventTimer::Class_Version(), "TSystem.h", 257,
                  typeid(::TProcessEventTimer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TProcessEventTimer::Dictionary, isa_proxy, 16,
                  sizeof(::TProcessEventTimer) );
      instance.SetDelete(&delete_TProcessEventTimer);
      instance.SetDeleteArray(&deleteArray_TProcessEventTimer);
      instance.SetDestructor(&destruct_TProcessEventTimer);
      instance.SetStreamerFunc(&streamer_TProcessEventTimer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TProcessEventTimer*)
   {
      return GenerateInitInstanceLocal((::TProcessEventTimer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TProcessEventTimer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TSystem(void *p = nullptr);
   static void *newArray_TSystem(Long_t size, void *p);
   static void delete_TSystem(void *p);
   static void deleteArray_TSystem(void *p);
   static void destruct_TSystem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSystem*)
   {
      ::TSystem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSystem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSystem", ::TSystem::Class_Version(), "TSystem.h", 266,
                  typeid(::TSystem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSystem::Dictionary, isa_proxy, 4,
                  sizeof(::TSystem) );
      instance.SetNew(&new_TSystem);
      instance.SetNewArray(&newArray_TSystem);
      instance.SetDelete(&delete_TSystem);
      instance.SetDeleteArray(&deleteArray_TSystem);
      instance.SetDestructor(&destruct_TSystem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSystem*)
   {
      return GenerateInitInstanceLocal((::TSystem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSystem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TRedirectOutputGuard(void *p);
   static void deleteArray_TRedirectOutputGuard(void *p);
   static void destruct_TRedirectOutputGuard(void *p);
   static void streamer_TRedirectOutputGuard(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRedirectOutputGuard*)
   {
      ::TRedirectOutputGuard *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRedirectOutputGuard >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRedirectOutputGuard", ::TRedirectOutputGuard::Class_Version(), "TRedirectOutputGuard.h", 36,
                  typeid(::TRedirectOutputGuard), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRedirectOutputGuard::Dictionary, isa_proxy, 16,
                  sizeof(::TRedirectOutputGuard) );
      instance.SetDelete(&delete_TRedirectOutputGuard);
      instance.SetDeleteArray(&deleteArray_TRedirectOutputGuard);
      instance.SetDestructor(&destruct_TRedirectOutputGuard);
      instance.SetStreamerFunc(&streamer_TRedirectOutputGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRedirectOutputGuard*)
   {
      return GenerateInitInstanceLocal((::TRedirectOutputGuard*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TRefCnt_Dictionary();
   static void TRefCnt_TClassManip(TClass*);
   static void *new_TRefCnt(void *p = nullptr);
   static void *newArray_TRefCnt(Long_t size, void *p);
   static void delete_TRefCnt(void *p);
   static void deleteArray_TRefCnt(void *p);
   static void destruct_TRefCnt(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRefCnt*)
   {
      ::TRefCnt *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRefCnt));
      static ::ROOT::TGenericClassInfo 
         instance("TRefCnt", "TRefCnt.h", 27,
                  typeid(::TRefCnt), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TRefCnt_Dictionary, isa_proxy, 0,
                  sizeof(::TRefCnt) );
      instance.SetNew(&new_TRefCnt);
      instance.SetNewArray(&newArray_TRefCnt);
      instance.SetDelete(&delete_TRefCnt);
      instance.SetDeleteArray(&deleteArray_TRefCnt);
      instance.SetDestructor(&destruct_TRefCnt);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRefCnt*)
   {
      return GenerateInitInstanceLocal((::TRefCnt*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRefCnt*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TRefCnt_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TRefCnt*)nullptr)->GetClass();
      TRefCnt_TClassManip(theClass);
   return theClass;
   }

   static void TRefCnt_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TRef(void *p = nullptr);
   static void *newArray_TRef(Long_t size, void *p);
   static void delete_TRef(void *p);
   static void deleteArray_TRef(void *p);
   static void destruct_TRef(void *p);
   static void streamer_TRef(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRef*)
   {
      ::TRef *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRef >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRef", ::TRef::Class_Version(), "TRef.h", 32,
                  typeid(::TRef), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRef::Dictionary, isa_proxy, 17,
                  sizeof(::TRef) );
      instance.SetNew(&new_TRef);
      instance.SetNewArray(&newArray_TRef);
      instance.SetDelete(&delete_TRef);
      instance.SetDeleteArray(&deleteArray_TRef);
      instance.SetDestructor(&destruct_TRef);
      instance.SetStreamerFunc(&streamer_TRef);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRef*)
   {
      return GenerateInitInstanceLocal((::TRef*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRef*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TRegexp(void *p);
   static void deleteArray_TRegexp(void *p);
   static void destruct_TRegexp(void *p);
   static void streamer_TRegexp(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRegexp*)
   {
      ::TRegexp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRegexp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRegexp", ::TRegexp::Class_Version(), "TRegexp.h", 31,
                  typeid(::TRegexp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRegexp::Dictionary, isa_proxy, 16,
                  sizeof(::TRegexp) );
      instance.SetDelete(&delete_TRegexp);
      instance.SetDeleteArray(&deleteArray_TRegexp);
      instance.SetDestructor(&destruct_TRegexp);
      instance.SetStreamerFunc(&streamer_TRegexp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRegexp*)
   {
      return GenerateInitInstanceLocal((::TRegexp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRegexp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TRemoteObject(void *p = nullptr);
   static void *newArray_TRemoteObject(Long_t size, void *p);
   static void delete_TRemoteObject(void *p);
   static void deleteArray_TRemoteObject(void *p);
   static void destruct_TRemoteObject(void *p);
   static void streamer_TRemoteObject(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRemoteObject*)
   {
      ::TRemoteObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRemoteObject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRemoteObject", ::TRemoteObject::Class_Version(), "TRemoteObject.h", 34,
                  typeid(::TRemoteObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRemoteObject::Dictionary, isa_proxy, 17,
                  sizeof(::TRemoteObject) );
      instance.SetNew(&new_TRemoteObject);
      instance.SetNewArray(&newArray_TRemoteObject);
      instance.SetDelete(&delete_TRemoteObject);
      instance.SetDeleteArray(&deleteArray_TRemoteObject);
      instance.SetDestructor(&destruct_TRemoteObject);
      instance.SetStreamerFunc(&streamer_TRemoteObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRemoteObject*)
   {
      return GenerateInitInstanceLocal((::TRemoteObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRemoteObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TRootIOCtor_Dictionary();
   static void TRootIOCtor_TClassManip(TClass*);
   static void *new_TRootIOCtor(void *p = nullptr);
   static void *newArray_TRootIOCtor(Long_t size, void *p);
   static void delete_TRootIOCtor(void *p);
   static void deleteArray_TRootIOCtor(void *p);
   static void destruct_TRootIOCtor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRootIOCtor*)
   {
      ::TRootIOCtor *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TRootIOCtor));
      static ::ROOT::TGenericClassInfo 
         instance("TRootIOCtor", "TRootIOCtor.h", 32,
                  typeid(::TRootIOCtor), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TRootIOCtor_Dictionary, isa_proxy, 4,
                  sizeof(::TRootIOCtor) );
      instance.SetNew(&new_TRootIOCtor);
      instance.SetNewArray(&newArray_TRootIOCtor);
      instance.SetDelete(&delete_TRootIOCtor);
      instance.SetDeleteArray(&deleteArray_TRootIOCtor);
      instance.SetDestructor(&destruct_TRootIOCtor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRootIOCtor*)
   {
      return GenerateInitInstanceLocal((::TRootIOCtor*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRootIOCtor*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TRootIOCtor_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TRootIOCtor*)nullptr)->GetClass();
      TRootIOCtor_TClassManip(theClass);
   return theClass;
   }

   static void TRootIOCtor_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TStringLong(void *p = nullptr);
   static void *newArray_TStringLong(Long_t size, void *p);
   static void delete_TStringLong(void *p);
   static void deleteArray_TStringLong(void *p);
   static void destruct_TStringLong(void *p);
   static void streamer_TStringLong(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStringLong*)
   {
      ::TStringLong *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStringLong >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStringLong", ::TStringLong::Class_Version(), "TStringLong.h", 30,
                  typeid(::TStringLong), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStringLong::Dictionary, isa_proxy, 17,
                  sizeof(::TStringLong) );
      instance.SetNew(&new_TStringLong);
      instance.SetNewArray(&newArray_TStringLong);
      instance.SetDelete(&delete_TStringLong);
      instance.SetDeleteArray(&deleteArray_TStringLong);
      instance.SetDestructor(&destruct_TStringLong);
      instance.SetStreamerFunc(&streamer_TStringLong);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStringLong*)
   {
      return GenerateInitInstanceLocal((::TStringLong*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStringLong*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStyle(void *p = nullptr);
   static void *newArray_TStyle(Long_t size, void *p);
   static void delete_TStyle(void *p);
   static void deleteArray_TStyle(void *p);
   static void destruct_TStyle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStyle*)
   {
      ::TStyle *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStyle >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStyle", ::TStyle::Class_Version(), "TStyle.h", 29,
                  typeid(::TStyle), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStyle::Dictionary, isa_proxy, 4,
                  sizeof(::TStyle) );
      instance.SetNew(&new_TStyle);
      instance.SetNewArray(&newArray_TStyle);
      instance.SetDelete(&delete_TStyle);
      instance.SetDeleteArray(&deleteArray_TStyle);
      instance.SetDestructor(&destruct_TStyle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStyle*)
   {
      return GenerateInitInstanceLocal((::TStyle*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStyle*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TSystemFile(void *p = nullptr);
   static void *newArray_TSystemFile(Long_t size, void *p);
   static void delete_TSystemFile(void *p);
   static void deleteArray_TSystemFile(void *p);
   static void destruct_TSystemFile(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSystemFile*)
   {
      ::TSystemFile *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSystemFile >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSystemFile", ::TSystemFile::Class_Version(), "TSystemFile.h", 29,
                  typeid(::TSystemFile), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSystemFile::Dictionary, isa_proxy, 4,
                  sizeof(::TSystemFile) );
      instance.SetNew(&new_TSystemFile);
      instance.SetNewArray(&newArray_TSystemFile);
      instance.SetDelete(&delete_TSystemFile);
      instance.SetDeleteArray(&deleteArray_TSystemFile);
      instance.SetDestructor(&destruct_TSystemFile);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSystemFile*)
   {
      return GenerateInitInstanceLocal((::TSystemFile*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSystemFile*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TSystemDirectory(void *p = nullptr);
   static void *newArray_TSystemDirectory(Long_t size, void *p);
   static void delete_TSystemDirectory(void *p);
   static void deleteArray_TSystemDirectory(void *p);
   static void destruct_TSystemDirectory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSystemDirectory*)
   {
      ::TSystemDirectory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSystemDirectory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSystemDirectory", ::TSystemDirectory::Class_Version(), "TSystemDirectory.h", 32,
                  typeid(::TSystemDirectory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSystemDirectory::Dictionary, isa_proxy, 4,
                  sizeof(::TSystemDirectory) );
      instance.SetNew(&new_TSystemDirectory);
      instance.SetNewArray(&newArray_TSystemDirectory);
      instance.SetDelete(&delete_TSystemDirectory);
      instance.SetDeleteArray(&deleteArray_TSystemDirectory);
      instance.SetDestructor(&destruct_TSystemDirectory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSystemDirectory*)
   {
      return GenerateInitInstanceLocal((::TSystemDirectory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSystemDirectory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TTask(void *p = nullptr);
   static void *newArray_TTask(Long_t size, void *p);
   static void delete_TTask(void *p);
   static void deleteArray_TTask(void *p);
   static void destruct_TTask(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TTask*)
   {
      ::TTask *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TTask >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TTask", ::TTask::Class_Version(), "TTask.h", 35,
                  typeid(::TTask), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TTask::Dictionary, isa_proxy, 4,
                  sizeof(::TTask) );
      instance.SetNew(&new_TTask);
      instance.SetNewArray(&newArray_TTask);
      instance.SetDelete(&delete_TTask);
      instance.SetDeleteArray(&deleteArray_TTask);
      instance.SetDestructor(&destruct_TTask);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TTask*)
   {
      return GenerateInitInstanceLocal((::TTask*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TTask*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TTimeStamp(void *p = nullptr);
   static void *newArray_TTimeStamp(Long_t size, void *p);
   static void delete_TTimeStamp(void *p);
   static void deleteArray_TTimeStamp(void *p);
   static void destruct_TTimeStamp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TTimeStamp*)
   {
      ::TTimeStamp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TTimeStamp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TTimeStamp", ::TTimeStamp::Class_Version(), "TTimeStamp.h", 71,
                  typeid(::TTimeStamp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TTimeStamp::Dictionary, isa_proxy, 4,
                  sizeof(::TTimeStamp) );
      instance.SetNew(&new_TTimeStamp);
      instance.SetNewArray(&newArray_TTimeStamp);
      instance.SetDelete(&delete_TTimeStamp);
      instance.SetDeleteArray(&deleteArray_TTimeStamp);
      instance.SetDestructor(&destruct_TTimeStamp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TTimeStamp*)
   {
      return GenerateInitInstanceLocal((::TTimeStamp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TTimeStamp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TUri(void *p = nullptr);
   static void *newArray_TUri(Long_t size, void *p);
   static void delete_TUri(void *p);
   static void deleteArray_TUri(void *p);
   static void destruct_TUri(void *p);
   static void streamer_TUri(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUri*)
   {
      ::TUri *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUri >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TUri", ::TUri::Class_Version(), "TUri.h", 35,
                  typeid(::TUri), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TUri::Dictionary, isa_proxy, 16,
                  sizeof(::TUri) );
      instance.SetNew(&new_TUri);
      instance.SetNewArray(&newArray_TUri);
      instance.SetDelete(&delete_TUri);
      instance.SetDeleteArray(&deleteArray_TUri);
      instance.SetDestructor(&destruct_TUri);
      instance.SetStreamerFunc(&streamer_TUri);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUri*)
   {
      return GenerateInitInstanceLocal((::TUri*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TUri*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualAuth(void *p);
   static void deleteArray_TVirtualAuth(void *p);
   static void destruct_TVirtualAuth(void *p);
   static void streamer_TVirtualAuth(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualAuth*)
   {
      ::TVirtualAuth *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualAuth >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualAuth", ::TVirtualAuth::Class_Version(), "TVirtualAuth.h", 27,
                  typeid(::TVirtualAuth), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualAuth::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualAuth) );
      instance.SetDelete(&delete_TVirtualAuth);
      instance.SetDeleteArray(&deleteArray_TVirtualAuth);
      instance.SetDestructor(&destruct_TVirtualAuth);
      instance.SetStreamerFunc(&streamer_TVirtualAuth);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualAuth*)
   {
      return GenerateInitInstanceLocal((::TVirtualAuth*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualAuth*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualFFT(void *p);
   static void deleteArray_TVirtualFFT(void *p);
   static void destruct_TVirtualFFT(void *p);
   static void streamer_TVirtualFFT(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualFFT*)
   {
      ::TVirtualFFT *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualFFT >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualFFT", ::TVirtualFFT::Class_Version(), "TVirtualFFT.h", 88,
                  typeid(::TVirtualFFT), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualFFT::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualFFT) );
      instance.SetDelete(&delete_TVirtualFFT);
      instance.SetDeleteArray(&deleteArray_TVirtualFFT);
      instance.SetDestructor(&destruct_TVirtualFFT);
      instance.SetStreamerFunc(&streamer_TVirtualFFT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualFFT*)
   {
      return GenerateInitInstanceLocal((::TVirtualFFT*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualFFT*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualGLPainter(void *p);
   static void deleteArray_TVirtualGLPainter(void *p);
   static void destruct_TVirtualGLPainter(void *p);
   static void streamer_TVirtualGLPainter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualGLPainter*)
   {
      ::TVirtualGLPainter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualGLPainter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualGLPainter", ::TVirtualGLPainter::Class_Version(), "TVirtualGL.h", 45,
                  typeid(::TVirtualGLPainter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualGLPainter::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualGLPainter) );
      instance.SetDelete(&delete_TVirtualGLPainter);
      instance.SetDeleteArray(&deleteArray_TVirtualGLPainter);
      instance.SetDestructor(&destruct_TVirtualGLPainter);
      instance.SetStreamerFunc(&streamer_TVirtualGLPainter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualGLPainter*)
   {
      return GenerateInitInstanceLocal((::TVirtualGLPainter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualGLPainter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualGLManip(void *p);
   static void deleteArray_TVirtualGLManip(void *p);
   static void destruct_TVirtualGLManip(void *p);
   static void streamer_TVirtualGLManip(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualGLManip*)
   {
      ::TVirtualGLManip *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualGLManip >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualGLManip", ::TVirtualGLManip::Class_Version(), "TVirtualGL.h", 59,
                  typeid(::TVirtualGLManip), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualGLManip::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualGLManip) );
      instance.SetDelete(&delete_TVirtualGLManip);
      instance.SetDeleteArray(&deleteArray_TVirtualGLManip);
      instance.SetDestructor(&destruct_TVirtualGLManip);
      instance.SetStreamerFunc(&streamer_TVirtualGLManip);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualGLManip*)
   {
      return GenerateInitInstanceLocal((::TVirtualGLManip*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualGLManip*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TGLManager(void *p);
   static void deleteArray_TGLManager(void *p);
   static void destruct_TGLManager(void *p);
   static void streamer_TGLManager(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TGLManager*)
   {
      ::TGLManager *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TGLManager >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TGLManager", ::TGLManager::Class_Version(), "TVirtualGL.h", 70,
                  typeid(::TGLManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TGLManager::Dictionary, isa_proxy, 16,
                  sizeof(::TGLManager) );
      instance.SetDelete(&delete_TGLManager);
      instance.SetDeleteArray(&deleteArray_TGLManager);
      instance.SetDestructor(&destruct_TGLManager);
      instance.SetStreamerFunc(&streamer_TGLManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TGLManager*)
   {
      return GenerateInitInstanceLocal((::TGLManager*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TGLManager*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TGLPaintDevice(void *p);
   static void deleteArray_TGLPaintDevice(void *p);
   static void destruct_TGLPaintDevice(void *p);
   static void streamer_TGLPaintDevice(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TGLPaintDevice*)
   {
      ::TGLPaintDevice *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TGLPaintDevice >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TGLPaintDevice", ::TGLPaintDevice::Class_Version(), "TVirtualGL.h", 144,
                  typeid(::TGLPaintDevice), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TGLPaintDevice::Dictionary, isa_proxy, 16,
                  sizeof(::TGLPaintDevice) );
      instance.SetDelete(&delete_TGLPaintDevice);
      instance.SetDeleteArray(&deleteArray_TGLPaintDevice);
      instance.SetDestructor(&destruct_TGLPaintDevice);
      instance.SetStreamerFunc(&streamer_TGLPaintDevice);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TGLPaintDevice*)
   {
      return GenerateInitInstanceLocal((::TGLPaintDevice*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TGLPaintDevice*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_THashTable(void *p = nullptr);
   static void *newArray_THashTable(Long_t size, void *p);
   static void delete_THashTable(void *p);
   static void deleteArray_THashTable(void *p);
   static void destruct_THashTable(void *p);
   static void streamer_THashTable(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::THashTable*)
   {
      ::THashTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::THashTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("THashTable", ::THashTable::Class_Version(), "THashTable.h", 35,
                  typeid(::THashTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::THashTable::Dictionary, isa_proxy, 16,
                  sizeof(::THashTable) );
      instance.SetNew(&new_THashTable);
      instance.SetNewArray(&newArray_THashTable);
      instance.SetDelete(&delete_THashTable);
      instance.SetDeleteArray(&deleteArray_THashTable);
      instance.SetDestructor(&destruct_THashTable);
      instance.SetStreamerFunc(&streamer_THashTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::THashTable*)
   {
      return GenerateInitInstanceLocal((::THashTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::THashTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_THashTableIter(void *p);
   static void deleteArray_THashTableIter(void *p);
   static void destruct_THashTableIter(void *p);
   static void streamer_THashTableIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::THashTableIter*)
   {
      ::THashTableIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::THashTableIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("THashTableIter", ::THashTableIter::Class_Version(), "THashTable.h", 114,
                  typeid(::THashTableIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::THashTableIter::Dictionary, isa_proxy, 16,
                  sizeof(::THashTableIter) );
      instance.SetDelete(&delete_THashTableIter);
      instance.SetDeleteArray(&deleteArray_THashTableIter);
      instance.SetDestructor(&destruct_THashTableIter);
      instance.SetStreamerFunc(&streamer_THashTableIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::THashTableIter*)
   {
      return GenerateInitInstanceLocal((::THashTableIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::THashTableIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TMap(void *p = nullptr);
   static void *newArray_TMap(Long_t size, void *p);
   static void delete_TMap(void *p);
   static void deleteArray_TMap(void *p);
   static void destruct_TMap(void *p);
   static void streamer_TMap(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMap*)
   {
      ::TMap *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMap >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMap", ::TMap::Class_Version(), "TMap.h", 40,
                  typeid(::TMap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMap::Dictionary, isa_proxy, 17,
                  sizeof(::TMap) );
      instance.SetNew(&new_TMap);
      instance.SetNewArray(&newArray_TMap);
      instance.SetDelete(&delete_TMap);
      instance.SetDeleteArray(&deleteArray_TMap);
      instance.SetDestructor(&destruct_TMap);
      instance.SetStreamerFunc(&streamer_TMap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMap*)
   {
      return GenerateInitInstanceLocal((::TMap*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMap*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TPair(void *p);
   static void deleteArray_TPair(void *p);
   static void destruct_TPair(void *p);
   static void streamer_TPair(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TPair*)
   {
      ::TPair *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TPair >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TPair", ::TPair::Class_Version(), "TMap.h", 102,
                  typeid(::TPair), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TPair::Dictionary, isa_proxy, 16,
                  sizeof(::TPair) );
      instance.SetDelete(&delete_TPair);
      instance.SetDeleteArray(&deleteArray_TPair);
      instance.SetDestructor(&destruct_TPair);
      instance.SetStreamerFunc(&streamer_TPair);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TPair*)
   {
      return GenerateInitInstanceLocal((::TPair*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TPair*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TMapIter(void *p);
   static void deleteArray_TMapIter(void *p);
   static void destruct_TMapIter(void *p);
   static void streamer_TMapIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMapIter*)
   {
      ::TMapIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMapIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMapIter", ::TMapIter::Class_Version(), "TMap.h", 144,
                  typeid(::TMapIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMapIter::Dictionary, isa_proxy, 16,
                  sizeof(::TMapIter) );
      instance.SetDelete(&delete_TMapIter);
      instance.SetDeleteArray(&deleteArray_TMapIter);
      instance.SetDestructor(&destruct_TMapIter);
      instance.SetStreamerFunc(&streamer_TMapIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMapIter*)
   {
      return GenerateInitInstanceLocal((::TMapIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMapIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TVirtualMonitoringWriter(void *p = nullptr);
   static void *newArray_TVirtualMonitoringWriter(Long_t size, void *p);
   static void delete_TVirtualMonitoringWriter(void *p);
   static void deleteArray_TVirtualMonitoringWriter(void *p);
   static void destruct_TVirtualMonitoringWriter(void *p);
   static void streamer_TVirtualMonitoringWriter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMonitoringWriter*)
   {
      ::TVirtualMonitoringWriter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMonitoringWriter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMonitoringWriter", ::TVirtualMonitoringWriter::Class_Version(), "TVirtualMonitoring.h", 35,
                  typeid(::TVirtualMonitoringWriter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualMonitoringWriter::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualMonitoringWriter) );
      instance.SetNew(&new_TVirtualMonitoringWriter);
      instance.SetNewArray(&newArray_TVirtualMonitoringWriter);
      instance.SetDelete(&delete_TVirtualMonitoringWriter);
      instance.SetDeleteArray(&deleteArray_TVirtualMonitoringWriter);
      instance.SetDestructor(&destruct_TVirtualMonitoringWriter);
      instance.SetStreamerFunc(&streamer_TVirtualMonitoringWriter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMonitoringWriter*)
   {
      return GenerateInitInstanceLocal((::TVirtualMonitoringWriter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TVirtualMonitoringReader(void *p = nullptr);
   static void *newArray_TVirtualMonitoringReader(Long_t size, void *p);
   static void delete_TVirtualMonitoringReader(void *p);
   static void deleteArray_TVirtualMonitoringReader(void *p);
   static void destruct_TVirtualMonitoringReader(void *p);
   static void streamer_TVirtualMonitoringReader(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMonitoringReader*)
   {
      ::TVirtualMonitoringReader *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMonitoringReader >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMonitoringReader", ::TVirtualMonitoringReader::Class_Version(), "TVirtualMonitoring.h", 89,
                  typeid(::TVirtualMonitoringReader), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualMonitoringReader::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualMonitoringReader) );
      instance.SetNew(&new_TVirtualMonitoringReader);
      instance.SetNewArray(&newArray_TVirtualMonitoringReader);
      instance.SetDelete(&delete_TVirtualMonitoringReader);
      instance.SetDeleteArray(&deleteArray_TVirtualMonitoringReader);
      instance.SetDestructor(&destruct_TVirtualMonitoringReader);
      instance.SetStreamerFunc(&streamer_TVirtualMonitoringReader);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMonitoringReader*)
   {
      return GenerateInitInstanceLocal((::TVirtualMonitoringReader*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualPadEditor(void *p);
   static void deleteArray_TVirtualPadEditor(void *p);
   static void destruct_TVirtualPadEditor(void *p);
   static void streamer_TVirtualPadEditor(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPadEditor*)
   {
      ::TVirtualPadEditor *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPadEditor >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPadEditor", ::TVirtualPadEditor::Class_Version(), "TVirtualPadEditor.h", 27,
                  typeid(::TVirtualPadEditor), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualPadEditor::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualPadEditor) );
      instance.SetDelete(&delete_TVirtualPadEditor);
      instance.SetDeleteArray(&deleteArray_TVirtualPadEditor);
      instance.SetDestructor(&destruct_TVirtualPadEditor);
      instance.SetStreamerFunc(&streamer_TVirtualPadEditor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPadEditor*)
   {
      return GenerateInitInstanceLocal((::TVirtualPadEditor*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualPadEditor*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualPad(void *p);
   static void deleteArray_TVirtualPad(void *p);
   static void destruct_TVirtualPad(void *p);
   static void streamer_TVirtualPad(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPad*)
   {
      ::TVirtualPad *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPad >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPad", ::TVirtualPad::Class_Version(), "TVirtualPad.h", 50,
                  typeid(::TVirtualPad), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualPad::Dictionary, isa_proxy, 17,
                  sizeof(::TVirtualPad) );
      instance.SetDelete(&delete_TVirtualPad);
      instance.SetDeleteArray(&deleteArray_TVirtualPad);
      instance.SetDestructor(&destruct_TVirtualPad);
      instance.SetStreamerFunc(&streamer_TVirtualPad);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPad*)
   {
      return GenerateInitInstanceLocal((::TVirtualPad*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualPad*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualPadPainter(void *p);
   static void deleteArray_TVirtualPadPainter(void *p);
   static void destruct_TVirtualPadPainter(void *p);
   static void streamer_TVirtualPadPainter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPadPainter*)
   {
      ::TVirtualPadPainter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPadPainter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPadPainter", ::TVirtualPadPainter::Class_Version(), "TVirtualPadPainter.h", 19,
                  typeid(::TVirtualPadPainter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualPadPainter::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualPadPainter) );
      instance.SetDelete(&delete_TVirtualPadPainter);
      instance.SetDeleteArray(&deleteArray_TVirtualPadPainter);
      instance.SetDestructor(&destruct_TVirtualPadPainter);
      instance.SetStreamerFunc(&streamer_TVirtualPadPainter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPadPainter*)
   {
      return GenerateInitInstanceLocal((::TVirtualPadPainter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualPadPainter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualPerfStats(void *p);
   static void deleteArray_TVirtualPerfStats(void *p);
   static void destruct_TVirtualPerfStats(void *p);
   static void streamer_TVirtualPerfStats(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPerfStats*)
   {
      ::TVirtualPerfStats *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPerfStats >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPerfStats", ::TVirtualPerfStats::Class_Version(), "TVirtualPerfStats.h", 32,
                  typeid(::TVirtualPerfStats), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualPerfStats::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualPerfStats) );
      instance.SetDelete(&delete_TVirtualPerfStats);
      instance.SetDeleteArray(&deleteArray_TVirtualPerfStats);
      instance.SetDestructor(&destruct_TVirtualPerfStats);
      instance.SetStreamerFunc(&streamer_TVirtualPerfStats);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPerfStats*)
   {
      return GenerateInitInstanceLocal((::TVirtualPerfStats*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualPerfStats*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualPS(void *p);
   static void deleteArray_TVirtualPS(void *p);
   static void destruct_TVirtualPS(void *p);
   static void streamer_TVirtualPS(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPS*)
   {
      ::TVirtualPS *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPS >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPS", ::TVirtualPS::Class_Version(), "TVirtualPS.h", 30,
                  typeid(::TVirtualPS), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualPS::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualPS) );
      instance.SetDelete(&delete_TVirtualPS);
      instance.SetDeleteArray(&deleteArray_TVirtualPS);
      instance.SetDestructor(&destruct_TVirtualPS);
      instance.SetStreamerFunc(&streamer_TVirtualPS);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPS*)
   {
      return GenerateInitInstanceLocal((::TVirtualPS*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualPS*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualTableInterface(void *p);
   static void deleteArray_TVirtualTableInterface(void *p);
   static void destruct_TVirtualTableInterface(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualTableInterface*)
   {
      ::TVirtualTableInterface *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualTableInterface >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualTableInterface", ::TVirtualTableInterface::Class_Version(), "TVirtualTableInterface.h", 17,
                  typeid(::TVirtualTableInterface), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualTableInterface::Dictionary, isa_proxy, 4,
                  sizeof(::TVirtualTableInterface) );
      instance.SetDelete(&delete_TVirtualTableInterface);
      instance.SetDeleteArray(&deleteArray_TVirtualTableInterface);
      instance.SetDestructor(&destruct_TVirtualTableInterface);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualTableInterface*)
   {
      return GenerateInitInstanceLocal((::TVirtualTableInterface*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualTableInterface*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualViewer3D(void *p);
   static void deleteArray_TVirtualViewer3D(void *p);
   static void destruct_TVirtualViewer3D(void *p);
   static void streamer_TVirtualViewer3D(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualViewer3D*)
   {
      ::TVirtualViewer3D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualViewer3D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualViewer3D", ::TVirtualViewer3D::Class_Version(), "TVirtualViewer3D.h", 33,
                  typeid(::TVirtualViewer3D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualViewer3D::Dictionary, isa_proxy, 16,
                  sizeof(::TVirtualViewer3D) );
      instance.SetDelete(&delete_TVirtualViewer3D);
      instance.SetDeleteArray(&deleteArray_TVirtualViewer3D);
      instance.SetDestructor(&destruct_TVirtualViewer3D);
      instance.SetStreamerFunc(&streamer_TVirtualViewer3D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualViewer3D*)
   {
      return GenerateInitInstanceLocal((::TVirtualViewer3D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualViewer3D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TVirtualX(void *p = nullptr);
   static void *newArray_TVirtualX(Long_t size, void *p);
   static void delete_TVirtualX(void *p);
   static void deleteArray_TVirtualX(void *p);
   static void destruct_TVirtualX(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualX*)
   {
      ::TVirtualX *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualX >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualX", ::TVirtualX::Class_Version(), "TVirtualX.h", 46,
                  typeid(::TVirtualX), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualX::Dictionary, isa_proxy, 4,
                  sizeof(::TVirtualX) );
      instance.SetNew(&new_TVirtualX);
      instance.SetNewArray(&newArray_TVirtualX);
      instance.SetDelete(&delete_TVirtualX);
      instance.SetDeleteArray(&deleteArray_TVirtualX);
      instance.SetDestructor(&destruct_TVirtualX);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualX*)
   {
      return GenerateInitInstanceLocal((::TVirtualX*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualX*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayC(void *p = nullptr);
   static void *newArray_TArrayC(Long_t size, void *p);
   static void delete_TArrayC(void *p);
   static void deleteArray_TArrayC(void *p);
   static void destruct_TArrayC(void *p);
   static void streamer_TArrayC(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayC*)
   {
      ::TArrayC *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayC >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayC", ::TArrayC::Class_Version(), "TArrayC.h", 27,
                  typeid(::TArrayC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayC::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayC) );
      instance.SetNew(&new_TArrayC);
      instance.SetNewArray(&newArray_TArrayC);
      instance.SetDelete(&delete_TArrayC);
      instance.SetDeleteArray(&deleteArray_TArrayC);
      instance.SetDestructor(&destruct_TArrayC);
      instance.SetStreamerFunc(&streamer_TArrayC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayC*)
   {
      return GenerateInitInstanceLocal((::TArrayC*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayC*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayD(void *p = nullptr);
   static void *newArray_TArrayD(Long_t size, void *p);
   static void delete_TArrayD(void *p);
   static void deleteArray_TArrayD(void *p);
   static void destruct_TArrayD(void *p);
   static void streamer_TArrayD(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayD*)
   {
      ::TArrayD *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayD >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayD", ::TArrayD::Class_Version(), "TArrayD.h", 27,
                  typeid(::TArrayD), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayD::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayD) );
      instance.SetNew(&new_TArrayD);
      instance.SetNewArray(&newArray_TArrayD);
      instance.SetDelete(&delete_TArrayD);
      instance.SetDeleteArray(&deleteArray_TArrayD);
      instance.SetDestructor(&destruct_TArrayD);
      instance.SetStreamerFunc(&streamer_TArrayD);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayD*)
   {
      return GenerateInitInstanceLocal((::TArrayD*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayD*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayF(void *p = nullptr);
   static void *newArray_TArrayF(Long_t size, void *p);
   static void delete_TArrayF(void *p);
   static void deleteArray_TArrayF(void *p);
   static void destruct_TArrayF(void *p);
   static void streamer_TArrayF(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayF*)
   {
      ::TArrayF *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayF >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayF", ::TArrayF::Class_Version(), "TArrayF.h", 27,
                  typeid(::TArrayF), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayF::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayF) );
      instance.SetNew(&new_TArrayF);
      instance.SetNewArray(&newArray_TArrayF);
      instance.SetDelete(&delete_TArrayF);
      instance.SetDeleteArray(&deleteArray_TArrayF);
      instance.SetDestructor(&destruct_TArrayF);
      instance.SetStreamerFunc(&streamer_TArrayF);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayF*)
   {
      return GenerateInitInstanceLocal((::TArrayF*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayF*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayL64(void *p = nullptr);
   static void *newArray_TArrayL64(Long_t size, void *p);
   static void delete_TArrayL64(void *p);
   static void deleteArray_TArrayL64(void *p);
   static void destruct_TArrayL64(void *p);
   static void streamer_TArrayL64(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayL64*)
   {
      ::TArrayL64 *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayL64 >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayL64", ::TArrayL64::Class_Version(), "TArrayL64.h", 27,
                  typeid(::TArrayL64), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayL64::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayL64) );
      instance.SetNew(&new_TArrayL64);
      instance.SetNewArray(&newArray_TArrayL64);
      instance.SetDelete(&delete_TArrayL64);
      instance.SetDeleteArray(&deleteArray_TArrayL64);
      instance.SetDestructor(&destruct_TArrayL64);
      instance.SetStreamerFunc(&streamer_TArrayL64);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayL64*)
   {
      return GenerateInitInstanceLocal((::TArrayL64*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayL64*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayL(void *p = nullptr);
   static void *newArray_TArrayL(Long_t size, void *p);
   static void delete_TArrayL(void *p);
   static void deleteArray_TArrayL(void *p);
   static void destruct_TArrayL(void *p);
   static void streamer_TArrayL(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayL*)
   {
      ::TArrayL *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayL >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayL", ::TArrayL::Class_Version(), "TArrayL.h", 27,
                  typeid(::TArrayL), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayL::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayL) );
      instance.SetNew(&new_TArrayL);
      instance.SetNewArray(&newArray_TArrayL);
      instance.SetDelete(&delete_TArrayL);
      instance.SetDeleteArray(&deleteArray_TArrayL);
      instance.SetDestructor(&destruct_TArrayL);
      instance.SetStreamerFunc(&streamer_TArrayL);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayL*)
   {
      return GenerateInitInstanceLocal((::TArrayL*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayL*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TArrayS(void *p = nullptr);
   static void *newArray_TArrayS(Long_t size, void *p);
   static void delete_TArrayS(void *p);
   static void deleteArray_TArrayS(void *p);
   static void destruct_TArrayS(void *p);
   static void streamer_TArrayS(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TArrayS*)
   {
      ::TArrayS *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TArrayS >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TArrayS", ::TArrayS::Class_Version(), "TArrayS.h", 27,
                  typeid(::TArrayS), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TArrayS::Dictionary, isa_proxy, 19,
                  sizeof(::TArrayS) );
      instance.SetNew(&new_TArrayS);
      instance.SetNewArray(&newArray_TArrayS);
      instance.SetDelete(&delete_TArrayS);
      instance.SetDeleteArray(&deleteArray_TArrayS);
      instance.SetDestructor(&destruct_TArrayS);
      instance.SetStreamerFunc(&streamer_TArrayS);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TArrayS*)
   {
      return GenerateInitInstanceLocal((::TArrayS*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TArrayS*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBits(void *p = nullptr);
   static void *newArray_TBits(Long_t size, void *p);
   static void delete_TBits(void *p);
   static void deleteArray_TBits(void *p);
   static void destruct_TBits(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBits*)
   {
      ::TBits *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBits >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBits", ::TBits::Class_Version(), "TBits.h", 26,
                  typeid(::TBits), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBits::Dictionary, isa_proxy, 4,
                  sizeof(::TBits) );
      instance.SetNew(&new_TBits);
      instance.SetNewArray(&newArray_TBits);
      instance.SetDelete(&delete_TBits);
      instance.SetDeleteArray(&deleteArray_TBits);
      instance.SetDestructor(&destruct_TBits);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBits*)
   {
      return GenerateInitInstanceLocal((::TBits*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBits*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TBitscLcLTReference_Dictionary();
   static void TBitscLcLTReference_TClassManip(TClass*);
   static void delete_TBitscLcLTReference(void *p);
   static void deleteArray_TBitscLcLTReference(void *p);
   static void destruct_TBitscLcLTReference(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBits::TReference*)
   {
      ::TBits::TReference *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TBits::TReference));
      static ::ROOT::TGenericClassInfo 
         instance("TBits::TReference", "TBits.h", 49,
                  typeid(::TBits::TReference), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TBitscLcLTReference_Dictionary, isa_proxy, 1,
                  sizeof(::TBits::TReference) );
      instance.SetDelete(&delete_TBitscLcLTReference);
      instance.SetDeleteArray(&deleteArray_TBitscLcLTReference);
      instance.SetDestructor(&destruct_TBitscLcLTReference);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBits::TReference*)
   {
      return GenerateInitInstanceLocal((::TBits::TReference*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBits::TReference*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TBitscLcLTReference_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TBits::TReference*)nullptr)->GetClass();
      TBitscLcLTReference_TClassManip(theClass);
   return theClass;
   }

   static void TBitscLcLTReference_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TBtree(void *p = nullptr);
   static void *newArray_TBtree(Long_t size, void *p);
   static void delete_TBtree(void *p);
   static void deleteArray_TBtree(void *p);
   static void destruct_TBtree(void *p);
   static void streamer_TBtree(TBuffer &buf, void *obj);
   static Long64_t merge_TBtree(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBtree*)
   {
      ::TBtree *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBtree >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBtree", ::TBtree::Class_Version(), "TBtree.h", 38,
                  typeid(::TBtree), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBtree::Dictionary, isa_proxy, 17,
                  sizeof(::TBtree) );
      instance.SetNew(&new_TBtree);
      instance.SetNewArray(&newArray_TBtree);
      instance.SetDelete(&delete_TBtree);
      instance.SetDeleteArray(&deleteArray_TBtree);
      instance.SetDestructor(&destruct_TBtree);
      instance.SetStreamerFunc(&streamer_TBtree);
      instance.SetMerge(&merge_TBtree);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBtree*)
   {
      return GenerateInitInstanceLocal((::TBtree*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBtree*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TBtreeIter(void *p);
   static void deleteArray_TBtreeIter(void *p);
   static void destruct_TBtreeIter(void *p);
   static void streamer_TBtreeIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBtreeIter*)
   {
      ::TBtreeIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBtreeIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBtreeIter", ::TBtreeIter::Class_Version(), "TBtree.h", 334,
                  typeid(::TBtreeIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBtreeIter::Dictionary, isa_proxy, 16,
                  sizeof(::TBtreeIter) );
      instance.SetDelete(&delete_TBtreeIter);
      instance.SetDeleteArray(&deleteArray_TBtreeIter);
      instance.SetDestructor(&destruct_TBtreeIter);
      instance.SetStreamerFunc(&streamer_TBtreeIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBtreeIter*)
   {
      return GenerateInitInstanceLocal((::TBtreeIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBtreeIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TClassTable(void *p);
   static void deleteArray_TClassTable(void *p);
   static void destruct_TClassTable(void *p);
   static void streamer_TClassTable(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClassTable*)
   {
      ::TClassTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TClassTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TClassTable", ::TClassTable::Class_Version(), "TClassTable.h", 36,
                  typeid(::TClassTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TClassTable::Dictionary, isa_proxy, 16,
                  sizeof(::TClassTable) );
      instance.SetDelete(&delete_TClassTable);
      instance.SetDeleteArray(&deleteArray_TClassTable);
      instance.SetDestructor(&destruct_TClassTable);
      instance.SetStreamerFunc(&streamer_TClassTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClassTable*)
   {
      return GenerateInitInstanceLocal((::TClassTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClassTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TClonesArray(void *p = nullptr);
   static void *newArray_TClonesArray(Long_t size, void *p);
   static void delete_TClonesArray(void *p);
   static void deleteArray_TClonesArray(void *p);
   static void destruct_TClonesArray(void *p);
   static void streamer_TClonesArray(TBuffer &buf, void *obj);
   static Long64_t merge_TClonesArray(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClonesArray*)
   {
      ::TClonesArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TClonesArray >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TClonesArray", ::TClonesArray::Class_Version(), "TClonesArray.h", 29,
                  typeid(::TClonesArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TClonesArray::Dictionary, isa_proxy, 17,
                  sizeof(::TClonesArray) );
      instance.SetNew(&new_TClonesArray);
      instance.SetNewArray(&newArray_TClonesArray);
      instance.SetDelete(&delete_TClonesArray);
      instance.SetDeleteArray(&deleteArray_TClonesArray);
      instance.SetDestructor(&destruct_TClonesArray);
      instance.SetStreamerFunc(&streamer_TClonesArray);
      instance.SetMerge(&merge_TClonesArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClonesArray*)
   {
      return GenerateInitInstanceLocal((::TClonesArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClonesArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TExMap(void *p = nullptr);
   static void *newArray_TExMap(Long_t size, void *p);
   static void delete_TExMap(void *p);
   static void deleteArray_TExMap(void *p);
   static void destruct_TExMap(void *p);
   static void streamer_TExMap(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TExMap*)
   {
      ::TExMap *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TExMap >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TExMap", ::TExMap::Class_Version(), "TExMap.h", 33,
                  typeid(::TExMap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TExMap::Dictionary, isa_proxy, 17,
                  sizeof(::TExMap) );
      instance.SetNew(&new_TExMap);
      instance.SetNewArray(&newArray_TExMap);
      instance.SetDelete(&delete_TExMap);
      instance.SetDeleteArray(&deleteArray_TExMap);
      instance.SetDestructor(&destruct_TExMap);
      instance.SetStreamerFunc(&streamer_TExMap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TExMap*)
   {
      return GenerateInitInstanceLocal((::TExMap*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TExMap*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TExMapIter(void *p);
   static void deleteArray_TExMapIter(void *p);
   static void destruct_TExMapIter(void *p);
   static void streamer_TExMapIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TExMapIter*)
   {
      ::TExMapIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TExMapIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TExMapIter", ::TExMapIter::Class_Version(), "TExMap.h", 85,
                  typeid(::TExMapIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TExMapIter::Dictionary, isa_proxy, 16,
                  sizeof(::TExMapIter) );
      instance.SetDelete(&delete_TExMapIter);
      instance.SetDeleteArray(&deleteArray_TExMapIter);
      instance.SetDestructor(&destruct_TExMapIter);
      instance.SetStreamerFunc(&streamer_TExMapIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TExMapIter*)
   {
      return GenerateInitInstanceLocal((::TExMapIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TExMapIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_THashList(void *p = nullptr);
   static void *newArray_THashList(Long_t size, void *p);
   static void delete_THashList(void *p);
   static void deleteArray_THashList(void *p);
   static void destruct_THashList(void *p);
   static void streamer_THashList(TBuffer &buf, void *obj);
   static Long64_t merge_THashList(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::THashList*)
   {
      ::THashList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::THashList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("THashList", ::THashList::Class_Version(), "THashList.h", 34,
                  typeid(::THashList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::THashList::Dictionary, isa_proxy, 16,
                  sizeof(::THashList) );
      instance.SetNew(&new_THashList);
      instance.SetNewArray(&newArray_THashList);
      instance.SetDelete(&delete_THashList);
      instance.SetDeleteArray(&deleteArray_THashList);
      instance.SetDestructor(&destruct_THashList);
      instance.SetStreamerFunc(&streamer_THashList);
      instance.SetMerge(&merge_THashList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::THashList*)
   {
      return GenerateInitInstanceLocal((::THashList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::THashList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TObjectTable(void *p = nullptr);
   static void *newArray_TObjectTable(Long_t size, void *p);
   static void delete_TObjectTable(void *p);
   static void deleteArray_TObjectTable(void *p);
   static void destruct_TObjectTable(void *p);
   static void streamer_TObjectTable(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjectTable*)
   {
      ::TObjectTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjectTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjectTable", ::TObjectTable::Class_Version(), "TObjectTable.h", 35,
                  typeid(::TObjectTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjectTable::Dictionary, isa_proxy, 16,
                  sizeof(::TObjectTable) );
      instance.SetNew(&new_TObjectTable);
      instance.SetNewArray(&newArray_TObjectTable);
      instance.SetDelete(&delete_TObjectTable);
      instance.SetDeleteArray(&deleteArray_TObjectTable);
      instance.SetDestructor(&destruct_TObjectTable);
      instance.SetStreamerFunc(&streamer_TObjectTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjectTable*)
   {
      return GenerateInitInstanceLocal((::TObjectTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjectTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TOrdCollection(void *p = nullptr);
   static void *newArray_TOrdCollection(Long_t size, void *p);
   static void delete_TOrdCollection(void *p);
   static void deleteArray_TOrdCollection(void *p);
   static void destruct_TOrdCollection(void *p);
   static void streamer_TOrdCollection(TBuffer &buf, void *obj);
   static Long64_t merge_TOrdCollection(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TOrdCollection*)
   {
      ::TOrdCollection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TOrdCollection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TOrdCollection", ::TOrdCollection::Class_Version(), "TOrdCollection.h", 32,
                  typeid(::TOrdCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TOrdCollection::Dictionary, isa_proxy, 16,
                  sizeof(::TOrdCollection) );
      instance.SetNew(&new_TOrdCollection);
      instance.SetNewArray(&newArray_TOrdCollection);
      instance.SetDelete(&delete_TOrdCollection);
      instance.SetDeleteArray(&deleteArray_TOrdCollection);
      instance.SetDestructor(&destruct_TOrdCollection);
      instance.SetStreamerFunc(&streamer_TOrdCollection);
      instance.SetMerge(&merge_TOrdCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TOrdCollection*)
   {
      return GenerateInitInstanceLocal((::TOrdCollection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TOrdCollection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TOrdCollectionIter(void *p);
   static void deleteArray_TOrdCollectionIter(void *p);
   static void destruct_TOrdCollectionIter(void *p);
   static void streamer_TOrdCollectionIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TOrdCollectionIter*)
   {
      ::TOrdCollectionIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TOrdCollectionIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TOrdCollectionIter", ::TOrdCollectionIter::Class_Version(), "TOrdCollection.h", 96,
                  typeid(::TOrdCollectionIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TOrdCollectionIter::Dictionary, isa_proxy, 16,
                  sizeof(::TOrdCollectionIter) );
      instance.SetDelete(&delete_TOrdCollectionIter);
      instance.SetDeleteArray(&deleteArray_TOrdCollectionIter);
      instance.SetDestructor(&destruct_TOrdCollectionIter);
      instance.SetStreamerFunc(&streamer_TOrdCollectionIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TOrdCollectionIter*)
   {
      return GenerateInitInstanceLocal((::TOrdCollectionIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TOrdCollectionIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TRefArray(void *p = nullptr);
   static void *newArray_TRefArray(Long_t size, void *p);
   static void delete_TRefArray(void *p);
   static void deleteArray_TRefArray(void *p);
   static void destruct_TRefArray(void *p);
   static void streamer_TRefArray(TBuffer &buf, void *obj);
   static Long64_t merge_TRefArray(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRefArray*)
   {
      ::TRefArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRefArray >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRefArray", ::TRefArray::Class_Version(), "TRefArray.h", 39,
                  typeid(::TRefArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRefArray::Dictionary, isa_proxy, 17,
                  sizeof(::TRefArray) );
      instance.SetNew(&new_TRefArray);
      instance.SetNewArray(&newArray_TRefArray);
      instance.SetDelete(&delete_TRefArray);
      instance.SetDeleteArray(&deleteArray_TRefArray);
      instance.SetDestructor(&destruct_TRefArray);
      instance.SetStreamerFunc(&streamer_TRefArray);
      instance.SetMerge(&merge_TRefArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRefArray*)
   {
      return GenerateInitInstanceLocal((::TRefArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRefArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TRefArrayIter(void *p);
   static void deleteArray_TRefArrayIter(void *p);
   static void destruct_TRefArrayIter(void *p);
   static void streamer_TRefArrayIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRefArrayIter*)
   {
      ::TRefArrayIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRefArrayIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRefArrayIter", ::TRefArrayIter::Class_Version(), "TRefArray.h", 122,
                  typeid(::TRefArrayIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRefArrayIter::Dictionary, isa_proxy, 16,
                  sizeof(::TRefArrayIter) );
      instance.SetDelete(&delete_TRefArrayIter);
      instance.SetDeleteArray(&deleteArray_TRefArrayIter);
      instance.SetDestructor(&destruct_TRefArrayIter);
      instance.SetStreamerFunc(&streamer_TRefArrayIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRefArrayIter*)
   {
      return GenerateInitInstanceLocal((::TRefArrayIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRefArrayIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TRefTable(void *p = nullptr);
   static void *newArray_TRefTable(Long_t size, void *p);
   static void delete_TRefTable(void *p);
   static void deleteArray_TRefTable(void *p);
   static void destruct_TRefTable(void *p);
   static void streamer_TRefTable(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRefTable*)
   {
      ::TRefTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRefTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRefTable", ::TRefTable::Class_Version(), "TRefTable.h", 35,
                  typeid(::TRefTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRefTable::Dictionary, isa_proxy, 17,
                  sizeof(::TRefTable) );
      instance.SetNew(&new_TRefTable);
      instance.SetNewArray(&newArray_TRefTable);
      instance.SetDelete(&delete_TRefTable);
      instance.SetDeleteArray(&deleteArray_TRefTable);
      instance.SetDestructor(&destruct_TRefTable);
      instance.SetStreamerFunc(&streamer_TRefTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRefTable*)
   {
      return GenerateInitInstanceLocal((::TRefTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRefTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TSortedList(void *p = nullptr);
   static void *newArray_TSortedList(Long_t size, void *p);
   static void delete_TSortedList(void *p);
   static void deleteArray_TSortedList(void *p);
   static void destruct_TSortedList(void *p);
   static void streamer_TSortedList(TBuffer &buf, void *obj);
   static Long64_t merge_TSortedList(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TSortedList*)
   {
      ::TSortedList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TSortedList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TSortedList", ::TSortedList::Class_Version(), "TSortedList.h", 28,
                  typeid(::TSortedList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TSortedList::Dictionary, isa_proxy, 16,
                  sizeof(::TSortedList) );
      instance.SetNew(&new_TSortedList);
      instance.SetNewArray(&newArray_TSortedList);
      instance.SetDelete(&delete_TSortedList);
      instance.SetDeleteArray(&deleteArray_TSortedList);
      instance.SetDestructor(&destruct_TSortedList);
      instance.SetStreamerFunc(&streamer_TSortedList);
      instance.SetMerge(&merge_TSortedList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TSortedList*)
   {
      return GenerateInitInstanceLocal((::TSortedList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TSortedList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TClassRef_Dictionary();
   static void TClassRef_TClassManip(TClass*);
   static void *new_TClassRef(void *p = nullptr);
   static void *newArray_TClassRef(Long_t size, void *p);
   static void delete_TClassRef(void *p);
   static void deleteArray_TClassRef(void *p);
   static void destruct_TClassRef(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClassRef*)
   {
      ::TClassRef *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TClassRef));
      static ::ROOT::TGenericClassInfo 
         instance("TClassRef", "TClassRef.h", 28,
                  typeid(::TClassRef), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TClassRef_Dictionary, isa_proxy, 4,
                  sizeof(::TClassRef) );
      instance.SetNew(&new_TClassRef);
      instance.SetNewArray(&newArray_TClassRef);
      instance.SetDelete(&delete_TClassRef);
      instance.SetDeleteArray(&deleteArray_TClassRef);
      instance.SetDestructor(&destruct_TClassRef);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClassRef*)
   {
      return GenerateInitInstanceLocal((::TClassRef*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClassRef*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TClassRef_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TClassRef*)nullptr)->GetClass();
      TClassRef_TClassManip(theClass);
   return theClass;
   }

   static void TClassRef_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TVirtualCollectionProxy_Dictionary();
   static void TVirtualCollectionProxy_TClassManip(TClass*);
   static void delete_TVirtualCollectionProxy(void *p);
   static void deleteArray_TVirtualCollectionProxy(void *p);
   static void destruct_TVirtualCollectionProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualCollectionProxy*)
   {
      ::TVirtualCollectionProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TVirtualCollectionProxy));
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualCollectionProxy", "TVirtualCollectionProxy.h", 38,
                  typeid(::TVirtualCollectionProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TVirtualCollectionProxy_Dictionary, isa_proxy, 1,
                  sizeof(::TVirtualCollectionProxy) );
      instance.SetDelete(&delete_TVirtualCollectionProxy);
      instance.SetDeleteArray(&deleteArray_TVirtualCollectionProxy);
      instance.SetDestructor(&destruct_TVirtualCollectionProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualCollectionProxy*)
   {
      return GenerateInitInstanceLocal((::TVirtualCollectionProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualCollectionProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TVirtualCollectionProxy_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TVirtualCollectionProxy*)nullptr)->GetClass();
      TVirtualCollectionProxy_TClassManip(theClass);
   return theClass;
   }

   static void TVirtualCollectionProxy_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TUnixSystem(void *p = nullptr);
   static void *newArray_TUnixSystem(Long_t size, void *p);
   static void delete_TUnixSystem(void *p);
   static void deleteArray_TUnixSystem(void *p);
   static void destruct_TUnixSystem(void *p);
   static void streamer_TUnixSystem(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUnixSystem*)
   {
      ::TUnixSystem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUnixSystem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TUnixSystem", ::TUnixSystem::Class_Version(), "TUnixSystem.h", 32,
                  typeid(::TUnixSystem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TUnixSystem::Dictionary, isa_proxy, 16,
                  sizeof(::TUnixSystem) );
      instance.SetNew(&new_TUnixSystem);
      instance.SetNewArray(&newArray_TUnixSystem);
      instance.SetDelete(&delete_TUnixSystem);
      instance.SetDeleteArray(&deleteArray_TUnixSystem);
      instance.SetDestructor(&destruct_TUnixSystem);
      instance.SetStreamerFunc(&streamer_TUnixSystem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUnixSystem*)
   {
      return GenerateInitInstanceLocal((::TUnixSystem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TUnixSystem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBrowserImp(void *p = nullptr);
   static void *newArray_TBrowserImp(Long_t size, void *p);
   static void delete_TBrowserImp(void *p);
   static void deleteArray_TBrowserImp(void *p);
   static void destruct_TBrowserImp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBrowserImp*)
   {
      ::TBrowserImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBrowserImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBrowserImp", ::TBrowserImp::Class_Version(), "TBrowserImp.h", 29,
                  typeid(::TBrowserImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBrowserImp::Dictionary, isa_proxy, 4,
                  sizeof(::TBrowserImp) );
      instance.SetNew(&new_TBrowserImp);
      instance.SetNewArray(&newArray_TBrowserImp);
      instance.SetDelete(&delete_TBrowserImp);
      instance.SetDeleteArray(&deleteArray_TBrowserImp);
      instance.SetDestructor(&destruct_TBrowserImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBrowserImp*)
   {
      return GenerateInitInstanceLocal((::TBrowserImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBrowserImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBrowser(void *p = nullptr);
   static void *newArray_TBrowser(Long_t size, void *p);
   static void delete_TBrowser(void *p);
   static void deleteArray_TBrowser(void *p);
   static void destruct_TBrowser(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBrowser*)
   {
      ::TBrowser *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBrowser >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBrowser", ::TBrowser::Class_Version(), "TBrowser.h", 37,
                  typeid(::TBrowser), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBrowser::Dictionary, isa_proxy, 4,
                  sizeof(::TBrowser) );
      instance.SetNew(&new_TBrowser);
      instance.SetNewArray(&newArray_TBrowser);
      instance.SetDelete(&delete_TBrowser);
      instance.SetDeleteArray(&deleteArray_TBrowser);
      instance.SetDestructor(&destruct_TBrowser);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBrowser*)
   {
      return GenerateInitInstanceLocal((::TBrowser*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBrowser*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TCanvasImp(void *p = nullptr);
   static void *newArray_TCanvasImp(Long_t size, void *p);
   static void delete_TCanvasImp(void *p);
   static void deleteArray_TCanvasImp(void *p);
   static void destruct_TCanvasImp(void *p);
   static void streamer_TCanvasImp(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TCanvasImp*)
   {
      ::TCanvasImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TCanvasImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TCanvasImp", ::TCanvasImp::Class_Version(), "TCanvasImp.h", 30,
                  typeid(::TCanvasImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TCanvasImp::Dictionary, isa_proxy, 16,
                  sizeof(::TCanvasImp) );
      instance.SetNew(&new_TCanvasImp);
      instance.SetNewArray(&newArray_TCanvasImp);
      instance.SetDelete(&delete_TCanvasImp);
      instance.SetDeleteArray(&deleteArray_TCanvasImp);
      instance.SetDestructor(&destruct_TCanvasImp);
      instance.SetStreamerFunc(&streamer_TCanvasImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TCanvasImp*)
   {
      return GenerateInitInstanceLocal((::TCanvasImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TCanvasImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TClassMenuItem(void *p = nullptr);
   static void *newArray_TClassMenuItem(Long_t size, void *p);
   static void delete_TClassMenuItem(void *p);
   static void deleteArray_TClassMenuItem(void *p);
   static void destruct_TClassMenuItem(void *p);
   static void streamer_TClassMenuItem(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClassMenuItem*)
   {
      ::TClassMenuItem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TClassMenuItem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TClassMenuItem", ::TClassMenuItem::Class_Version(), "TClassMenuItem.h", 31,
                  typeid(::TClassMenuItem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TClassMenuItem::Dictionary, isa_proxy, 16,
                  sizeof(::TClassMenuItem) );
      instance.SetNew(&new_TClassMenuItem);
      instance.SetNewArray(&newArray_TClassMenuItem);
      instance.SetDelete(&delete_TClassMenuItem);
      instance.SetDeleteArray(&deleteArray_TClassMenuItem);
      instance.SetDestructor(&destruct_TClassMenuItem);
      instance.SetStreamerFunc(&streamer_TClassMenuItem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClassMenuItem*)
   {
      return GenerateInitInstanceLocal((::TClassMenuItem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClassMenuItem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TContextMenuImp(void *p = nullptr);
   static void *newArray_TContextMenuImp(Long_t size, void *p);
   static void delete_TContextMenuImp(void *p);
   static void deleteArray_TContextMenuImp(void *p);
   static void destruct_TContextMenuImp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TContextMenuImp*)
   {
      ::TContextMenuImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TContextMenuImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TContextMenuImp", ::TContextMenuImp::Class_Version(), "TContextMenuImp.h", 33,
                  typeid(::TContextMenuImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TContextMenuImp::Dictionary, isa_proxy, 4,
                  sizeof(::TContextMenuImp) );
      instance.SetNew(&new_TContextMenuImp);
      instance.SetNewArray(&newArray_TContextMenuImp);
      instance.SetDelete(&delete_TContextMenuImp);
      instance.SetDeleteArray(&deleteArray_TContextMenuImp);
      instance.SetDestructor(&destruct_TContextMenuImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TContextMenuImp*)
   {
      return GenerateInitInstanceLocal((::TContextMenuImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TContextMenuImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TContextMenu(void *p);
   static void deleteArray_TContextMenu(void *p);
   static void destruct_TContextMenu(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TContextMenu*)
   {
      ::TContextMenu *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TContextMenu >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TContextMenu", ::TContextMenu::Class_Version(), "TContextMenu.h", 44,
                  typeid(::TContextMenu), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TContextMenu::Dictionary, isa_proxy, 4,
                  sizeof(::TContextMenu) );
      instance.SetDelete(&delete_TContextMenu);
      instance.SetDeleteArray(&deleteArray_TContextMenu);
      instance.SetDestructor(&destruct_TContextMenu);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TContextMenu*)
   {
      return GenerateInitInstanceLocal((::TContextMenu*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TContextMenu*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TControlBarImp(void *p);
   static void deleteArray_TControlBarImp(void *p);
   static void destruct_TControlBarImp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TControlBarImp*)
   {
      ::TControlBarImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TControlBarImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TControlBarImp", ::TControlBarImp::Class_Version(), "TControlBarImp.h", 30,
                  typeid(::TControlBarImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TControlBarImp::Dictionary, isa_proxy, 4,
                  sizeof(::TControlBarImp) );
      instance.SetDelete(&delete_TControlBarImp);
      instance.SetDeleteArray(&deleteArray_TControlBarImp);
      instance.SetDestructor(&destruct_TControlBarImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TControlBarImp*)
   {
      return GenerateInitInstanceLocal((::TControlBarImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TControlBarImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TGuiFactory(void *p = nullptr);
   static void *newArray_TGuiFactory(Long_t size, void *p);
   static void delete_TGuiFactory(void *p);
   static void deleteArray_TGuiFactory(void *p);
   static void destruct_TGuiFactory(void *p);
   static void streamer_TGuiFactory(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TGuiFactory*)
   {
      ::TGuiFactory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TGuiFactory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TGuiFactory", ::TGuiFactory::Class_Version(), "TGuiFactory.h", 42,
                  typeid(::TGuiFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TGuiFactory::Dictionary, isa_proxy, 16,
                  sizeof(::TGuiFactory) );
      instance.SetNew(&new_TGuiFactory);
      instance.SetNewArray(&newArray_TGuiFactory);
      instance.SetDelete(&delete_TGuiFactory);
      instance.SetDeleteArray(&deleteArray_TGuiFactory);
      instance.SetDestructor(&destruct_TGuiFactory);
      instance.SetStreamerFunc(&streamer_TGuiFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TGuiFactory*)
   {
      return GenerateInitInstanceLocal((::TGuiFactory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TGuiFactory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TInspectorImp(void *p = nullptr);
   static void *newArray_TInspectorImp(Long_t size, void *p);
   static void delete_TInspectorImp(void *p);
   static void deleteArray_TInspectorImp(void *p);
   static void destruct_TInspectorImp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TInspectorImp*)
   {
      ::TInspectorImp *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TInspectorImp >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TInspectorImp", ::TInspectorImp::Class_Version(), "TInspectorImp.h", 30,
                  typeid(::TInspectorImp), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TInspectorImp::Dictionary, isa_proxy, 4,
                  sizeof(::TInspectorImp) );
      instance.SetNew(&new_TInspectorImp);
      instance.SetNewArray(&newArray_TInspectorImp);
      instance.SetDelete(&delete_TInspectorImp);
      instance.SetDeleteArray(&deleteArray_TInspectorImp);
      instance.SetDestructor(&destruct_TInspectorImp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TInspectorImp*)
   {
      return GenerateInitInstanceLocal((::TInspectorImp*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TInspectorImp*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TObjectSpy(void *p = nullptr);
   static void *newArray_TObjectSpy(Long_t size, void *p);
   static void delete_TObjectSpy(void *p);
   static void deleteArray_TObjectSpy(void *p);
   static void destruct_TObjectSpy(void *p);
   static void streamer_TObjectSpy(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjectSpy*)
   {
      ::TObjectSpy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjectSpy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjectSpy", ::TObjectSpy::Class_Version(), "TObjectSpy.h", 30,
                  typeid(::TObjectSpy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjectSpy::Dictionary, isa_proxy, 16,
                  sizeof(::TObjectSpy) );
      instance.SetNew(&new_TObjectSpy);
      instance.SetNewArray(&newArray_TObjectSpy);
      instance.SetDelete(&delete_TObjectSpy);
      instance.SetDeleteArray(&deleteArray_TObjectSpy);
      instance.SetDestructor(&destruct_TObjectSpy);
      instance.SetStreamerFunc(&streamer_TObjectSpy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjectSpy*)
   {
      return GenerateInitInstanceLocal((::TObjectSpy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjectSpy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TObjectRefSpy(void *p);
   static void deleteArray_TObjectRefSpy(void *p);
   static void destruct_TObjectRefSpy(void *p);
   static void streamer_TObjectRefSpy(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjectRefSpy*)
   {
      ::TObjectRefSpy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjectRefSpy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TObjectRefSpy", ::TObjectRefSpy::Class_Version(), "TObjectSpy.h", 52,
                  typeid(::TObjectRefSpy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TObjectRefSpy::Dictionary, isa_proxy, 16,
                  sizeof(::TObjectRefSpy) );
      instance.SetDelete(&delete_TObjectRefSpy);
      instance.SetDeleteArray(&deleteArray_TObjectRefSpy);
      instance.SetDestructor(&destruct_TObjectRefSpy);
      instance.SetStreamerFunc(&streamer_TObjectRefSpy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjectRefSpy*)
   {
      return GenerateInitInstanceLocal((::TObjectRefSpy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TObjectRefSpy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TFunction(void *p = nullptr);
   static void *newArray_TFunction(Long_t size, void *p);
   static void delete_TFunction(void *p);
   static void deleteArray_TFunction(void *p);
   static void destruct_TFunction(void *p);
   static void streamer_TFunction(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFunction*)
   {
      ::TFunction *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFunction >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFunction", ::TFunction::Class_Version(), "TFunction.h", 30,
                  typeid(::TFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFunction::Dictionary, isa_proxy, 16,
                  sizeof(::TFunction) );
      instance.SetNew(&new_TFunction);
      instance.SetNewArray(&newArray_TFunction);
      instance.SetDelete(&delete_TFunction);
      instance.SetDeleteArray(&deleteArray_TFunction);
      instance.SetDestructor(&destruct_TFunction);
      instance.SetStreamerFunc(&streamer_TFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFunction*)
   {
      return GenerateInitInstanceLocal((::TFunction*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFunction*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TMethod(void *p = nullptr);
   static void *newArray_TMethod(Long_t size, void *p);
   static void delete_TMethod(void *p);
   static void deleteArray_TMethod(void *p);
   static void destruct_TMethod(void *p);
   static void streamer_TMethod(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMethod*)
   {
      ::TMethod *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMethod >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMethod", ::TMethod::Class_Version(), "TMethod.h", 38,
                  typeid(::TMethod), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMethod::Dictionary, isa_proxy, 16,
                  sizeof(::TMethod) );
      instance.SetNew(&new_TMethod);
      instance.SetNewArray(&newArray_TMethod);
      instance.SetDelete(&delete_TMethod);
      instance.SetDeleteArray(&deleteArray_TMethod);
      instance.SetDestructor(&destruct_TMethod);
      instance.SetStreamerFunc(&streamer_TMethod);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMethod*)
   {
      return GenerateInitInstanceLocal((::TMethod*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMethod*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TToggle(void *p = nullptr);
   static void *newArray_TToggle(Long_t size, void *p);
   static void delete_TToggle(void *p);
   static void deleteArray_TToggle(void *p);
   static void destruct_TToggle(void *p);
   static void streamer_TToggle(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TToggle*)
   {
      ::TToggle *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TToggle >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TToggle", ::TToggle::Class_Version(), "TToggle.h", 47,
                  typeid(::TToggle), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TToggle::Dictionary, isa_proxy, 16,
                  sizeof(::TToggle) );
      instance.SetNew(&new_TToggle);
      instance.SetNewArray(&newArray_TToggle);
      instance.SetDelete(&delete_TToggle);
      instance.SetDeleteArray(&deleteArray_TToggle);
      instance.SetDestructor(&destruct_TToggle);
      instance.SetStreamerFunc(&streamer_TToggle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TToggle*)
   {
      return GenerateInitInstanceLocal((::TToggle*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TToggle*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TToggleGroup(void *p = nullptr);
   static void *newArray_TToggleGroup(Long_t size, void *p);
   static void delete_TToggleGroup(void *p);
   static void deleteArray_TToggleGroup(void *p);
   static void destruct_TToggleGroup(void *p);
   static void streamer_TToggleGroup(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TToggleGroup*)
   {
      ::TToggleGroup *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TToggleGroup >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TToggleGroup", ::TToggleGroup::Class_Version(), "TToggleGroup.h", 30,
                  typeid(::TToggleGroup), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TToggleGroup::Dictionary, isa_proxy, 16,
                  sizeof(::TToggleGroup) );
      instance.SetNew(&new_TToggleGroup);
      instance.SetNewArray(&newArray_TToggleGroup);
      instance.SetDelete(&delete_TToggleGroup);
      instance.SetDeleteArray(&deleteArray_TToggleGroup);
      instance.SetDestructor(&destruct_TToggleGroup);
      instance.SetStreamerFunc(&streamer_TToggleGroup);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TToggleGroup*)
   {
      return GenerateInitInstanceLocal((::TToggleGroup*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TToggleGroup*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TBaseClass(void *p = nullptr);
   static void *newArray_TBaseClass(Long_t size, void *p);
   static void delete_TBaseClass(void *p);
   static void deleteArray_TBaseClass(void *p);
   static void destruct_TBaseClass(void *p);
   static void streamer_TBaseClass(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBaseClass*)
   {
      ::TBaseClass *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBaseClass >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TBaseClass", ::TBaseClass::Class_Version(), "TBaseClass.h", 33,
                  typeid(::TBaseClass), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TBaseClass::Dictionary, isa_proxy, 17,
                  sizeof(::TBaseClass) );
      instance.SetNew(&new_TBaseClass);
      instance.SetNewArray(&newArray_TBaseClass);
      instance.SetDelete(&delete_TBaseClass);
      instance.SetDeleteArray(&deleteArray_TBaseClass);
      instance.SetDestructor(&destruct_TBaseClass);
      instance.SetStreamerFunc(&streamer_TBaseClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBaseClass*)
   {
      return GenerateInitInstanceLocal((::TBaseClass*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TBaseClass*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClassGenerator*)
   {
      ::TClassGenerator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TClassGenerator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TClassGenerator", ::TClassGenerator::Class_Version(), "TClassGenerator.h", 28,
                  typeid(::TClassGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TClassGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::TClassGenerator) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClassGenerator*)
   {
      return GenerateInitInstanceLocal((::TClassGenerator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClassGenerator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TClassStreamer_Dictionary();
   static void TClassStreamer_TClassManip(TClass*);
   static void delete_TClassStreamer(void *p);
   static void deleteArray_TClassStreamer(void *p);
   static void destruct_TClassStreamer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TClassStreamer*)
   {
      ::TClassStreamer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TClassStreamer));
      static ::ROOT::TGenericClassInfo 
         instance("TClassStreamer", "TClassStreamer.h", 26,
                  typeid(::TClassStreamer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TClassStreamer_Dictionary, isa_proxy, 4,
                  sizeof(::TClassStreamer) );
      instance.SetDelete(&delete_TClassStreamer);
      instance.SetDeleteArray(&deleteArray_TClassStreamer);
      instance.SetDestructor(&destruct_TClassStreamer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TClassStreamer*)
   {
      return GenerateInitInstanceLocal((::TClassStreamer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TClassStreamer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TClassStreamer_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TClassStreamer*)nullptr)->GetClass();
      TClassStreamer_TClassManip(theClass);
   return theClass;
   }

   static void TClassStreamer_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TDataMember(void *p = nullptr);
   static void *newArray_TDataMember(Long_t size, void *p);
   static void delete_TDataMember(void *p);
   static void deleteArray_TDataMember(void *p);
   static void destruct_TDataMember(void *p);
   static void streamer_TDataMember(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDataMember*)
   {
      ::TDataMember *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDataMember >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDataMember", ::TDataMember::Class_Version(), "TDataMember.h", 31,
                  typeid(::TDataMember), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDataMember::Dictionary, isa_proxy, 17,
                  sizeof(::TDataMember) );
      instance.SetNew(&new_TDataMember);
      instance.SetNewArray(&newArray_TDataMember);
      instance.SetDelete(&delete_TDataMember);
      instance.SetDeleteArray(&deleteArray_TDataMember);
      instance.SetDestructor(&destruct_TDataMember);
      instance.SetStreamerFunc(&streamer_TDataMember);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDataMember*)
   {
      return GenerateInitInstanceLocal((::TDataMember*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDataMember*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TOptionListItem(void *p = nullptr);
   static void *newArray_TOptionListItem(Long_t size, void *p);
   static void delete_TOptionListItem(void *p);
   static void deleteArray_TOptionListItem(void *p);
   static void destruct_TOptionListItem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TOptionListItem*)
   {
      ::TOptionListItem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TOptionListItem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TOptionListItem", ::TOptionListItem::Class_Version(), "TDataMember.h", 105,
                  typeid(::TOptionListItem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TOptionListItem::Dictionary, isa_proxy, 4,
                  sizeof(::TOptionListItem) );
      instance.SetNew(&new_TOptionListItem);
      instance.SetNewArray(&newArray_TOptionListItem);
      instance.SetDelete(&delete_TOptionListItem);
      instance.SetDeleteArray(&deleteArray_TOptionListItem);
      instance.SetDestructor(&destruct_TOptionListItem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TOptionListItem*)
   {
      return GenerateInitInstanceLocal((::TOptionListItem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TOptionListItem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TDictAttributeMap(void *p = nullptr);
   static void *newArray_TDictAttributeMap(Long_t size, void *p);
   static void delete_TDictAttributeMap(void *p);
   static void deleteArray_TDictAttributeMap(void *p);
   static void destruct_TDictAttributeMap(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TDictAttributeMap*)
   {
      ::TDictAttributeMap *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TDictAttributeMap >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TDictAttributeMap", ::TDictAttributeMap::Class_Version(), "TDictAttributeMap.h", 29,
                  typeid(::TDictAttributeMap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TDictAttributeMap::Dictionary, isa_proxy, 4,
                  sizeof(::TDictAttributeMap) );
      instance.SetNew(&new_TDictAttributeMap);
      instance.SetNewArray(&newArray_TDictAttributeMap);
      instance.SetDelete(&delete_TDictAttributeMap);
      instance.SetDeleteArray(&deleteArray_TDictAttributeMap);
      instance.SetDestructor(&destruct_TDictAttributeMap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TDictAttributeMap*)
   {
      return GenerateInitInstanceLocal((::TDictAttributeMap*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TDictAttributeMap*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TGlobal(void *p = nullptr);
   static void *newArray_TGlobal(Long_t size, void *p);
   static void delete_TGlobal(void *p);
   static void deleteArray_TGlobal(void *p);
   static void destruct_TGlobal(void *p);
   static void streamer_TGlobal(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TGlobal*)
   {
      ::TGlobal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TGlobal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TGlobal", ::TGlobal::Class_Version(), "TGlobal.h", 28,
                  typeid(::TGlobal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TGlobal::Dictionary, isa_proxy, 16,
                  sizeof(::TGlobal) );
      instance.SetNew(&new_TGlobal);
      instance.SetNewArray(&newArray_TGlobal);
      instance.SetDelete(&delete_TGlobal);
      instance.SetDeleteArray(&deleteArray_TGlobal);
      instance.SetDestructor(&destruct_TGlobal);
      instance.SetStreamerFunc(&streamer_TGlobal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TGlobal*)
   {
      return GenerateInitInstanceLocal((::TGlobal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TGlobal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TEnum(void *p = nullptr);
   static void *newArray_TEnum(Long_t size, void *p);
   static void delete_TEnum(void *p);
   static void deleteArray_TEnum(void *p);
   static void destruct_TEnum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TEnum*)
   {
      ::TEnum *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TEnum >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TEnum", ::TEnum::Class_Version(), "TEnum.h", 33,
                  typeid(::TEnum), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TEnum::Dictionary, isa_proxy, 4,
                  sizeof(::TEnum) );
      instance.SetNew(&new_TEnum);
      instance.SetNewArray(&newArray_TEnum);
      instance.SetDelete(&delete_TEnum);
      instance.SetDeleteArray(&deleteArray_TEnum);
      instance.SetDestructor(&destruct_TEnum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TEnum*)
   {
      return GenerateInitInstanceLocal((::TEnum*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TEnum*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TEnumConstant(void *p = nullptr);
   static void *newArray_TEnumConstant(Long_t size, void *p);
   static void delete_TEnumConstant(void *p);
   static void deleteArray_TEnumConstant(void *p);
   static void destruct_TEnumConstant(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TEnumConstant*)
   {
      ::TEnumConstant *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TEnumConstant >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TEnumConstant", ::TEnumConstant::Class_Version(), "TEnumConstant.h", 29,
                  typeid(::TEnumConstant), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TEnumConstant::Dictionary, isa_proxy, 4,
                  sizeof(::TEnumConstant) );
      instance.SetNew(&new_TEnumConstant);
      instance.SetNewArray(&newArray_TEnumConstant);
      instance.SetDelete(&delete_TEnumConstant);
      instance.SetDeleteArray(&deleteArray_TEnumConstant);
      instance.SetDestructor(&destruct_TEnumConstant);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TEnumConstant*)
   {
      return GenerateInitInstanceLocal((::TEnumConstant*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TEnumConstant*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TFileMergeInfo(void *p);
   static void deleteArray_TFileMergeInfo(void *p);
   static void destruct_TFileMergeInfo(void *p);
   static void streamer_TFileMergeInfo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileMergeInfo*)
   {
      ::TFileMergeInfo *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileMergeInfo >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFileMergeInfo", ::TFileMergeInfo::Class_Version(), "TFileMergeInfo.h", 42,
                  typeid(::TFileMergeInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFileMergeInfo::Dictionary, isa_proxy, 16,
                  sizeof(::TFileMergeInfo) );
      instance.SetDelete(&delete_TFileMergeInfo);
      instance.SetDeleteArray(&deleteArray_TFileMergeInfo);
      instance.SetDestructor(&destruct_TFileMergeInfo);
      instance.SetStreamerFunc(&streamer_TFileMergeInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileMergeInfo*)
   {
      return GenerateInitInstanceLocal((::TFileMergeInfo*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFileMergeInfo*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TFunctionTemplate(void *p);
   static void deleteArray_TFunctionTemplate(void *p);
   static void destruct_TFunctionTemplate(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFunctionTemplate*)
   {
      ::TFunctionTemplate *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFunctionTemplate >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TFunctionTemplate", ::TFunctionTemplate::Class_Version(), "TFunctionTemplate.h", 26,
                  typeid(::TFunctionTemplate), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TFunctionTemplate::Dictionary, isa_proxy, 4,
                  sizeof(::TFunctionTemplate) );
      instance.SetDelete(&delete_TFunctionTemplate);
      instance.SetDeleteArray(&deleteArray_TFunctionTemplate);
      instance.SetDestructor(&destruct_TFunctionTemplate);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFunctionTemplate*)
   {
      return GenerateInitInstanceLocal((::TFunctionTemplate*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TFunctionTemplate*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListOfDataMembers(void *p);
   static void deleteArray_TListOfDataMembers(void *p);
   static void destruct_TListOfDataMembers(void *p);
   static void streamer_TListOfDataMembers(TBuffer &buf, void *obj);
   static Long64_t merge_TListOfDataMembers(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfDataMembers*)
   {
      ::TListOfDataMembers *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfDataMembers >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfDataMembers", ::TListOfDataMembers::Class_Version(), "TListOfDataMembers.h", 32,
                  typeid(::TListOfDataMembers), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfDataMembers::Dictionary, isa_proxy, 17,
                  sizeof(::TListOfDataMembers) );
      instance.SetDelete(&delete_TListOfDataMembers);
      instance.SetDeleteArray(&deleteArray_TListOfDataMembers);
      instance.SetDestructor(&destruct_TListOfDataMembers);
      instance.SetStreamerFunc(&streamer_TListOfDataMembers);
      instance.SetMerge(&merge_TListOfDataMembers);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfDataMembers*)
   {
      return GenerateInitInstanceLocal((::TListOfDataMembers*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfDataMembers*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TListOfEnums(void *p = nullptr);
   static void *newArray_TListOfEnums(Long_t size, void *p);
   static void delete_TListOfEnums(void *p);
   static void deleteArray_TListOfEnums(void *p);
   static void destruct_TListOfEnums(void *p);
   static Long64_t merge_TListOfEnums(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfEnums*)
   {
      ::TListOfEnums *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfEnums >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfEnums", ::TListOfEnums::Class_Version(), "TListOfEnums.h", 32,
                  typeid(::TListOfEnums), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfEnums::Dictionary, isa_proxy, 4,
                  sizeof(::TListOfEnums) );
      instance.SetNew(&new_TListOfEnums);
      instance.SetNewArray(&newArray_TListOfEnums);
      instance.SetDelete(&delete_TListOfEnums);
      instance.SetDeleteArray(&deleteArray_TListOfEnums);
      instance.SetDestructor(&destruct_TListOfEnums);
      instance.SetMerge(&merge_TListOfEnums);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfEnums*)
   {
      return GenerateInitInstanceLocal((::TListOfEnums*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfEnums*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TListOfEnumsWithLock(void *p = nullptr);
   static void *newArray_TListOfEnumsWithLock(Long_t size, void *p);
   static void delete_TListOfEnumsWithLock(void *p);
   static void deleteArray_TListOfEnumsWithLock(void *p);
   static void destruct_TListOfEnumsWithLock(void *p);
   static Long64_t merge_TListOfEnumsWithLock(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfEnumsWithLock*)
   {
      ::TListOfEnumsWithLock *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfEnumsWithLock >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfEnumsWithLock", ::TListOfEnumsWithLock::Class_Version(), "TListOfEnumsWithLock.h", 30,
                  typeid(::TListOfEnumsWithLock), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfEnumsWithLock::Dictionary, isa_proxy, 4,
                  sizeof(::TListOfEnumsWithLock) );
      instance.SetNew(&new_TListOfEnumsWithLock);
      instance.SetNewArray(&newArray_TListOfEnumsWithLock);
      instance.SetDelete(&delete_TListOfEnumsWithLock);
      instance.SetDeleteArray(&deleteArray_TListOfEnumsWithLock);
      instance.SetDestructor(&destruct_TListOfEnumsWithLock);
      instance.SetMerge(&merge_TListOfEnumsWithLock);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfEnumsWithLock*)
   {
      return GenerateInitInstanceLocal((::TListOfEnumsWithLock*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfEnumsWithLock*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListOfEnumsWithLockIter(void *p);
   static void deleteArray_TListOfEnumsWithLockIter(void *p);
   static void destruct_TListOfEnumsWithLockIter(void *p);
   static void streamer_TListOfEnumsWithLockIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfEnumsWithLockIter*)
   {
      ::TListOfEnumsWithLockIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfEnumsWithLockIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfEnumsWithLockIter", ::TListOfEnumsWithLockIter::Class_Version(), "TListOfEnumsWithLock.h", 91,
                  typeid(::TListOfEnumsWithLockIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfEnumsWithLockIter::Dictionary, isa_proxy, 16,
                  sizeof(::TListOfEnumsWithLockIter) );
      instance.SetDelete(&delete_TListOfEnumsWithLockIter);
      instance.SetDeleteArray(&deleteArray_TListOfEnumsWithLockIter);
      instance.SetDestructor(&destruct_TListOfEnumsWithLockIter);
      instance.SetStreamerFunc(&streamer_TListOfEnumsWithLockIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfEnumsWithLockIter*)
   {
      return GenerateInitInstanceLocal((::TListOfEnumsWithLockIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfEnumsWithLockIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListOfFunctions(void *p);
   static void deleteArray_TListOfFunctions(void *p);
   static void destruct_TListOfFunctions(void *p);
   static Long64_t merge_TListOfFunctions(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfFunctions*)
   {
      ::TListOfFunctions *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfFunctions >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfFunctions", ::TListOfFunctions::Class_Version(), "TListOfFunctions.h", 34,
                  typeid(::TListOfFunctions), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfFunctions::Dictionary, isa_proxy, 4,
                  sizeof(::TListOfFunctions) );
      instance.SetDelete(&delete_TListOfFunctions);
      instance.SetDeleteArray(&deleteArray_TListOfFunctions);
      instance.SetDestructor(&destruct_TListOfFunctions);
      instance.SetMerge(&merge_TListOfFunctions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfFunctions*)
   {
      return GenerateInitInstanceLocal((::TListOfFunctions*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfFunctions*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListOfFunctionsIter(void *p);
   static void deleteArray_TListOfFunctionsIter(void *p);
   static void destruct_TListOfFunctionsIter(void *p);
   static void streamer_TListOfFunctionsIter(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfFunctionsIter*)
   {
      ::TListOfFunctionsIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfFunctionsIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfFunctionsIter", ::TListOfFunctionsIter::Class_Version(), "TListOfFunctions.h", 113,
                  typeid(::TListOfFunctionsIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfFunctionsIter::Dictionary, isa_proxy, 16,
                  sizeof(::TListOfFunctionsIter) );
      instance.SetDelete(&delete_TListOfFunctionsIter);
      instance.SetDeleteArray(&deleteArray_TListOfFunctionsIter);
      instance.SetDestructor(&destruct_TListOfFunctionsIter);
      instance.SetStreamerFunc(&streamer_TListOfFunctionsIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfFunctionsIter*)
   {
      return GenerateInitInstanceLocal((::TListOfFunctionsIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfFunctionsIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TListOfFunctionTemplates(void *p);
   static void deleteArray_TListOfFunctionTemplates(void *p);
   static void destruct_TListOfFunctionTemplates(void *p);
   static Long64_t merge_TListOfFunctionTemplates(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TListOfFunctionTemplates*)
   {
      ::TListOfFunctionTemplates *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TListOfFunctionTemplates >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TListOfFunctionTemplates", ::TListOfFunctionTemplates::Class_Version(), "TListOfFunctionTemplates.h", 34,
                  typeid(::TListOfFunctionTemplates), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TListOfFunctionTemplates::Dictionary, isa_proxy, 4,
                  sizeof(::TListOfFunctionTemplates) );
      instance.SetDelete(&delete_TListOfFunctionTemplates);
      instance.SetDeleteArray(&deleteArray_TListOfFunctionTemplates);
      instance.SetDestructor(&destruct_TListOfFunctionTemplates);
      instance.SetMerge(&merge_TListOfFunctionTemplates);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TListOfFunctionTemplates*)
   {
      return GenerateInitInstanceLocal((::TListOfFunctionTemplates*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TListOfFunctionTemplates*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TMemberStreamer_Dictionary();
   static void TMemberStreamer_TClassManip(TClass*);
   static void delete_TMemberStreamer(void *p);
   static void deleteArray_TMemberStreamer(void *p);
   static void destruct_TMemberStreamer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMemberStreamer*)
   {
      ::TMemberStreamer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TMemberStreamer));
      static ::ROOT::TGenericClassInfo 
         instance("TMemberStreamer", "TMemberStreamer.h", 26,
                  typeid(::TMemberStreamer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TMemberStreamer_Dictionary, isa_proxy, 4,
                  sizeof(::TMemberStreamer) );
      instance.SetDelete(&delete_TMemberStreamer);
      instance.SetDeleteArray(&deleteArray_TMemberStreamer);
      instance.SetDestructor(&destruct_TMemberStreamer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMemberStreamer*)
   {
      return GenerateInitInstanceLocal((::TMemberStreamer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMemberStreamer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TMemberStreamer_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TMemberStreamer*)nullptr)->GetClass();
      TMemberStreamer_TClassManip(theClass);
   return theClass;
   }

   static void TMemberStreamer_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TMethodArg(void *p = nullptr);
   static void *newArray_TMethodArg(Long_t size, void *p);
   static void delete_TMethodArg(void *p);
   static void deleteArray_TMethodArg(void *p);
   static void destruct_TMethodArg(void *p);
   static void streamer_TMethodArg(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TMethodArg*)
   {
      ::TMethodArg *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TMethodArg >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TMethodArg", ::TMethodArg::Class_Version(), "TMethodArg.h", 36,
                  typeid(::TMethodArg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TMethodArg::Dictionary, isa_proxy, 16,
                  sizeof(::TMethodArg) );
      instance.SetNew(&new_TMethodArg);
      instance.SetNewArray(&newArray_TMethodArg);
      instance.SetDelete(&delete_TMethodArg);
      instance.SetDeleteArray(&deleteArray_TMethodArg);
      instance.SetDestructor(&destruct_TMethodArg);
      instance.SetStreamerFunc(&streamer_TMethodArg);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TMethodArg*)
   {
      return GenerateInitInstanceLocal((::TMethodArg*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TMethodArg*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TProtoClass(void *p = nullptr);
   static void *newArray_TProtoClass(Long_t size, void *p);
   static void delete_TProtoClass(void *p);
   static void deleteArray_TProtoClass(void *p);
   static void destruct_TProtoClass(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TProtoClass*)
   {
      ::TProtoClass *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TProtoClass >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TProtoClass", ::TProtoClass::Class_Version(), "TProtoClass.h", 38,
                  typeid(::TProtoClass), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TProtoClass::Dictionary, isa_proxy, 4,
                  sizeof(::TProtoClass) );
      instance.SetNew(&new_TProtoClass);
      instance.SetNewArray(&newArray_TProtoClass);
      instance.SetDelete(&delete_TProtoClass);
      instance.SetDeleteArray(&deleteArray_TProtoClass);
      instance.SetDestructor(&destruct_TProtoClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TProtoClass*)
   {
      return GenerateInitInstanceLocal((::TProtoClass*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TProtoClass*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TProtoClasscLcLTProtoRealData(void *p = nullptr);
   static void *newArray_TProtoClasscLcLTProtoRealData(Long_t size, void *p);
   static void delete_TProtoClasscLcLTProtoRealData(void *p);
   static void deleteArray_TProtoClasscLcLTProtoRealData(void *p);
   static void destruct_TProtoClasscLcLTProtoRealData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TProtoClass::TProtoRealData*)
   {
      ::TProtoClass::TProtoRealData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TProtoClass::TProtoRealData >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TProtoClass::TProtoRealData", ::TProtoClass::TProtoRealData::Class_Version(), "TProtoClass.h", 40,
                  typeid(::TProtoClass::TProtoRealData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TProtoClass::TProtoRealData::Dictionary, isa_proxy, 4,
                  sizeof(::TProtoClass::TProtoRealData) );
      instance.SetNew(&new_TProtoClasscLcLTProtoRealData);
      instance.SetNewArray(&newArray_TProtoClasscLcLTProtoRealData);
      instance.SetDelete(&delete_TProtoClasscLcLTProtoRealData);
      instance.SetDeleteArray(&deleteArray_TProtoClasscLcLTProtoRealData);
      instance.SetDestructor(&destruct_TProtoClasscLcLTProtoRealData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TProtoClass::TProtoRealData*)
   {
      return GenerateInitInstanceLocal((::TProtoClass::TProtoRealData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TProtoClass::TProtoRealData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TRealData(void *p = nullptr);
   static void *newArray_TRealData(Long_t size, void *p);
   static void delete_TRealData(void *p);
   static void deleteArray_TRealData(void *p);
   static void destruct_TRealData(void *p);
   static void streamer_TRealData(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRealData*)
   {
      ::TRealData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRealData >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TRealData", ::TRealData::Class_Version(), "TRealData.h", 30,
                  typeid(::TRealData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TRealData::Dictionary, isa_proxy, 16,
                  sizeof(::TRealData) );
      instance.SetNew(&new_TRealData);
      instance.SetNewArray(&newArray_TRealData);
      instance.SetDelete(&delete_TRealData);
      instance.SetDeleteArray(&deleteArray_TRealData);
      instance.SetDestructor(&destruct_TRealData);
      instance.SetStreamerFunc(&streamer_TRealData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRealData*)
   {
      return GenerateInitInstanceLocal((::TRealData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TRealData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_ROOTcLcLTSchemaRule(void *p = nullptr);
   static void *newArray_ROOTcLcLTSchemaRule(Long_t size, void *p);
   static void delete_ROOTcLcLTSchemaRule(void *p);
   static void deleteArray_ROOTcLcLTSchemaRule(void *p);
   static void destruct_ROOTcLcLTSchemaRule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::TSchemaRule*)
   {
      ::ROOT::TSchemaRule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::TSchemaRule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::TSchemaRule", ::ROOT::TSchemaRule::Class_Version(), "TSchemaRule.h", 19,
                  typeid(::ROOT::TSchemaRule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::TSchemaRule::Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::TSchemaRule) );
      instance.SetNew(&new_ROOTcLcLTSchemaRule);
      instance.SetNewArray(&newArray_ROOTcLcLTSchemaRule);
      instance.SetDelete(&delete_ROOTcLcLTSchemaRule);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLTSchemaRule);
      instance.SetDestructor(&destruct_ROOTcLcLTSchemaRule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::TSchemaRule*)
   {
      return GenerateInitInstanceLocal((::ROOT::TSchemaRule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::TSchemaRule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_ROOTcLcLTSchemaRulecLcLTSources(void *p = nullptr);
   static void *newArray_ROOTcLcLTSchemaRulecLcLTSources(Long_t size, void *p);
   static void delete_ROOTcLcLTSchemaRulecLcLTSources(void *p);
   static void deleteArray_ROOTcLcLTSchemaRulecLcLTSources(void *p);
   static void destruct_ROOTcLcLTSchemaRulecLcLTSources(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::TSchemaRule::TSources*)
   {
      ::ROOT::TSchemaRule::TSources *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::TSchemaRule::TSources >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::TSchemaRule::TSources", ::ROOT::TSchemaRule::TSources::Class_Version(), "TSchemaRule.h", 23,
                  typeid(::ROOT::TSchemaRule::TSources), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::TSchemaRule::TSources::Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::TSchemaRule::TSources) );
      instance.SetNew(&new_ROOTcLcLTSchemaRulecLcLTSources);
      instance.SetNewArray(&newArray_ROOTcLcLTSchemaRulecLcLTSources);
      instance.SetDelete(&delete_ROOTcLcLTSchemaRulecLcLTSources);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLTSchemaRulecLcLTSources);
      instance.SetDestructor(&destruct_ROOTcLcLTSchemaRulecLcLTSources);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::TSchemaRule::TSources*)
   {
      return GenerateInitInstanceLocal((::ROOT::TSchemaRule::TSources*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::TSchemaRule::TSources*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p = nullptr);
   static void *newArray_ROOTcLcLDetailcLcLTSchemaRuleSet(Long_t size, void *p);
   static void delete_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p);
   static void deleteArray_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p);
   static void destruct_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p);
   static void streamer_ROOTcLcLDetailcLcLTSchemaRuleSet(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Detail::TSchemaRuleSet*)
   {
      ::ROOT::Detail::TSchemaRuleSet *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::ROOT::Detail::TSchemaRuleSet >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Detail::TSchemaRuleSet", ::ROOT::Detail::TSchemaRuleSet::Class_Version(), "TSchemaRuleSet.h", 24,
                  typeid(::ROOT::Detail::TSchemaRuleSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::ROOT::Detail::TSchemaRuleSet::Dictionary, isa_proxy, 17,
                  sizeof(::ROOT::Detail::TSchemaRuleSet) );
      instance.SetNew(&new_ROOTcLcLDetailcLcLTSchemaRuleSet);
      instance.SetNewArray(&newArray_ROOTcLcLDetailcLcLTSchemaRuleSet);
      instance.SetDelete(&delete_ROOTcLcLDetailcLcLTSchemaRuleSet);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLDetailcLcLTSchemaRuleSet);
      instance.SetDestructor(&destruct_ROOTcLcLDetailcLcLTSchemaRuleSet);
      instance.SetStreamerFunc(&streamer_ROOTcLcLDetailcLcLTSchemaRuleSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Detail::TSchemaRuleSet*)
   {
      return GenerateInitInstanceLocal((::ROOT::Detail::TSchemaRuleSet*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::Detail::TSchemaRuleSet*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *ROOTcLcLDetailcLcLTStatusBitsChecker_Dictionary();
   static void ROOTcLcLDetailcLcLTStatusBitsChecker_TClassManip(TClass*);
   static void *new_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p = nullptr);
   static void *newArray_ROOTcLcLDetailcLcLTStatusBitsChecker(Long_t size, void *p);
   static void delete_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p);
   static void deleteArray_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p);
   static void destruct_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Detail::TStatusBitsChecker*)
   {
      ::ROOT::Detail::TStatusBitsChecker *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Detail::TStatusBitsChecker));
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Detail::TStatusBitsChecker", "TStatusBitsChecker.h", 25,
                  typeid(::ROOT::Detail::TStatusBitsChecker), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &ROOTcLcLDetailcLcLTStatusBitsChecker_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Detail::TStatusBitsChecker) );
      instance.SetNew(&new_ROOTcLcLDetailcLcLTStatusBitsChecker);
      instance.SetNewArray(&newArray_ROOTcLcLDetailcLcLTStatusBitsChecker);
      instance.SetDelete(&delete_ROOTcLcLDetailcLcLTStatusBitsChecker);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLDetailcLcLTStatusBitsChecker);
      instance.SetDestructor(&destruct_ROOTcLcLDetailcLcLTStatusBitsChecker);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Detail::TStatusBitsChecker*)
   {
      return GenerateInitInstanceLocal((::ROOT::Detail::TStatusBitsChecker*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::ROOT::Detail::TStatusBitsChecker*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ROOTcLcLDetailcLcLTStatusBitsChecker_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ROOT::Detail::TStatusBitsChecker*)nullptr)->GetClass();
      ROOTcLcLDetailcLcLTStatusBitsChecker_TClassManip(theClass);
   return theClass;
   }

   static void ROOTcLcLDetailcLcLTStatusBitsChecker_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerElement(void *p = nullptr);
   static void *newArray_TStreamerElement(Long_t size, void *p);
   static void delete_TStreamerElement(void *p);
   static void deleteArray_TStreamerElement(void *p);
   static void destruct_TStreamerElement(void *p);
   static void streamer_TStreamerElement(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerElement*)
   {
      ::TStreamerElement *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerElement >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerElement", ::TStreamerElement::Class_Version(), "TStreamerElement.h", 33,
                  typeid(::TStreamerElement), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerElement::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerElement) );
      instance.SetNew(&new_TStreamerElement);
      instance.SetNewArray(&newArray_TStreamerElement);
      instance.SetDelete(&delete_TStreamerElement);
      instance.SetDeleteArray(&deleteArray_TStreamerElement);
      instance.SetDestructor(&destruct_TStreamerElement);
      instance.SetStreamerFunc(&streamer_TStreamerElement);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerElement*)
   {
      return GenerateInitInstanceLocal((::TStreamerElement*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerElement*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerBase(void *p = nullptr);
   static void *newArray_TStreamerBase(Long_t size, void *p);
   static void delete_TStreamerBase(void *p);
   static void deleteArray_TStreamerBase(void *p);
   static void destruct_TStreamerBase(void *p);
   static void streamer_TStreamerBase(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerBase*)
   {
      ::TStreamerBase *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerBase >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerBase", ::TStreamerBase::Class_Version(), "TStreamerElement.h", 151,
                  typeid(::TStreamerBase), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerBase::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerBase) );
      instance.SetNew(&new_TStreamerBase);
      instance.SetNewArray(&newArray_TStreamerBase);
      instance.SetDelete(&delete_TStreamerBase);
      instance.SetDeleteArray(&deleteArray_TStreamerBase);
      instance.SetDestructor(&destruct_TStreamerBase);
      instance.SetStreamerFunc(&streamer_TStreamerBase);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerBase*)
   {
      return GenerateInitInstanceLocal((::TStreamerBase*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerBase*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerBasicPointer(void *p = nullptr);
   static void *newArray_TStreamerBasicPointer(Long_t size, void *p);
   static void delete_TStreamerBasicPointer(void *p);
   static void deleteArray_TStreamerBasicPointer(void *p);
   static void destruct_TStreamerBasicPointer(void *p);
   static void streamer_TStreamerBasicPointer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerBasicPointer*)
   {
      ::TStreamerBasicPointer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerBasicPointer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerBasicPointer", ::TStreamerBasicPointer::Class_Version(), "TStreamerElement.h", 199,
                  typeid(::TStreamerBasicPointer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerBasicPointer::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerBasicPointer) );
      instance.SetNew(&new_TStreamerBasicPointer);
      instance.SetNewArray(&newArray_TStreamerBasicPointer);
      instance.SetDelete(&delete_TStreamerBasicPointer);
      instance.SetDeleteArray(&deleteArray_TStreamerBasicPointer);
      instance.SetDestructor(&destruct_TStreamerBasicPointer);
      instance.SetStreamerFunc(&streamer_TStreamerBasicPointer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerBasicPointer*)
   {
      return GenerateInitInstanceLocal((::TStreamerBasicPointer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerBasicPointer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerLoop(void *p = nullptr);
   static void *newArray_TStreamerLoop(Long_t size, void *p);
   static void delete_TStreamerLoop(void *p);
   static void deleteArray_TStreamerLoop(void *p);
   static void destruct_TStreamerLoop(void *p);
   static void streamer_TStreamerLoop(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerLoop*)
   {
      ::TStreamerLoop *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerLoop >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerLoop", ::TStreamerLoop::Class_Version(), "TStreamerElement.h", 236,
                  typeid(::TStreamerLoop), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerLoop::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerLoop) );
      instance.SetNew(&new_TStreamerLoop);
      instance.SetNewArray(&newArray_TStreamerLoop);
      instance.SetDelete(&delete_TStreamerLoop);
      instance.SetDeleteArray(&deleteArray_TStreamerLoop);
      instance.SetDestructor(&destruct_TStreamerLoop);
      instance.SetStreamerFunc(&streamer_TStreamerLoop);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerLoop*)
   {
      return GenerateInitInstanceLocal((::TStreamerLoop*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerLoop*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerBasicType(void *p = nullptr);
   static void *newArray_TStreamerBasicType(Long_t size, void *p);
   static void delete_TStreamerBasicType(void *p);
   static void deleteArray_TStreamerBasicType(void *p);
   static void destruct_TStreamerBasicType(void *p);
   static void streamer_TStreamerBasicType(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerBasicType*)
   {
      ::TStreamerBasicType *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerBasicType >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerBasicType", ::TStreamerBasicType::Class_Version(), "TStreamerElement.h", 270,
                  typeid(::TStreamerBasicType), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerBasicType::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerBasicType) );
      instance.SetNew(&new_TStreamerBasicType);
      instance.SetNewArray(&newArray_TStreamerBasicType);
      instance.SetDelete(&delete_TStreamerBasicType);
      instance.SetDeleteArray(&deleteArray_TStreamerBasicType);
      instance.SetDestructor(&destruct_TStreamerBasicType);
      instance.SetStreamerFunc(&streamer_TStreamerBasicType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerBasicType*)
   {
      return GenerateInitInstanceLocal((::TStreamerBasicType*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerBasicType*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerObject(void *p = nullptr);
   static void *newArray_TStreamerObject(Long_t size, void *p);
   static void delete_TStreamerObject(void *p);
   static void deleteArray_TStreamerObject(void *p);
   static void destruct_TStreamerObject(void *p);
   static void streamer_TStreamerObject(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerObject*)
   {
      ::TStreamerObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerObject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerObject", ::TStreamerObject::Class_Version(), "TStreamerElement.h", 294,
                  typeid(::TStreamerObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerObject::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerObject) );
      instance.SetNew(&new_TStreamerObject);
      instance.SetNewArray(&newArray_TStreamerObject);
      instance.SetDelete(&delete_TStreamerObject);
      instance.SetDeleteArray(&deleteArray_TStreamerObject);
      instance.SetDestructor(&destruct_TStreamerObject);
      instance.SetStreamerFunc(&streamer_TStreamerObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerObject*)
   {
      return GenerateInitInstanceLocal((::TStreamerObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerObjectAny(void *p = nullptr);
   static void *newArray_TStreamerObjectAny(Long_t size, void *p);
   static void delete_TStreamerObjectAny(void *p);
   static void deleteArray_TStreamerObjectAny(void *p);
   static void destruct_TStreamerObjectAny(void *p);
   static void streamer_TStreamerObjectAny(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerObjectAny*)
   {
      ::TStreamerObjectAny *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerObjectAny >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerObjectAny", ::TStreamerObjectAny::Class_Version(), "TStreamerElement.h", 313,
                  typeid(::TStreamerObjectAny), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerObjectAny::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerObjectAny) );
      instance.SetNew(&new_TStreamerObjectAny);
      instance.SetNewArray(&newArray_TStreamerObjectAny);
      instance.SetDelete(&delete_TStreamerObjectAny);
      instance.SetDeleteArray(&deleteArray_TStreamerObjectAny);
      instance.SetDestructor(&destruct_TStreamerObjectAny);
      instance.SetStreamerFunc(&streamer_TStreamerObjectAny);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerObjectAny*)
   {
      return GenerateInitInstanceLocal((::TStreamerObjectAny*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerObjectAny*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerObjectPointer(void *p = nullptr);
   static void *newArray_TStreamerObjectPointer(Long_t size, void *p);
   static void delete_TStreamerObjectPointer(void *p);
   static void deleteArray_TStreamerObjectPointer(void *p);
   static void destruct_TStreamerObjectPointer(void *p);
   static void streamer_TStreamerObjectPointer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerObjectPointer*)
   {
      ::TStreamerObjectPointer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerObjectPointer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerObjectPointer", ::TStreamerObjectPointer::Class_Version(), "TStreamerElement.h", 332,
                  typeid(::TStreamerObjectPointer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerObjectPointer::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerObjectPointer) );
      instance.SetNew(&new_TStreamerObjectPointer);
      instance.SetNewArray(&newArray_TStreamerObjectPointer);
      instance.SetDelete(&delete_TStreamerObjectPointer);
      instance.SetDeleteArray(&deleteArray_TStreamerObjectPointer);
      instance.SetDestructor(&destruct_TStreamerObjectPointer);
      instance.SetStreamerFunc(&streamer_TStreamerObjectPointer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerObjectPointer*)
   {
      return GenerateInitInstanceLocal((::TStreamerObjectPointer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerObjectPointer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerObjectAnyPointer(void *p = nullptr);
   static void *newArray_TStreamerObjectAnyPointer(Long_t size, void *p);
   static void delete_TStreamerObjectAnyPointer(void *p);
   static void deleteArray_TStreamerObjectAnyPointer(void *p);
   static void destruct_TStreamerObjectAnyPointer(void *p);
   static void streamer_TStreamerObjectAnyPointer(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerObjectAnyPointer*)
   {
      ::TStreamerObjectAnyPointer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerObjectAnyPointer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerObjectAnyPointer", ::TStreamerObjectAnyPointer::Class_Version(), "TStreamerElement.h", 353,
                  typeid(::TStreamerObjectAnyPointer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerObjectAnyPointer::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerObjectAnyPointer) );
      instance.SetNew(&new_TStreamerObjectAnyPointer);
      instance.SetNewArray(&newArray_TStreamerObjectAnyPointer);
      instance.SetDelete(&delete_TStreamerObjectAnyPointer);
      instance.SetDeleteArray(&deleteArray_TStreamerObjectAnyPointer);
      instance.SetDestructor(&destruct_TStreamerObjectAnyPointer);
      instance.SetStreamerFunc(&streamer_TStreamerObjectAnyPointer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerObjectAnyPointer*)
   {
      return GenerateInitInstanceLocal((::TStreamerObjectAnyPointer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerObjectAnyPointer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerString(void *p = nullptr);
   static void *newArray_TStreamerString(Long_t size, void *p);
   static void delete_TStreamerString(void *p);
   static void deleteArray_TStreamerString(void *p);
   static void destruct_TStreamerString(void *p);
   static void streamer_TStreamerString(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerString*)
   {
      ::TStreamerString *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerString >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerString", ::TStreamerString::Class_Version(), "TStreamerElement.h", 374,
                  typeid(::TStreamerString), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerString::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerString) );
      instance.SetNew(&new_TStreamerString);
      instance.SetNewArray(&newArray_TStreamerString);
      instance.SetDelete(&delete_TStreamerString);
      instance.SetDeleteArray(&deleteArray_TStreamerString);
      instance.SetDestructor(&destruct_TStreamerString);
      instance.SetStreamerFunc(&streamer_TStreamerString);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerString*)
   {
      return GenerateInitInstanceLocal((::TStreamerString*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerString*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerSTL(void *p = nullptr);
   static void *newArray_TStreamerSTL(Long_t size, void *p);
   static void delete_TStreamerSTL(void *p);
   static void deleteArray_TStreamerSTL(void *p);
   static void destruct_TStreamerSTL(void *p);
   static void streamer_TStreamerSTL(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerSTL*)
   {
      ::TStreamerSTL *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerSTL >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerSTL", ::TStreamerSTL::Class_Version(), "TStreamerElement.h", 392,
                  typeid(::TStreamerSTL), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerSTL::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerSTL) );
      instance.SetNew(&new_TStreamerSTL);
      instance.SetNewArray(&newArray_TStreamerSTL);
      instance.SetDelete(&delete_TStreamerSTL);
      instance.SetDeleteArray(&deleteArray_TStreamerSTL);
      instance.SetDestructor(&destruct_TStreamerSTL);
      instance.SetStreamerFunc(&streamer_TStreamerSTL);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerSTL*)
   {
      return GenerateInitInstanceLocal((::TStreamerSTL*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerSTL*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_TStreamerSTLstring(void *p = nullptr);
   static void *newArray_TStreamerSTLstring(Long_t size, void *p);
   static void delete_TStreamerSTLstring(void *p);
   static void deleteArray_TStreamerSTLstring(void *p);
   static void destruct_TStreamerSTLstring(void *p);
   static void streamer_TStreamerSTLstring(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerSTLstring*)
   {
      ::TStreamerSTLstring *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerSTLstring >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerSTLstring", ::TStreamerSTLstring::Class_Version(), "TStreamerElement.h", 426,
                  typeid(::TStreamerSTLstring), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerSTLstring::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerSTLstring) );
      instance.SetNew(&new_TStreamerSTLstring);
      instance.SetNewArray(&newArray_TStreamerSTLstring);
      instance.SetDelete(&delete_TStreamerSTLstring);
      instance.SetDeleteArray(&deleteArray_TStreamerSTLstring);
      instance.SetDestructor(&destruct_TStreamerSTLstring);
      instance.SetStreamerFunc(&streamer_TStreamerSTLstring);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerSTLstring*)
   {
      return GenerateInitInstanceLocal((::TStreamerSTLstring*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerSTLstring*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TStreamerArtificial(void *p);
   static void deleteArray_TStreamerArtificial(void *p);
   static void destruct_TStreamerArtificial(void *p);
   static void streamer_TStreamerArtificial(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TStreamerArtificial*)
   {
      ::TStreamerArtificial *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TStreamerArtificial >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TStreamerArtificial", ::TStreamerArtificial::Class_Version(), "TStreamerElement.h", 450,
                  typeid(::TStreamerArtificial), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TStreamerArtificial::Dictionary, isa_proxy, 17,
                  sizeof(::TStreamerArtificial) );
      instance.SetDelete(&delete_TStreamerArtificial);
      instance.SetDeleteArray(&deleteArray_TStreamerArtificial);
      instance.SetDestructor(&destruct_TStreamerArtificial);
      instance.SetStreamerFunc(&streamer_TStreamerArtificial);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TStreamerArtificial*)
   {
      return GenerateInitInstanceLocal((::TStreamerArtificial*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TStreamerArtificial*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_TVirtualStreamerInfo(void *p);
   static void deleteArray_TVirtualStreamerInfo(void *p);
   static void destruct_TVirtualStreamerInfo(void *p);
   static void streamer_TVirtualStreamerInfo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualStreamerInfo*)
   {
      ::TVirtualStreamerInfo *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualStreamerInfo >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualStreamerInfo", ::TVirtualStreamerInfo::Class_Version(), "TVirtualStreamerInfo.h", 44,
                  typeid(::TVirtualStreamerInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::TVirtualStreamerInfo::Dictionary, isa_proxy, 17,
                  sizeof(::TVirtualStreamerInfo) );
      instance.SetDelete(&delete_TVirtualStreamerInfo);
      instance.SetDeleteArray(&deleteArray_TVirtualStreamerInfo);
      instance.SetDestructor(&destruct_TVirtualStreamerInfo);
      instance.SetStreamerFunc(&streamer_TVirtualStreamerInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualStreamerInfo*)
   {
      return GenerateInitInstanceLocal((::TVirtualStreamerInfo*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualStreamerInfo*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *TVirtualArray_Dictionary();
   static void TVirtualArray_TClassManip(TClass*);
   static void delete_TVirtualArray(void *p);
   static void deleteArray_TVirtualArray(void *p);
   static void destruct_TVirtualArray(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualArray*)
   {
      ::TVirtualArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TVirtualArray));
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualArray", 0, "TVirtualArray.h", 27,
                  typeid(::TVirtualArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TVirtualArray_Dictionary, isa_proxy, 9,
                  sizeof(::TVirtualArray) );
      instance.SetDelete(&delete_TVirtualArray);
      instance.SetDeleteArray(&deleteArray_TVirtualArray);
      instance.SetDestructor(&destruct_TVirtualArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualArray*)
   {
      return GenerateInitInstanceLocal((::TVirtualArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TVirtualArray_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TVirtualArray*)nullptr)->GetClass();
      TVirtualArray_TClassManip(theClass);
   return theClass;
   }

   static void TVirtualArray_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TVirtualObject_Dictionary();
   static void TVirtualObject_TClassManip(TClass*);
   static void delete_TVirtualObject(void *p);
   static void deleteArray_TVirtualObject(void *p);
   static void destruct_TVirtualObject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualObject*)
   {
      ::TVirtualObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TVirtualObject));
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualObject", 0, "TVirtualObject.h", 26,
                  typeid(::TVirtualObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &TVirtualObject_Dictionary, isa_proxy, 9,
                  sizeof(::TVirtualObject) );
      instance.SetDelete(&delete_TVirtualObject);
      instance.SetDeleteArray(&deleteArray_TVirtualObject);
      instance.SetDestructor(&destruct_TVirtualObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualObject*)
   {
      return GenerateInitInstanceLocal((::TVirtualObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::TVirtualObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TVirtualObject_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::TVirtualObject*)nullptr)->GetClass();
      TVirtualObject_TClassManip(theClass);
   return theClass;
   }

   static void TVirtualObject_TClassManip(TClass* ){
   }

} // end of namespace ROOT

//______________________________________________________________________________
atomic_TClass_ptr TStorage::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStorage::Class_Name()
{
   return "TStorage";
}

//______________________________________________________________________________
const char *TStorage::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStorage*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStorage::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStorage*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStorage::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStorage*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStorage::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStorage*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObject::Class_Name()
{
   return "TObject";
}

//______________________________________________________________________________
const char *TObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TIterator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TIterator::Class_Name()
{
   return "TIterator";
}

//______________________________________________________________________________
const char *TIterator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TIterator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TIterator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TIterator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TIterator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TIterator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TIterator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TIterator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TString::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TString::Class_Name()
{
   return "TString";
}

//______________________________________________________________________________
const char *TString::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TString*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TString::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TString*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TString::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TString*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TString::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TString*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualMutex::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMutex::Class_Name()
{
   return "TVirtualMutex";
}

//______________________________________________________________________________
const char *TVirtualMutex::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMutex::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualMutex::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualMutex::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TLockGuard::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TLockGuard::Class_Name()
{
   return "TLockGuard";
}

//______________________________________________________________________________
const char *TLockGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TLockGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TLockGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TLockGuard::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)nullptr)->GetClass(); }
   return fgIsA;
}

namespace ROOT {
//______________________________________________________________________________
atomic_TClass_ptr TVirtualRWMutex::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualRWMutex::Class_Name()
{
   return "ROOT::TVirtualRWMutex";
}

//______________________________________________________________________________
const char *TVirtualRWMutex::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TVirtualRWMutex*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualRWMutex::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TVirtualRWMutex*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualRWMutex::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TVirtualRWMutex*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualRWMutex::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TVirtualRWMutex*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT
namespace ROOT {
//______________________________________________________________________________
atomic_TClass_ptr TReadLockGuard::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TReadLockGuard::Class_Name()
{
   return "ROOT::TReadLockGuard";
}

//______________________________________________________________________________
const char *TReadLockGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TReadLockGuard*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TReadLockGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TReadLockGuard*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TReadLockGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TReadLockGuard*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TReadLockGuard::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TReadLockGuard*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT
namespace ROOT {
//______________________________________________________________________________
atomic_TClass_ptr TWriteLockGuard::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TWriteLockGuard::Class_Name()
{
   return "ROOT::TWriteLockGuard";
}

//______________________________________________________________________________
const char *TWriteLockGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TWriteLockGuard*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TWriteLockGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TWriteLockGuard*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TWriteLockGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TWriteLockGuard*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TWriteLockGuard::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TWriteLockGuard*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT
//______________________________________________________________________________
atomic_TClass_ptr TCollection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TCollection::Class_Name()
{
   return "TCollection";
}

//______________________________________________________________________________
const char *TCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TCollection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TCollection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TCollection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TCollection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TIter::Class_Name()
{
   return "TIter";
}

//______________________________________________________________________________
const char *TIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSeqCollection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSeqCollection::Class_Name()
{
   return "TSeqCollection";
}

//______________________________________________________________________________
const char *TSeqCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSeqCollection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSeqCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSeqCollection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSeqCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSeqCollection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSeqCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSeqCollection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TList::Class_Name()
{
   return "TList";
}

//______________________________________________________________________________
const char *TList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListIter::Class_Name()
{
   return "TListIter";
}

//______________________________________________________________________________
const char *TListIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TNamed::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TNamed::Class_Name()
{
   return "TNamed";
}

//______________________________________________________________________________
const char *TNamed::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TNamed*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TNamed::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TNamed*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TNamed::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TNamed*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TNamed::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TNamed*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDictionary::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDictionary::Class_Name()
{
   return "TDictionary";
}

//______________________________________________________________________________
const char *TDictionary::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDictionary*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDictionary::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDictionary*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDictionary::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDictionary*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDictionary::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDictionary*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDataType::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDataType::Class_Name()
{
   return "TDataType";
}

//______________________________________________________________________________
const char *TDataType::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDataType*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDataType::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDataType*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDataType::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDataType*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDataType::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDataType*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TInterpreter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TInterpreter::Class_Name()
{
   return "TInterpreter";
}

//______________________________________________________________________________
const char *TInterpreter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInterpreter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TInterpreter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInterpreter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TInterpreter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInterpreter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TInterpreter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInterpreter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQObject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQObject::Class_Name()
{
   return "TQObject";
}

//______________________________________________________________________________
const char *TQObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQObject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQObject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQObject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQObject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQObjSender::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQObjSender::Class_Name()
{
   return "TQObjSender";
}

//______________________________________________________________________________
const char *TQObjSender::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQObjSender*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQObjSender::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQObjSender*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQObjSender::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQObjSender*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQObjSender::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQObjSender*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TApplicationImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TApplicationImp::Class_Name()
{
   return "TApplicationImp";
}

//______________________________________________________________________________
const char *TApplicationImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TApplicationImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TApplicationImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TApplicationImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TApplicationImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TApplicationImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TApplicationImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TApplicationImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TApplication::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TApplication::Class_Name()
{
   return "TApplication";
}

//______________________________________________________________________________
const char *TApplication::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TApplication*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TApplication::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TApplication*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TApplication::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TApplication*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TApplication::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TApplication*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAtt3D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAtt3D::Class_Name()
{
   return "TAtt3D";
}

//______________________________________________________________________________
const char *TAtt3D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAtt3D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAtt3D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAtt3D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAtt3D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAtt3D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAtt3D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAtt3D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttAxis::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttAxis::Class_Name()
{
   return "TAttAxis";
}

//______________________________________________________________________________
const char *TAttAxis::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttAxis*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttAxis::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttAxis*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttAxis::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttAxis*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttAxis::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttAxis*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttBBox2D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttBBox2D::Class_Name()
{
   return "TAttBBox2D";
}

//______________________________________________________________________________
const char *TAttBBox2D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox2D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttBBox2D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox2D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttBBox2D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox2D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttBBox2D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox2D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttBBox::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttBBox::Class_Name()
{
   return "TAttBBox";
}

//______________________________________________________________________________
const char *TAttBBox::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttBBox::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttBBox::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttBBox::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttBBox*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttFill::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttFill::Class_Name()
{
   return "TAttFill";
}

//______________________________________________________________________________
const char *TAttFill::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttFill*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttFill::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttFill*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttFill::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttFill*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttFill::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttFill*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttLine::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttLine::Class_Name()
{
   return "TAttLine";
}

//______________________________________________________________________________
const char *TAttLine::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttLine*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttLine::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttLine*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttLine::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttLine*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttLine::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttLine*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttMarker::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttMarker::Class_Name()
{
   return "TAttMarker";
}

//______________________________________________________________________________
const char *TAttMarker::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttMarker*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttMarker::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttMarker*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttMarker::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttMarker*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttMarker::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttMarker*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttPad::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttPad::Class_Name()
{
   return "TAttPad";
}

//______________________________________________________________________________
const char *TAttPad::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttPad*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttPad::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttPad*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttPad::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttPad*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttPad::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttPad*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TAttText::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TAttText::Class_Name()
{
   return "TAttText";
}

//______________________________________________________________________________
const char *TAttText::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttText*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TAttText::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TAttText*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TAttText::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttText*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TAttText::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TAttText*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBase64::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBase64::Class_Name()
{
   return "TBase64";
}

//______________________________________________________________________________
const char *TBase64::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBase64::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBase64::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBase64::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStopwatch::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStopwatch::Class_Name()
{
   return "TStopwatch";
}

//______________________________________________________________________________
const char *TStopwatch::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStopwatch*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStopwatch::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStopwatch*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStopwatch::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStopwatch*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStopwatch::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStopwatch*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBenchmark::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBenchmark::Class_Name()
{
   return "TBenchmark";
}

//______________________________________________________________________________
const char *TBenchmark::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBenchmark*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBenchmark::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBenchmark*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBenchmark::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBenchmark*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBenchmark::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBenchmark*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBuffer3D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBuffer3D::Class_Name()
{
   return "TBuffer3D";
}

//______________________________________________________________________________
const char *TBuffer3D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBuffer3D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBuffer3D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBuffer3D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBuffer3D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBuffer3D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBuffer3D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBuffer3D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjArray::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjArray::Class_Name()
{
   return "TObjArray";
}

//______________________________________________________________________________
const char *TObjArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjArray*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjArray*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjArray*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjArray*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjArrayIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjArrayIter::Class_Name()
{
   return "TObjArrayIter";
}

//______________________________________________________________________________
const char *TObjArrayIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjArrayIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjArrayIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjArrayIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjArrayIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjArrayIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjArrayIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjArrayIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TClass::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TClass::Class_Name()
{
   return "TClass";
}

//______________________________________________________________________________
const char *TClass::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClass*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TClass::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClass*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TClass::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClass*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TClass::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClass*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBuffer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBuffer::Class_Name()
{
   return "TBuffer";
}

//______________________________________________________________________________
const char *TBuffer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBuffer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBuffer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBuffer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBuffer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBuffer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBuffer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBuffer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TColor::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TColor::Class_Name()
{
   return "TColor";
}

//______________________________________________________________________________
const char *TColor::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TColor*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TColor::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TColor*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TColor::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TColor*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TColor::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TColor*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TColorGradient::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TColorGradient::Class_Name()
{
   return "TColorGradient";
}

//______________________________________________________________________________
const char *TColorGradient::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TColorGradient*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TColorGradient::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TColorGradient*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TColorGradient::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TColorGradient*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TColorGradient::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TColorGradient*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TLinearGradient::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TLinearGradient::Class_Name()
{
   return "TLinearGradient";
}

//______________________________________________________________________________
const char *TLinearGradient::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLinearGradient*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TLinearGradient::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLinearGradient*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TLinearGradient::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLinearGradient*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TLinearGradient::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLinearGradient*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRadialGradient::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRadialGradient::Class_Name()
{
   return "TRadialGradient";
}

//______________________________________________________________________________
const char *TRadialGradient::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRadialGradient*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRadialGradient::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRadialGradient*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRadialGradient::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRadialGradient*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRadialGradient::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRadialGradient*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDatime::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDatime::Class_Name()
{
   return "TDatime";
}

//______________________________________________________________________________
const char *TDatime::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDatime*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDatime::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDatime*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDatime::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDatime*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDatime::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDatime*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TUUID::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TUUID::Class_Name()
{
   return "TUUID";
}

//______________________________________________________________________________
const char *TUUID::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUUID*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TUUID::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUUID*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TUUID::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUUID*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUUID::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUUID*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDirectory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDirectory::Class_Name()
{
   return "TDirectory";
}

//______________________________________________________________________________
const char *TDirectory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDirectory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDirectory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDirectory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDirectory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDirectory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDirectory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDirectory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TEnvRec::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TEnvRec::Class_Name()
{
   return "TEnvRec";
}

//______________________________________________________________________________
const char *TEnvRec::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnvRec*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TEnvRec::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnvRec*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TEnvRec::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnvRec*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TEnvRec::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnvRec*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TEnv::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TEnv::Class_Name()
{
   return "TEnv";
}

//______________________________________________________________________________
const char *TEnv::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnv*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TEnv::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnv*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TEnv::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnv*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TEnv::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnv*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TExec::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TExec::Class_Name()
{
   return "TExec";
}

//______________________________________________________________________________
const char *TExec::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExec*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TExec::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExec*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TExec::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExec*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TExec::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExec*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFileCollection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFileCollection::Class_Name()
{
   return "TFileCollection";
}

//______________________________________________________________________________
const char *TFileCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFileCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFileCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TUrl::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TUrl::Class_Name()
{
   return "TUrl";
}

//______________________________________________________________________________
const char *TUrl::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TUrl::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TUrl::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUrl::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMD5::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMD5::Class_Name()
{
   return "TMD5";
}

//______________________________________________________________________________
const char *TMD5::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMD5*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMD5::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMD5*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMD5::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMD5*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMD5::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMD5*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFileInfo::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFileInfo::Class_Name()
{
   return "TFileInfo";
}

//______________________________________________________________________________
const char *TFileInfo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFileInfo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFileInfo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileInfo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFileInfoMeta::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFileInfoMeta::Class_Name()
{
   return "TFileInfoMeta";
}

//______________________________________________________________________________
const char *TFileInfoMeta::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFileInfoMeta::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFileInfoMeta::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileInfoMeta::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFolder::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFolder::Class_Name()
{
   return "TFolder";
}

//______________________________________________________________________________
const char *TFolder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFolder*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFolder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFolder*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFolder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFolder*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFolder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFolder*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TInetAddress::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TInetAddress::Class_Name()
{
   return "TInetAddress";
}

//______________________________________________________________________________
const char *TInetAddress::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TInetAddress::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TInetAddress::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TInetAddress::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMacro::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMacro::Class_Name()
{
   return "TMacro";
}

//______________________________________________________________________________
const char *TMacro::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMacro*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMacro::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMacro*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMacro::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMacro*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMacro::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMacro*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMemberInspector::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMemberInspector::Class_Name()
{
   return "TMemberInspector";
}

//______________________________________________________________________________
const char *TMemberInspector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMemberInspector*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMemberInspector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMemberInspector*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMemberInspector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMemberInspector*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMemberInspector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMemberInspector*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMessageHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMessageHandler::Class_Name()
{
   return "TMessageHandler";
}

//______________________________________________________________________________
const char *TMessageHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMessageHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMessageHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMessageHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMessageHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMessageHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMessageHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMessageHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TNotifyLinkBase::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TNotifyLinkBase::Class_Name()
{
   return "TNotifyLinkBase";
}

//______________________________________________________________________________
const char *TNotifyLinkBase::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TNotifyLinkBase*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TNotifyLinkBase::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TNotifyLinkBase*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TNotifyLinkBase::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TNotifyLinkBase*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TNotifyLinkBase::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TNotifyLinkBase*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjString::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjString::Class_Name()
{
   return "TObjString";
}

//______________________________________________________________________________
const char *TObjString::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjString*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjString::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjString*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjString::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjString*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjString::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjString*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TROOT::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TROOT::Class_Name()
{
   return "TROOT";
}

//______________________________________________________________________________
const char *TROOT::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TROOT*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TROOT::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TROOT*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TROOT::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TROOT*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TROOT::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TROOT*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<bool>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<bool>::Class_Name()
{
   return "TParameter<bool>";
}

//______________________________________________________________________________
template <> const char *TParameter<bool>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<bool>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<bool>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<bool>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<bool>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<Long64_t>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<Long64_t>::Class_Name()
{
   return "TParameter<Long64_t>";
}

//______________________________________________________________________________
template <> const char *TParameter<Long64_t>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<Long64_t>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<Long64_t>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<Long64_t>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<long>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<long>::Class_Name()
{
   return "TParameter<long>";
}

//______________________________________________________________________________
template <> const char *TParameter<long>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<long>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<long>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<long>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<int>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<int>::Class_Name()
{
   return "TParameter<int>";
}

//______________________________________________________________________________
template <> const char *TParameter<int>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<int>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<int>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<int>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<double>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<double>::Class_Name()
{
   return "TParameter<double>";
}

//______________________________________________________________________________
template <> const char *TParameter<double>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<double>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<double>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<double>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr TParameter<float>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<float>::Class_Name()
{
   return "TParameter<float>";
}

//______________________________________________________________________________
template <> const char *TParameter<float>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<float>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *TParameter<float>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<float>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMethodCall::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMethodCall::Class_Name()
{
   return "TMethodCall";
}

//______________________________________________________________________________
const char *TMethodCall::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethodCall*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMethodCall::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethodCall*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMethodCall::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethodCall*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMethodCall::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethodCall*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TPluginHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TPluginHandler::Class_Name()
{
   return "TPluginHandler";
}

//______________________________________________________________________________
const char *TPluginHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPluginHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TPluginHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPluginHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TPluginHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPluginHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TPluginHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPluginHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TPluginManager::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TPluginManager::Class_Name()
{
   return "TPluginManager";
}

//______________________________________________________________________________
const char *TPluginManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPluginManager*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TPluginManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPluginManager*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TPluginManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPluginManager*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TPluginManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPluginManager*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArray::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArray::Class_Name()
{
   return "TArray";
}

//______________________________________________________________________________
const char *TArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArray*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArray*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArray*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArray*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayI::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayI::Class_Name()
{
   return "TArrayI";
}

//______________________________________________________________________________
const char *TArrayI::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayI*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayI::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayI*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayI::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayI*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayI::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayI*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TPRegexp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TPRegexp::Class_Name()
{
   return "TPRegexp";
}

//______________________________________________________________________________
const char *TPRegexp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPRegexp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TPRegexp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPRegexp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TPRegexp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPRegexp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TPRegexp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPRegexp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TPMERegexp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TPMERegexp::Class_Name()
{
   return "TPMERegexp";
}

//______________________________________________________________________________
const char *TPMERegexp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPMERegexp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TPMERegexp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPMERegexp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TPMERegexp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPMERegexp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TPMERegexp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPMERegexp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStringToken::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStringToken::Class_Name()
{
   return "TStringToken";
}

//______________________________________________________________________________
const char *TStringToken::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStringToken*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStringToken::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStringToken*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStringToken::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStringToken*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStringToken::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStringToken*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TProcessID::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TProcessID::Class_Name()
{
   return "TProcessID";
}

//______________________________________________________________________________
const char *TProcessID::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessID*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TProcessID::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessID*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TProcessID::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessID*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TProcessID::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessID*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TProcessUUID::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TProcessUUID::Class_Name()
{
   return "TProcessUUID";
}

//______________________________________________________________________________
const char *TProcessUUID::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessUUID*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TProcessUUID::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessUUID*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TProcessUUID::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessUUID*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TProcessUUID::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessUUID*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQClass::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQClass::Class_Name()
{
   return "TQClass";
}

//______________________________________________________________________________
const char *TQClass::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQClass*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQClass::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQClass*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQClass::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQClass*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQClass::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQClass*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQCommand::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQCommand::Class_Name()
{
   return "TQCommand";
}

//______________________________________________________________________________
const char *TQCommand::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQCommand*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQCommand::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQCommand*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQCommand::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQCommand*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQCommand::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQCommand*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQUndoManager::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQUndoManager::Class_Name()
{
   return "TQUndoManager";
}

//______________________________________________________________________________
const char *TQUndoManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQUndoManager*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQUndoManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQUndoManager*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQUndoManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQUndoManager*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQUndoManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQUndoManager*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TQConnection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TQConnection::Class_Name()
{
   return "TQConnection";
}

//______________________________________________________________________________
const char *TQConnection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQConnection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TQConnection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TQConnection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TQConnection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQConnection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TQConnection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TQConnection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSysEvtHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSysEvtHandler::Class_Name()
{
   return "TSysEvtHandler";
}

//______________________________________________________________________________
const char *TSysEvtHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSysEvtHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSysEvtHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSysEvtHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSysEvtHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSysEvtHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSysEvtHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSysEvtHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFileHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFileHandler::Class_Name()
{
   return "TFileHandler";
}

//______________________________________________________________________________
const char *TFileHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFileHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFileHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSignalHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSignalHandler::Class_Name()
{
   return "TSignalHandler";
}

//______________________________________________________________________________
const char *TSignalHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSignalHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSignalHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSignalHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSignalHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSignalHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSignalHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSignalHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStdExceptionHandler::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStdExceptionHandler::Class_Name()
{
   return "TStdExceptionHandler";
}

//______________________________________________________________________________
const char *TStdExceptionHandler::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStdExceptionHandler*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStdExceptionHandler::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStdExceptionHandler*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStdExceptionHandler::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStdExceptionHandler*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStdExceptionHandler::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStdExceptionHandler*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TTime::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TTime::Class_Name()
{
   return "TTime";
}

//______________________________________________________________________________
const char *TTime::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTime*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TTime::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTime*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TTime::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTime*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TTime::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTime*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TTimer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TTimer::Class_Name()
{
   return "TTimer";
}

//______________________________________________________________________________
const char *TTimer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TTimer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TTimer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TTimer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr SysInfo_t::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *SysInfo_t::Class_Name()
{
   return "SysInfo_t";
}

//______________________________________________________________________________
const char *SysInfo_t::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::SysInfo_t*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int SysInfo_t::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::SysInfo_t*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *SysInfo_t::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::SysInfo_t*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *SysInfo_t::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::SysInfo_t*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr CpuInfo_t::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *CpuInfo_t::Class_Name()
{
   return "CpuInfo_t";
}

//______________________________________________________________________________
const char *CpuInfo_t::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::CpuInfo_t*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int CpuInfo_t::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::CpuInfo_t*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *CpuInfo_t::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::CpuInfo_t*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *CpuInfo_t::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::CpuInfo_t*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr MemInfo_t::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *MemInfo_t::Class_Name()
{
   return "MemInfo_t";
}

//______________________________________________________________________________
const char *MemInfo_t::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::MemInfo_t*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int MemInfo_t::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::MemInfo_t*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *MemInfo_t::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::MemInfo_t*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *MemInfo_t::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::MemInfo_t*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr ProcInfo_t::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *ProcInfo_t::Class_Name()
{
   return "ProcInfo_t";
}

//______________________________________________________________________________
const char *ProcInfo_t::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ProcInfo_t*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int ProcInfo_t::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ProcInfo_t*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *ProcInfo_t::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ProcInfo_t*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *ProcInfo_t::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ProcInfo_t*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TProcessEventTimer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TProcessEventTimer::Class_Name()
{
   return "TProcessEventTimer";
}

//______________________________________________________________________________
const char *TProcessEventTimer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessEventTimer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TProcessEventTimer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProcessEventTimer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TProcessEventTimer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessEventTimer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TProcessEventTimer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProcessEventTimer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSystem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSystem::Class_Name()
{
   return "TSystem";
}

//______________________________________________________________________________
const char *TSystem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSystem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSystem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSystem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRedirectOutputGuard::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRedirectOutputGuard::Class_Name()
{
   return "TRedirectOutputGuard";
}

//______________________________________________________________________________
const char *TRedirectOutputGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRedirectOutputGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRedirectOutputGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRedirectOutputGuard::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRef::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRef::Class_Name()
{
   return "TRef";
}

//______________________________________________________________________________
const char *TRef::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRef*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRef::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRef*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRef::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRef*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRef::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRef*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRegexp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRegexp::Class_Name()
{
   return "TRegexp";
}

//______________________________________________________________________________
const char *TRegexp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRegexp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRegexp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRegexp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRegexp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRegexp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRegexp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRegexp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRemoteObject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRemoteObject::Class_Name()
{
   return "TRemoteObject";
}

//______________________________________________________________________________
const char *TRemoteObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRemoteObject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRemoteObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRemoteObject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRemoteObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRemoteObject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRemoteObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRemoteObject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStringLong::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStringLong::Class_Name()
{
   return "TStringLong";
}

//______________________________________________________________________________
const char *TStringLong::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStringLong*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStringLong::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStringLong*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStringLong::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStringLong*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStringLong::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStringLong*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStyle::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStyle::Class_Name()
{
   return "TStyle";
}

//______________________________________________________________________________
const char *TStyle::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStyle*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStyle::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStyle*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStyle::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStyle*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStyle::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStyle*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSystemFile::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSystemFile::Class_Name()
{
   return "TSystemFile";
}

//______________________________________________________________________________
const char *TSystemFile::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystemFile*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSystemFile::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystemFile*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSystemFile::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystemFile*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSystemFile::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystemFile*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSystemDirectory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSystemDirectory::Class_Name()
{
   return "TSystemDirectory";
}

//______________________________________________________________________________
const char *TSystemDirectory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystemDirectory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSystemDirectory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSystemDirectory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSystemDirectory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystemDirectory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSystemDirectory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSystemDirectory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TTask::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TTask::Class_Name()
{
   return "TTask";
}

//______________________________________________________________________________
const char *TTask::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTask*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TTask::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTask*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TTask::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTask*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TTask::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTask*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TTimeStamp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TTimeStamp::Class_Name()
{
   return "TTimeStamp";
}

//______________________________________________________________________________
const char *TTimeStamp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TTimeStamp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TTimeStamp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TTimeStamp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TUri::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TUri::Class_Name()
{
   return "TUri";
}

//______________________________________________________________________________
const char *TUri::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUri*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TUri::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUri*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TUri::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUri*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUri::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUri*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualAuth::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualAuth::Class_Name()
{
   return "TVirtualAuth";
}

//______________________________________________________________________________
const char *TVirtualAuth::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualAuth::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualAuth::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualAuth::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualFFT::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualFFT::Class_Name()
{
   return "TVirtualFFT";
}

//______________________________________________________________________________
const char *TVirtualFFT::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFFT*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualFFT::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFFT*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualFFT::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFFT*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualFFT::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFFT*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualGLPainter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualGLPainter::Class_Name()
{
   return "TVirtualGLPainter";
}

//______________________________________________________________________________
const char *TVirtualGLPainter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLPainter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualGLPainter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLPainter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualGLPainter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLPainter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualGLPainter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLPainter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualGLManip::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualGLManip::Class_Name()
{
   return "TVirtualGLManip";
}

//______________________________________________________________________________
const char *TVirtualGLManip::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLManip*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualGLManip::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLManip*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualGLManip::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLManip*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualGLManip::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualGLManip*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TGLManager::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TGLManager::Class_Name()
{
   return "TGLManager";
}

//______________________________________________________________________________
const char *TGLManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGLManager*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TGLManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGLManager*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TGLManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGLManager*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TGLManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGLManager*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TGLPaintDevice::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TGLPaintDevice::Class_Name()
{
   return "TGLPaintDevice";
}

//______________________________________________________________________________
const char *TGLPaintDevice::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGLPaintDevice*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TGLPaintDevice::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGLPaintDevice*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TGLPaintDevice::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGLPaintDevice*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TGLPaintDevice::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGLPaintDevice*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr THashTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *THashTable::Class_Name()
{
   return "THashTable";
}

//______________________________________________________________________________
const char *THashTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int THashTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *THashTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *THashTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr THashTableIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *THashTableIter::Class_Name()
{
   return "THashTableIter";
}

//______________________________________________________________________________
const char *THashTableIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashTableIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int THashTableIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashTableIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *THashTableIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashTableIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *THashTableIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashTableIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMap::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMap::Class_Name()
{
   return "TMap";
}

//______________________________________________________________________________
const char *TMap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMap*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMap*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMap*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMap*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TPair::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TPair::Class_Name()
{
   return "TPair";
}

//______________________________________________________________________________
const char *TPair::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPair*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TPair::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TPair*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TPair::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPair*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TPair::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TPair*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMapIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMapIter::Class_Name()
{
   return "TMapIter";
}

//______________________________________________________________________________
const char *TMapIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMapIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMapIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMapIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMapIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMapIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMapIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMapIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualMonitoringWriter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMonitoringWriter::Class_Name()
{
   return "TVirtualMonitoringWriter";
}

//______________________________________________________________________________
const char *TVirtualMonitoringWriter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMonitoringWriter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualMonitoringWriter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualMonitoringWriter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualMonitoringReader::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMonitoringReader::Class_Name()
{
   return "TVirtualMonitoringReader";
}

//______________________________________________________________________________
const char *TVirtualMonitoringReader::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMonitoringReader::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualMonitoringReader::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualMonitoringReader::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualPadEditor::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPadEditor::Class_Name()
{
   return "TVirtualPadEditor";
}

//______________________________________________________________________________
const char *TVirtualPadEditor::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadEditor*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPadEditor::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadEditor*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualPadEditor::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadEditor*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPadEditor::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadEditor*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualPad::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPad::Class_Name()
{
   return "TVirtualPad";
}

//______________________________________________________________________________
const char *TVirtualPad::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPad*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPad::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPad*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualPad::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPad*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPad::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPad*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualPadPainter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPadPainter::Class_Name()
{
   return "TVirtualPadPainter";
}

//______________________________________________________________________________
const char *TVirtualPadPainter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadPainter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPadPainter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadPainter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualPadPainter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadPainter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPadPainter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPadPainter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualPerfStats::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPerfStats::Class_Name()
{
   return "TVirtualPerfStats";
}

//______________________________________________________________________________
const char *TVirtualPerfStats::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPerfStats::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualPerfStats::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPerfStats::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualPS::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPS::Class_Name()
{
   return "TVirtualPS";
}

//______________________________________________________________________________
const char *TVirtualPS::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPS*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPS::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPS*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualPS::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPS*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPS::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPS*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualTableInterface::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualTableInterface::Class_Name()
{
   return "TVirtualTableInterface";
}

//______________________________________________________________________________
const char *TVirtualTableInterface::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualTableInterface::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualTableInterface::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualTableInterface::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualViewer3D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualViewer3D::Class_Name()
{
   return "TVirtualViewer3D";
}

//______________________________________________________________________________
const char *TVirtualViewer3D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualViewer3D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualViewer3D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualViewer3D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualViewer3D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualViewer3D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualViewer3D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualViewer3D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualX::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualX::Class_Name()
{
   return "TVirtualX";
}

//______________________________________________________________________________
const char *TVirtualX::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualX*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualX::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualX*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualX::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualX*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualX::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualX*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayC::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayC::Class_Name()
{
   return "TArrayC";
}

//______________________________________________________________________________
const char *TArrayC::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayC*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayC::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayC*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayC::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayC*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayC::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayC*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayD::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayD::Class_Name()
{
   return "TArrayD";
}

//______________________________________________________________________________
const char *TArrayD::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayD*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayD::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayD*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayD::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayD*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayD::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayD*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayF::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayF::Class_Name()
{
   return "TArrayF";
}

//______________________________________________________________________________
const char *TArrayF::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayF*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayF::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayF*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayF::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayF*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayF::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayF*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayL64::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayL64::Class_Name()
{
   return "TArrayL64";
}

//______________________________________________________________________________
const char *TArrayL64::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayL64*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayL64::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayL64*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayL64::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayL64*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayL64::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayL64*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayL::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayL::Class_Name()
{
   return "TArrayL";
}

//______________________________________________________________________________
const char *TArrayL::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayL*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayL::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayL*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayL::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayL*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayL::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayL*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TArrayS::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TArrayS::Class_Name()
{
   return "TArrayS";
}

//______________________________________________________________________________
const char *TArrayS::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayS*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TArrayS::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TArrayS*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TArrayS::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayS*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TArrayS::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TArrayS*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBits::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBits::Class_Name()
{
   return "TBits";
}

//______________________________________________________________________________
const char *TBits::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBits*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBits::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBits*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBits::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBits*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBits::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBits*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBtree::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBtree::Class_Name()
{
   return "TBtree";
}

//______________________________________________________________________________
const char *TBtree::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBtree*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBtree::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBtree*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBtree::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBtree*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBtree::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBtree*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBtreeIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBtreeIter::Class_Name()
{
   return "TBtreeIter";
}

//______________________________________________________________________________
const char *TBtreeIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBtreeIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBtreeIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBtreeIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBtreeIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBtreeIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBtreeIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBtreeIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TClassTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TClassTable::Class_Name()
{
   return "TClassTable";
}

//______________________________________________________________________________
const char *TClassTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TClassTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TClassTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TClassTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TClonesArray::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TClonesArray::Class_Name()
{
   return "TClonesArray";
}

//______________________________________________________________________________
const char *TClonesArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClonesArray*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TClonesArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClonesArray*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TClonesArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClonesArray*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TClonesArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClonesArray*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TExMap::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TExMap::Class_Name()
{
   return "TExMap";
}

//______________________________________________________________________________
const char *TExMap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExMap*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TExMap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExMap*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TExMap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExMap*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TExMap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExMap*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TExMapIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TExMapIter::Class_Name()
{
   return "TExMapIter";
}

//______________________________________________________________________________
const char *TExMapIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExMapIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TExMapIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TExMapIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TExMapIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExMapIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TExMapIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TExMapIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr THashList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *THashList::Class_Name()
{
   return "THashList";
}

//______________________________________________________________________________
const char *THashList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int THashList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::THashList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *THashList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *THashList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::THashList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjectTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjectTable::Class_Name()
{
   return "TObjectTable";
}

//______________________________________________________________________________
const char *TObjectTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjectTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjectTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjectTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TOrdCollection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TOrdCollection::Class_Name()
{
   return "TOrdCollection";
}

//______________________________________________________________________________
const char *TOrdCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TOrdCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TOrdCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TOrdCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TOrdCollectionIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TOrdCollectionIter::Class_Name()
{
   return "TOrdCollectionIter";
}

//______________________________________________________________________________
const char *TOrdCollectionIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollectionIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TOrdCollectionIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollectionIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TOrdCollectionIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollectionIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TOrdCollectionIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOrdCollectionIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRefArray::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRefArray::Class_Name()
{
   return "TRefArray";
}

//______________________________________________________________________________
const char *TRefArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefArray*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRefArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefArray*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRefArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefArray*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRefArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefArray*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRefArrayIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRefArrayIter::Class_Name()
{
   return "TRefArrayIter";
}

//______________________________________________________________________________
const char *TRefArrayIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefArrayIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRefArrayIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefArrayIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRefArrayIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefArrayIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRefArrayIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefArrayIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRefTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRefTable::Class_Name()
{
   return "TRefTable";
}

//______________________________________________________________________________
const char *TRefTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRefTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRefTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRefTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRefTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRefTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TSortedList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSortedList::Class_Name()
{
   return "TSortedList";
}

//______________________________________________________________________________
const char *TSortedList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSortedList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSortedList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TSortedList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSortedList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSortedList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSortedList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TSortedList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TUnixSystem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TUnixSystem::Class_Name()
{
   return "TUnixSystem";
}

//______________________________________________________________________________
const char *TUnixSystem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUnixSystem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TUnixSystem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUnixSystem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TUnixSystem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUnixSystem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUnixSystem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUnixSystem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBrowserImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBrowserImp::Class_Name()
{
   return "TBrowserImp";
}

//______________________________________________________________________________
const char *TBrowserImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBrowserImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBrowserImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBrowserImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBrowserImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBrowserImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBrowserImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBrowserImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBrowser::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBrowser::Class_Name()
{
   return "TBrowser";
}

//______________________________________________________________________________
const char *TBrowser::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBrowser*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBrowser::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBrowser*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBrowser::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBrowser*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBrowser::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBrowser*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TCanvasImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TCanvasImp::Class_Name()
{
   return "TCanvasImp";
}

//______________________________________________________________________________
const char *TCanvasImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TCanvasImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TCanvasImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TCanvasImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TCanvasImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TCanvasImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TCanvasImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TCanvasImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TClassMenuItem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TClassMenuItem::Class_Name()
{
   return "TClassMenuItem";
}

//______________________________________________________________________________
const char *TClassMenuItem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassMenuItem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TClassMenuItem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassMenuItem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TClassMenuItem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassMenuItem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TClassMenuItem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassMenuItem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TContextMenuImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TContextMenuImp::Class_Name()
{
   return "TContextMenuImp";
}

//______________________________________________________________________________
const char *TContextMenuImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TContextMenuImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TContextMenuImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TContextMenuImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TContextMenuImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TContextMenuImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TContextMenuImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TContextMenuImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TContextMenu::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TContextMenu::Class_Name()
{
   return "TContextMenu";
}

//______________________________________________________________________________
const char *TContextMenu::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TContextMenu*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TContextMenu::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TContextMenu*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TContextMenu::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TContextMenu*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TContextMenu::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TContextMenu*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TControlBarImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TControlBarImp::Class_Name()
{
   return "TControlBarImp";
}

//______________________________________________________________________________
const char *TControlBarImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TControlBarImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TControlBarImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TControlBarImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TControlBarImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TControlBarImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TControlBarImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TControlBarImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TGuiFactory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TGuiFactory::Class_Name()
{
   return "TGuiFactory";
}

//______________________________________________________________________________
const char *TGuiFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGuiFactory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TGuiFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGuiFactory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TGuiFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGuiFactory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TGuiFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGuiFactory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TInspectorImp::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TInspectorImp::Class_Name()
{
   return "TInspectorImp";
}

//______________________________________________________________________________
const char *TInspectorImp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInspectorImp*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TInspectorImp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInspectorImp*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TInspectorImp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInspectorImp*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TInspectorImp::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInspectorImp*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjectSpy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjectSpy::Class_Name()
{
   return "TObjectSpy";
}

//______________________________________________________________________________
const char *TObjectSpy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjectSpy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjectSpy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjectSpy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TObjectRefSpy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TObjectRefSpy::Class_Name()
{
   return "TObjectRefSpy";
}

//______________________________________________________________________________
const char *TObjectRefSpy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TObjectRefSpy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TObjectRefSpy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjectRefSpy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFunction::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFunction::Class_Name()
{
   return "TFunction";
}

//______________________________________________________________________________
const char *TFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFunction*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFunction*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFunction*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFunction*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMethod::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMethod::Class_Name()
{
   return "TMethod";
}

//______________________________________________________________________________
const char *TMethod::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethod*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMethod::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethod*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMethod::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethod*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMethod::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethod*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TToggle::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TToggle::Class_Name()
{
   return "TToggle";
}

//______________________________________________________________________________
const char *TToggle::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TToggle*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TToggle::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TToggle*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TToggle::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TToggle*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TToggle::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TToggle*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TToggleGroup::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TToggleGroup::Class_Name()
{
   return "TToggleGroup";
}

//______________________________________________________________________________
const char *TToggleGroup::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TToggleGroup*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TToggleGroup::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TToggleGroup*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TToggleGroup::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TToggleGroup*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TToggleGroup::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TToggleGroup*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TBaseClass::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TBaseClass::Class_Name()
{
   return "TBaseClass";
}

//______________________________________________________________________________
const char *TBaseClass::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBaseClass*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TBaseClass::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBaseClass*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TBaseClass::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBaseClass*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBaseClass::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBaseClass*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TClassGenerator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TClassGenerator::Class_Name()
{
   return "TClassGenerator";
}

//______________________________________________________________________________
const char *TClassGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassGenerator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TClassGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TClassGenerator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TClassGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassGenerator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TClassGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TClassGenerator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDataMember::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDataMember::Class_Name()
{
   return "TDataMember";
}

//______________________________________________________________________________
const char *TDataMember::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDataMember*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDataMember::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDataMember*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDataMember::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDataMember*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDataMember::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDataMember*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TOptionListItem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TOptionListItem::Class_Name()
{
   return "TOptionListItem";
}

//______________________________________________________________________________
const char *TOptionListItem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOptionListItem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TOptionListItem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TOptionListItem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TOptionListItem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOptionListItem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TOptionListItem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TOptionListItem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TDictAttributeMap::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TDictAttributeMap::Class_Name()
{
   return "TDictAttributeMap";
}

//______________________________________________________________________________
const char *TDictAttributeMap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDictAttributeMap*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TDictAttributeMap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TDictAttributeMap*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TDictAttributeMap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDictAttributeMap*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TDictAttributeMap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TDictAttributeMap*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TGlobal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TGlobal::Class_Name()
{
   return "TGlobal";
}

//______________________________________________________________________________
const char *TGlobal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGlobal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TGlobal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TGlobal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TGlobal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGlobal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TGlobal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TGlobal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TEnum::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TEnum::Class_Name()
{
   return "TEnum";
}

//______________________________________________________________________________
const char *TEnum::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnum*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TEnum::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnum*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TEnum::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnum*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TEnum::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnum*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TEnumConstant::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TEnumConstant::Class_Name()
{
   return "TEnumConstant";
}

//______________________________________________________________________________
const char *TEnumConstant::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnumConstant*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TEnumConstant::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TEnumConstant*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TEnumConstant::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnumConstant*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TEnumConstant::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TEnumConstant*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFileMergeInfo::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFileMergeInfo::Class_Name()
{
   return "TFileMergeInfo";
}

//______________________________________________________________________________
const char *TFileMergeInfo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileMergeInfo*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFileMergeInfo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileMergeInfo*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFileMergeInfo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileMergeInfo*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileMergeInfo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileMergeInfo*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TFunctionTemplate::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TFunctionTemplate::Class_Name()
{
   return "TFunctionTemplate";
}

//______________________________________________________________________________
const char *TFunctionTemplate::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFunctionTemplate*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TFunctionTemplate::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFunctionTemplate*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TFunctionTemplate::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFunctionTemplate*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFunctionTemplate::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFunctionTemplate*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfDataMembers::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfDataMembers::Class_Name()
{
   return "TListOfDataMembers";
}

//______________________________________________________________________________
const char *TListOfDataMembers::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfDataMembers*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfDataMembers::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfDataMembers*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfDataMembers::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfDataMembers*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfDataMembers::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfDataMembers*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfEnums::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfEnums::Class_Name()
{
   return "TListOfEnums";
}

//______________________________________________________________________________
const char *TListOfEnums::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnums*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfEnums::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnums*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfEnums::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnums*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfEnums::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnums*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfEnumsWithLock::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfEnumsWithLock::Class_Name()
{
   return "TListOfEnumsWithLock";
}

//______________________________________________________________________________
const char *TListOfEnumsWithLock::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLock*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfEnumsWithLock::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLock*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfEnumsWithLock::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLock*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfEnumsWithLock::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLock*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfEnumsWithLockIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfEnumsWithLockIter::Class_Name()
{
   return "TListOfEnumsWithLockIter";
}

//______________________________________________________________________________
const char *TListOfEnumsWithLockIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLockIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfEnumsWithLockIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLockIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfEnumsWithLockIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLockIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfEnumsWithLockIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfEnumsWithLockIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfFunctions::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfFunctions::Class_Name()
{
   return "TListOfFunctions";
}

//______________________________________________________________________________
const char *TListOfFunctions::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctions*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfFunctions::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctions*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfFunctions::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctions*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfFunctions::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctions*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfFunctionsIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfFunctionsIter::Class_Name()
{
   return "TListOfFunctionsIter";
}

//______________________________________________________________________________
const char *TListOfFunctionsIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionsIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfFunctionsIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionsIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfFunctionsIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionsIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfFunctionsIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionsIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TListOfFunctionTemplates::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TListOfFunctionTemplates::Class_Name()
{
   return "TListOfFunctionTemplates";
}

//______________________________________________________________________________
const char *TListOfFunctionTemplates::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionTemplates*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TListOfFunctionTemplates::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionTemplates*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TListOfFunctionTemplates::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionTemplates*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TListOfFunctionTemplates::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TListOfFunctionTemplates*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TMethodArg::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TMethodArg::Class_Name()
{
   return "TMethodArg";
}

//______________________________________________________________________________
const char *TMethodArg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethodArg*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TMethodArg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TMethodArg*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TMethodArg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethodArg*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TMethodArg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TMethodArg*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TProtoClass::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TProtoClass::Class_Name()
{
   return "TProtoClass";
}

//______________________________________________________________________________
const char *TProtoClass::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TProtoClass::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TProtoClass::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TProtoClass::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TProtoClass::TProtoRealData::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TProtoClass::TProtoRealData::Class_Name()
{
   return "TProtoClass::TProtoRealData";
}

//______________________________________________________________________________
const char *TProtoClass::TProtoRealData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass::TProtoRealData*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TProtoClass::TProtoRealData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass::TProtoRealData*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TProtoClass::TProtoRealData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass::TProtoRealData*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TProtoClass::TProtoRealData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TProtoClass::TProtoRealData*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TRealData::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TRealData::Class_Name()
{
   return "TRealData";
}

//______________________________________________________________________________
const char *TRealData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRealData*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TRealData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRealData*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TRealData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRealData*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRealData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRealData*)nullptr)->GetClass(); }
   return fgIsA;
}

namespace ROOT {
//______________________________________________________________________________
atomic_TClass_ptr TSchemaRule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSchemaRule::Class_Name()
{
   return "ROOT::TSchemaRule";
}

//______________________________________________________________________________
const char *TSchemaRule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSchemaRule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSchemaRule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSchemaRule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT
namespace ROOT {
//______________________________________________________________________________
atomic_TClass_ptr TSchemaRule::TSources::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSchemaRule::TSources::Class_Name()
{
   return "ROOT::TSchemaRule::TSources";
}

//______________________________________________________________________________
const char *TSchemaRule::TSources::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule::TSources*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSchemaRule::TSources::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule::TSources*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSchemaRule::TSources::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule::TSources*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSchemaRule::TSources::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::TSchemaRule::TSources*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT
namespace ROOT {
   namespace Detail {
//______________________________________________________________________________
atomic_TClass_ptr TSchemaRuleSet::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TSchemaRuleSet::Class_Name()
{
   return "ROOT::Detail::TSchemaRuleSet";
}

//______________________________________________________________________________
const char *TSchemaRuleSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Detail::TSchemaRuleSet*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TSchemaRuleSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Detail::TSchemaRuleSet*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TSchemaRuleSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Detail::TSchemaRuleSet*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TSchemaRuleSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Detail::TSchemaRuleSet*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace ROOT::Detail
} // namespace ROOT::Detail
//______________________________________________________________________________
atomic_TClass_ptr TStreamerElement::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerElement::Class_Name()
{
   return "TStreamerElement";
}

//______________________________________________________________________________
const char *TStreamerElement::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerElement*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerElement::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerElement*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerElement::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerElement*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerElement::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerElement*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerBase::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerBase::Class_Name()
{
   return "TStreamerBase";
}

//______________________________________________________________________________
const char *TStreamerBase::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBase*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerBase::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBase*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerBase::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBase*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerBase::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBase*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerBasicPointer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerBasicPointer::Class_Name()
{
   return "TStreamerBasicPointer";
}

//______________________________________________________________________________
const char *TStreamerBasicPointer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicPointer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerBasicPointer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicPointer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerBasicPointer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicPointer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerBasicPointer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicPointer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerLoop::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerLoop::Class_Name()
{
   return "TStreamerLoop";
}

//______________________________________________________________________________
const char *TStreamerLoop::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerLoop*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerLoop::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerLoop*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerLoop::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerLoop*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerLoop::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerLoop*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerBasicType::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerBasicType::Class_Name()
{
   return "TStreamerBasicType";
}

//______________________________________________________________________________
const char *TStreamerBasicType::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicType*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerBasicType::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicType*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerBasicType::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicType*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerBasicType::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerBasicType*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerObject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerObject::Class_Name()
{
   return "TStreamerObject";
}

//______________________________________________________________________________
const char *TStreamerObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerObjectAny::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerObjectAny::Class_Name()
{
   return "TStreamerObjectAny";
}

//______________________________________________________________________________
const char *TStreamerObjectAny::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAny*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerObjectAny::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAny*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerObjectAny::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAny*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerObjectAny::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAny*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerObjectPointer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerObjectPointer::Class_Name()
{
   return "TStreamerObjectPointer";
}

//______________________________________________________________________________
const char *TStreamerObjectPointer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectPointer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerObjectPointer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectPointer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerObjectPointer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectPointer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerObjectPointer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectPointer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerObjectAnyPointer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerObjectAnyPointer::Class_Name()
{
   return "TStreamerObjectAnyPointer";
}

//______________________________________________________________________________
const char *TStreamerObjectAnyPointer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAnyPointer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerObjectAnyPointer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAnyPointer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerObjectAnyPointer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAnyPointer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerObjectAnyPointer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerObjectAnyPointer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerString::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerString::Class_Name()
{
   return "TStreamerString";
}

//______________________________________________________________________________
const char *TStreamerString::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerString*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerString::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerString*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerString::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerString*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerString::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerString*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerSTL::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerSTL::Class_Name()
{
   return "TStreamerSTL";
}

//______________________________________________________________________________
const char *TStreamerSTL::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTL*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerSTL::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTL*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerSTL::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTL*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerSTL::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTL*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerSTLstring::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerSTLstring::Class_Name()
{
   return "TStreamerSTLstring";
}

//______________________________________________________________________________
const char *TStreamerSTLstring::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTLstring*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerSTLstring::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTLstring*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerSTLstring::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTLstring*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerSTLstring::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerSTLstring*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TStreamerArtificial::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TStreamerArtificial::Class_Name()
{
   return "TStreamerArtificial";
}

//______________________________________________________________________________
const char *TStreamerArtificial::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerArtificial*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TStreamerArtificial::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TStreamerArtificial*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TStreamerArtificial::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerArtificial*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TStreamerArtificial::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TStreamerArtificial*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr TVirtualStreamerInfo::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualStreamerInfo::Class_Name()
{
   return "TVirtualStreamerInfo";
}

//______________________________________________________________________________
const char *TVirtualStreamerInfo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualStreamerInfo*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualStreamerInfo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualStreamerInfo*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *TVirtualStreamerInfo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualStreamerInfo*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualStreamerInfo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualStreamerInfo*)nullptr)->GetClass(); }
   return fgIsA;
}

namespace ROOT {
   static TClass *string_Dictionary();
   static void string_TClassManip(TClass*);
   static void *new_string(void *p = nullptr);
   static void *newArray_string(Long_t size, void *p);
   static void delete_string(void *p);
   static void deleteArray_string(void *p);
   static void destruct_string(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const string*)
   {
      string *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(string));
      static ::ROOT::TGenericClassInfo 
         instance("string", "string", 1608,
                  typeid(string), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &string_Dictionary, isa_proxy, 0,
                  sizeof(string) );
      instance.SetNew(&new_string);
      instance.SetNewArray(&newArray_string);
      instance.SetDelete(&delete_string);
      instance.SetDeleteArray(&deleteArray_string);
      instance.SetDestructor(&destruct_string);

      ::ROOT::AddClassAlternate("string","std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const string*)
   {
      return GenerateInitInstanceLocal((string*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const string*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *string_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const string*)nullptr)->GetClass();
      string_TClassManip(theClass);
   return theClass;
   }

   static void string_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_timespec(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::timespec : new ::timespec;
   }
   static void *newArray_timespec(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::timespec[nElements] : new ::timespec[nElements];
   }
   // Wrapper around operator delete
   static void delete_timespec(void *p) {
      delete ((::timespec*)p);
   }
   static void deleteArray_timespec(void *p) {
      delete [] ((::timespec*)p);
   }
   static void destruct_timespec(void *p) {
      typedef ::timespec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::timespec

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,long> : new pair<const long,long>;
   }
   static void *newArray_pairlEconstsPlongcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,long>[nElements] : new pair<const long,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOlonggR(void *p) {
      delete ((pair<const long,long>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOlonggR(void *p) {
      delete [] ((pair<const long,long>*)p);
   }
   static void destruct_pairlEconstsPlongcOlonggR(void *p) {
      typedef pair<const long,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,int> : new pair<string,int>;
   }
   static void *newArray_pairlEstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,int>[nElements] : new pair<string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOintgR(void *p) {
      delete ((pair<string,int>*)p);
   }
   static void deleteArray_pairlEstringcOintgR(void *p) {
      delete [] ((pair<string,int>*)p);
   }
   static void destruct_pairlEstringcOintgR(void *p) {
      typedef pair<string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,int> : new pair<int,int>;
   }
   static void *newArray_pairlEintcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,int>[nElements] : new pair<int,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOintgR(void *p) {
      delete ((pair<int,int>*)p);
   }
   static void deleteArray_pairlEintcOintgR(void *p) {
      delete [] ((pair<int,int>*)p);
   }
   static void destruct_pairlEintcOintgR(void *p) {
      typedef pair<int,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,char*> : new pair<const double,char*>;
   }
   static void *newArray_pairlEconstsPdoublecOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,char*>[nElements] : new pair<const double,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOcharmUgR(void *p) {
      delete ((pair<const double,char*>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOcharmUgR(void *p) {
      delete [] ((pair<const double,char*>*)p);
   }
   static void destruct_pairlEconstsPdoublecOcharmUgR(void *p) {
      typedef pair<const double,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,void*> : new pair<const double,void*>;
   }
   static void *newArray_pairlEconstsPdoublecOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,void*>[nElements] : new pair<const double,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOvoidmUgR(void *p) {
      delete ((pair<const double,void*>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOvoidmUgR(void *p) {
      delete [] ((pair<const double,void*>*)p);
   }
   static void destruct_pairlEconstsPdoublecOvoidmUgR(void *p) {
      typedef pair<const double,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,double> : new pair<const double,double>;
   }
   static void *newArray_pairlEconstsPdoublecOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,double>[nElements] : new pair<const double,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOdoublegR(void *p) {
      delete ((pair<const double,double>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOdoublegR(void *p) {
      delete [] ((pair<const double,double>*)p);
   }
   static void destruct_pairlEconstsPdoublecOdoublegR(void *p) {
      typedef pair<const double,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,float> : new pair<const double,float>;
   }
   static void *newArray_pairlEconstsPdoublecOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,float>[nElements] : new pair<const double,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOfloatgR(void *p) {
      delete ((pair<const double,float>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOfloatgR(void *p) {
      delete [] ((pair<const double,float>*)p);
   }
   static void destruct_pairlEconstsPdoublecOfloatgR(void *p) {
      typedef pair<const double,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,long> : new pair<const double,long>;
   }
   static void *newArray_pairlEconstsPdoublecOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,long>[nElements] : new pair<const double,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOlonggR(void *p) {
      delete ((pair<const double,long>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOlonggR(void *p) {
      delete [] ((pair<const double,long>*)p);
   }
   static void destruct_pairlEconstsPdoublecOlonggR(void *p) {
      typedef pair<const double,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,int> : new pair<const double,int>;
   }
   static void *newArray_pairlEconstsPdoublecOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const double,int>[nElements] : new pair<const double,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOintgR(void *p) {
      delete ((pair<const double,int>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOintgR(void *p) {
      delete [] ((pair<const double,int>*)p);
   }
   static void destruct_pairlEconstsPdoublecOintgR(void *p) {
      typedef pair<const double,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,char*> : new pair<const float,char*>;
   }
   static void *newArray_pairlEconstsPfloatcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,char*>[nElements] : new pair<const float,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOcharmUgR(void *p) {
      delete ((pair<const float,char*>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOcharmUgR(void *p) {
      delete [] ((pair<const float,char*>*)p);
   }
   static void destruct_pairlEconstsPfloatcOcharmUgR(void *p) {
      typedef pair<const float,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,void*> : new pair<const float,void*>;
   }
   static void *newArray_pairlEconstsPfloatcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,void*>[nElements] : new pair<const float,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOvoidmUgR(void *p) {
      delete ((pair<const float,void*>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOvoidmUgR(void *p) {
      delete [] ((pair<const float,void*>*)p);
   }
   static void destruct_pairlEconstsPfloatcOvoidmUgR(void *p) {
      typedef pair<const float,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,double> : new pair<const float,double>;
   }
   static void *newArray_pairlEconstsPfloatcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,double>[nElements] : new pair<const float,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOdoublegR(void *p) {
      delete ((pair<const float,double>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOdoublegR(void *p) {
      delete [] ((pair<const float,double>*)p);
   }
   static void destruct_pairlEconstsPfloatcOdoublegR(void *p) {
      typedef pair<const float,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,float> : new pair<const float,float>;
   }
   static void *newArray_pairlEconstsPfloatcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,float>[nElements] : new pair<const float,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOfloatgR(void *p) {
      delete ((pair<const float,float>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOfloatgR(void *p) {
      delete [] ((pair<const float,float>*)p);
   }
   static void destruct_pairlEconstsPfloatcOfloatgR(void *p) {
      typedef pair<const float,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,long> : new pair<const float,long>;
   }
   static void *newArray_pairlEconstsPfloatcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,long>[nElements] : new pair<const float,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOlonggR(void *p) {
      delete ((pair<const float,long>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOlonggR(void *p) {
      delete [] ((pair<const float,long>*)p);
   }
   static void destruct_pairlEconstsPfloatcOlonggR(void *p) {
      typedef pair<const float,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,int> : new pair<const float,int>;
   }
   static void *newArray_pairlEconstsPfloatcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const float,int>[nElements] : new pair<const float,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOintgR(void *p) {
      delete ((pair<const float,int>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOintgR(void *p) {
      delete [] ((pair<const float,int>*)p);
   }
   static void destruct_pairlEconstsPfloatcOintgR(void *p) {
      typedef pair<const float,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,char*> : new pair<const long,char*>;
   }
   static void *newArray_pairlEconstsPlongcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,char*>[nElements] : new pair<const long,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOcharmUgR(void *p) {
      delete ((pair<const long,char*>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOcharmUgR(void *p) {
      delete [] ((pair<const long,char*>*)p);
   }
   static void destruct_pairlEconstsPlongcOcharmUgR(void *p) {
      typedef pair<const long,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,void*> : new pair<const long,void*>;
   }
   static void *newArray_pairlEconstsPlongcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,void*>[nElements] : new pair<const long,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOvoidmUgR(void *p) {
      delete ((pair<const long,void*>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOvoidmUgR(void *p) {
      delete [] ((pair<const long,void*>*)p);
   }
   static void destruct_pairlEconstsPlongcOvoidmUgR(void *p) {
      typedef pair<const long,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,double> : new pair<const long,double>;
   }
   static void *newArray_pairlEconstsPlongcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,double>[nElements] : new pair<const long,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOdoublegR(void *p) {
      delete ((pair<const long,double>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOdoublegR(void *p) {
      delete [] ((pair<const long,double>*)p);
   }
   static void destruct_pairlEconstsPlongcOdoublegR(void *p) {
      typedef pair<const long,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,float> : new pair<const long,float>;
   }
   static void *newArray_pairlEconstsPlongcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,float>[nElements] : new pair<const long,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOfloatgR(void *p) {
      delete ((pair<const long,float>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOfloatgR(void *p) {
      delete [] ((pair<const long,float>*)p);
   }
   static void destruct_pairlEconstsPlongcOfloatgR(void *p) {
      typedef pair<const long,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,int> : new pair<const long,int>;
   }
   static void *newArray_pairlEconstsPlongcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const long,int>[nElements] : new pair<const long,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOintgR(void *p) {
      delete ((pair<const long,int>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOintgR(void *p) {
      delete [] ((pair<const long,int>*)p);
   }
   static void destruct_pairlEconstsPlongcOintgR(void *p) {
      typedef pair<const long,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,char*> : new pair<const int,char*>;
   }
   static void *newArray_pairlEconstsPintcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,char*>[nElements] : new pair<const int,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOcharmUgR(void *p) {
      delete ((pair<const int,char*>*)p);
   }
   static void deleteArray_pairlEconstsPintcOcharmUgR(void *p) {
      delete [] ((pair<const int,char*>*)p);
   }
   static void destruct_pairlEconstsPintcOcharmUgR(void *p) {
      typedef pair<const int,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,void*> : new pair<const int,void*>;
   }
   static void *newArray_pairlEconstsPintcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,void*>[nElements] : new pair<const int,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOvoidmUgR(void *p) {
      delete ((pair<const int,void*>*)p);
   }
   static void deleteArray_pairlEconstsPintcOvoidmUgR(void *p) {
      delete [] ((pair<const int,void*>*)p);
   }
   static void destruct_pairlEconstsPintcOvoidmUgR(void *p) {
      typedef pair<const int,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,double> : new pair<const int,double>;
   }
   static void *newArray_pairlEconstsPintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,double>[nElements] : new pair<const int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOdoublegR(void *p) {
      delete ((pair<const int,double>*)p);
   }
   static void deleteArray_pairlEconstsPintcOdoublegR(void *p) {
      delete [] ((pair<const int,double>*)p);
   }
   static void destruct_pairlEconstsPintcOdoublegR(void *p) {
      typedef pair<const int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,float> : new pair<const int,float>;
   }
   static void *newArray_pairlEconstsPintcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,float>[nElements] : new pair<const int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOfloatgR(void *p) {
      delete ((pair<const int,float>*)p);
   }
   static void deleteArray_pairlEconstsPintcOfloatgR(void *p) {
      delete [] ((pair<const int,float>*)p);
   }
   static void destruct_pairlEconstsPintcOfloatgR(void *p) {
      typedef pair<const int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,long> : new pair<const int,long>;
   }
   static void *newArray_pairlEconstsPintcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,long>[nElements] : new pair<const int,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOlonggR(void *p) {
      delete ((pair<const int,long>*)p);
   }
   static void deleteArray_pairlEconstsPintcOlonggR(void *p) {
      delete [] ((pair<const int,long>*)p);
   }
   static void destruct_pairlEconstsPintcOlonggR(void *p) {
      typedef pair<const int,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,int> : new pair<const int,int>;
   }
   static void *newArray_pairlEconstsPintcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const int,int>[nElements] : new pair<const int,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOintgR(void *p) {
      delete ((pair<const int,int>*)p);
   }
   static void deleteArray_pairlEconstsPintcOintgR(void *p) {
      delete [] ((pair<const int,int>*)p);
   }
   static void destruct_pairlEconstsPintcOintgR(void *p) {
      typedef pair<const int,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,void*> : new pair<const string,void*>;
   }
   static void *newArray_pairlEconstsPstringcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,void*>[nElements] : new pair<const string,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOvoidmUgR(void *p) {
      delete ((pair<const string,void*>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOvoidmUgR(void *p) {
      delete [] ((pair<const string,void*>*)p);
   }
   static void destruct_pairlEconstsPstringcOvoidmUgR(void *p) {
      typedef pair<const string,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,double> : new pair<const string,double>;
   }
   static void *newArray_pairlEconstsPstringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,double>[nElements] : new pair<const string,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOdoublegR(void *p) {
      delete ((pair<const string,double>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOdoublegR(void *p) {
      delete [] ((pair<const string,double>*)p);
   }
   static void destruct_pairlEconstsPstringcOdoublegR(void *p) {
      typedef pair<const string,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,float> : new pair<const string,float>;
   }
   static void *newArray_pairlEconstsPstringcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,float>[nElements] : new pair<const string,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOfloatgR(void *p) {
      delete ((pair<const string,float>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOfloatgR(void *p) {
      delete [] ((pair<const string,float>*)p);
   }
   static void destruct_pairlEconstsPstringcOfloatgR(void *p) {
      typedef pair<const string,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,long> : new pair<const string,long>;
   }
   static void *newArray_pairlEconstsPstringcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,long>[nElements] : new pair<const string,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOlonggR(void *p) {
      delete ((pair<const string,long>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOlonggR(void *p) {
      delete [] ((pair<const string,long>*)p);
   }
   static void destruct_pairlEconstsPstringcOlonggR(void *p) {
      typedef pair<const string,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,int> : new pair<const string,int>;
   }
   static void *newArray_pairlEconstsPstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const string,int>[nElements] : new pair<const string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOintgR(void *p) {
      delete ((pair<const string,int>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOintgR(void *p) {
      delete [] ((pair<const string,int>*)p);
   }
   static void destruct_pairlEconstsPstringcOintgR(void *p) {
      typedef pair<const string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,char*> : new pair<const char*,char*>;
   }
   static void *newArray_pairlEconstsPcharmUcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,char*>[nElements] : new pair<const char*,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOcharmUgR(void *p) {
      delete ((pair<const char*,char*>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOcharmUgR(void *p) {
      delete [] ((pair<const char*,char*>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOcharmUgR(void *p) {
      typedef pair<const char*,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,void*> : new pair<const char*,void*>;
   }
   static void *newArray_pairlEconstsPcharmUcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,void*>[nElements] : new pair<const char*,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      delete ((pair<const char*,void*>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      delete [] ((pair<const char*,void*>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      typedef pair<const char*,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,double> : new pair<const char*,double>;
   }
   static void *newArray_pairlEconstsPcharmUcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,double>[nElements] : new pair<const char*,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOdoublegR(void *p) {
      delete ((pair<const char*,double>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOdoublegR(void *p) {
      delete [] ((pair<const char*,double>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOdoublegR(void *p) {
      typedef pair<const char*,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,float> : new pair<const char*,float>;
   }
   static void *newArray_pairlEconstsPcharmUcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,float>[nElements] : new pair<const char*,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOfloatgR(void *p) {
      delete ((pair<const char*,float>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOfloatgR(void *p) {
      delete [] ((pair<const char*,float>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOfloatgR(void *p) {
      typedef pair<const char*,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,long> : new pair<const char*,long>;
   }
   static void *newArray_pairlEconstsPcharmUcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,long>[nElements] : new pair<const char*,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOlonggR(void *p) {
      delete ((pair<const char*,long>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOlonggR(void *p) {
      delete [] ((pair<const char*,long>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOlonggR(void *p) {
      typedef pair<const char*,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,int> : new pair<const char*,int>;
   }
   static void *newArray_pairlEconstsPcharmUcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<const char*,int>[nElements] : new pair<const char*,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOintgR(void *p) {
      delete ((pair<const char*,int>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOintgR(void *p) {
      delete [] ((pair<const char*,int>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOintgR(void *p) {
      typedef pair<const char*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,char*> : new pair<double,char*>;
   }
   static void *newArray_pairlEdoublecOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,char*>[nElements] : new pair<double,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOcharmUgR(void *p) {
      delete ((pair<double,char*>*)p);
   }
   static void deleteArray_pairlEdoublecOcharmUgR(void *p) {
      delete [] ((pair<double,char*>*)p);
   }
   static void destruct_pairlEdoublecOcharmUgR(void *p) {
      typedef pair<double,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,void*> : new pair<double,void*>;
   }
   static void *newArray_pairlEdoublecOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,void*>[nElements] : new pair<double,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOvoidmUgR(void *p) {
      delete ((pair<double,void*>*)p);
   }
   static void deleteArray_pairlEdoublecOvoidmUgR(void *p) {
      delete [] ((pair<double,void*>*)p);
   }
   static void destruct_pairlEdoublecOvoidmUgR(void *p) {
      typedef pair<double,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,double> : new pair<double,double>;
   }
   static void *newArray_pairlEdoublecOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,double>[nElements] : new pair<double,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOdoublegR(void *p) {
      delete ((pair<double,double>*)p);
   }
   static void deleteArray_pairlEdoublecOdoublegR(void *p) {
      delete [] ((pair<double,double>*)p);
   }
   static void destruct_pairlEdoublecOdoublegR(void *p) {
      typedef pair<double,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,float> : new pair<double,float>;
   }
   static void *newArray_pairlEdoublecOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,float>[nElements] : new pair<double,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOfloatgR(void *p) {
      delete ((pair<double,float>*)p);
   }
   static void deleteArray_pairlEdoublecOfloatgR(void *p) {
      delete [] ((pair<double,float>*)p);
   }
   static void destruct_pairlEdoublecOfloatgR(void *p) {
      typedef pair<double,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,long> : new pair<double,long>;
   }
   static void *newArray_pairlEdoublecOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,long>[nElements] : new pair<double,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOlonggR(void *p) {
      delete ((pair<double,long>*)p);
   }
   static void deleteArray_pairlEdoublecOlonggR(void *p) {
      delete [] ((pair<double,long>*)p);
   }
   static void destruct_pairlEdoublecOlonggR(void *p) {
      typedef pair<double,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,int> : new pair<double,int>;
   }
   static void *newArray_pairlEdoublecOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<double,int>[nElements] : new pair<double,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOintgR(void *p) {
      delete ((pair<double,int>*)p);
   }
   static void deleteArray_pairlEdoublecOintgR(void *p) {
      delete [] ((pair<double,int>*)p);
   }
   static void destruct_pairlEdoublecOintgR(void *p) {
      typedef pair<double,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,char*> : new pair<float,char*>;
   }
   static void *newArray_pairlEfloatcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,char*>[nElements] : new pair<float,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOcharmUgR(void *p) {
      delete ((pair<float,char*>*)p);
   }
   static void deleteArray_pairlEfloatcOcharmUgR(void *p) {
      delete [] ((pair<float,char*>*)p);
   }
   static void destruct_pairlEfloatcOcharmUgR(void *p) {
      typedef pair<float,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,void*> : new pair<float,void*>;
   }
   static void *newArray_pairlEfloatcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,void*>[nElements] : new pair<float,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOvoidmUgR(void *p) {
      delete ((pair<float,void*>*)p);
   }
   static void deleteArray_pairlEfloatcOvoidmUgR(void *p) {
      delete [] ((pair<float,void*>*)p);
   }
   static void destruct_pairlEfloatcOvoidmUgR(void *p) {
      typedef pair<float,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,double> : new pair<float,double>;
   }
   static void *newArray_pairlEfloatcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,double>[nElements] : new pair<float,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOdoublegR(void *p) {
      delete ((pair<float,double>*)p);
   }
   static void deleteArray_pairlEfloatcOdoublegR(void *p) {
      delete [] ((pair<float,double>*)p);
   }
   static void destruct_pairlEfloatcOdoublegR(void *p) {
      typedef pair<float,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,float> : new pair<float,float>;
   }
   static void *newArray_pairlEfloatcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,float>[nElements] : new pair<float,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOfloatgR(void *p) {
      delete ((pair<float,float>*)p);
   }
   static void deleteArray_pairlEfloatcOfloatgR(void *p) {
      delete [] ((pair<float,float>*)p);
   }
   static void destruct_pairlEfloatcOfloatgR(void *p) {
      typedef pair<float,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,long> : new pair<float,long>;
   }
   static void *newArray_pairlEfloatcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,long>[nElements] : new pair<float,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOlonggR(void *p) {
      delete ((pair<float,long>*)p);
   }
   static void deleteArray_pairlEfloatcOlonggR(void *p) {
      delete [] ((pair<float,long>*)p);
   }
   static void destruct_pairlEfloatcOlonggR(void *p) {
      typedef pair<float,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,int> : new pair<float,int>;
   }
   static void *newArray_pairlEfloatcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<float,int>[nElements] : new pair<float,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOintgR(void *p) {
      delete ((pair<float,int>*)p);
   }
   static void deleteArray_pairlEfloatcOintgR(void *p) {
      delete [] ((pair<float,int>*)p);
   }
   static void destruct_pairlEfloatcOintgR(void *p) {
      typedef pair<float,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,char*> : new pair<long,char*>;
   }
   static void *newArray_pairlElongcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,char*>[nElements] : new pair<long,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOcharmUgR(void *p) {
      delete ((pair<long,char*>*)p);
   }
   static void deleteArray_pairlElongcOcharmUgR(void *p) {
      delete [] ((pair<long,char*>*)p);
   }
   static void destruct_pairlElongcOcharmUgR(void *p) {
      typedef pair<long,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,void*> : new pair<long,void*>;
   }
   static void *newArray_pairlElongcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,void*>[nElements] : new pair<long,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOvoidmUgR(void *p) {
      delete ((pair<long,void*>*)p);
   }
   static void deleteArray_pairlElongcOvoidmUgR(void *p) {
      delete [] ((pair<long,void*>*)p);
   }
   static void destruct_pairlElongcOvoidmUgR(void *p) {
      typedef pair<long,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,double> : new pair<long,double>;
   }
   static void *newArray_pairlElongcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,double>[nElements] : new pair<long,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOdoublegR(void *p) {
      delete ((pair<long,double>*)p);
   }
   static void deleteArray_pairlElongcOdoublegR(void *p) {
      delete [] ((pair<long,double>*)p);
   }
   static void destruct_pairlElongcOdoublegR(void *p) {
      typedef pair<long,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,float> : new pair<long,float>;
   }
   static void *newArray_pairlElongcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,float>[nElements] : new pair<long,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOfloatgR(void *p) {
      delete ((pair<long,float>*)p);
   }
   static void deleteArray_pairlElongcOfloatgR(void *p) {
      delete [] ((pair<long,float>*)p);
   }
   static void destruct_pairlElongcOfloatgR(void *p) {
      typedef pair<long,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,long> : new pair<long,long>;
   }
   static void *newArray_pairlElongcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,long>[nElements] : new pair<long,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOlonggR(void *p) {
      delete ((pair<long,long>*)p);
   }
   static void deleteArray_pairlElongcOlonggR(void *p) {
      delete [] ((pair<long,long>*)p);
   }
   static void destruct_pairlElongcOlonggR(void *p) {
      typedef pair<long,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,int> : new pair<long,int>;
   }
   static void *newArray_pairlElongcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<long,int>[nElements] : new pair<long,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOintgR(void *p) {
      delete ((pair<long,int>*)p);
   }
   static void deleteArray_pairlElongcOintgR(void *p) {
      delete [] ((pair<long,int>*)p);
   }
   static void destruct_pairlElongcOintgR(void *p) {
      typedef pair<long,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,char*> : new pair<int,char*>;
   }
   static void *newArray_pairlEintcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,char*>[nElements] : new pair<int,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOcharmUgR(void *p) {
      delete ((pair<int,char*>*)p);
   }
   static void deleteArray_pairlEintcOcharmUgR(void *p) {
      delete [] ((pair<int,char*>*)p);
   }
   static void destruct_pairlEintcOcharmUgR(void *p) {
      typedef pair<int,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,void*> : new pair<int,void*>;
   }
   static void *newArray_pairlEintcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,void*>[nElements] : new pair<int,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOvoidmUgR(void *p) {
      delete ((pair<int,void*>*)p);
   }
   static void deleteArray_pairlEintcOvoidmUgR(void *p) {
      delete [] ((pair<int,void*>*)p);
   }
   static void destruct_pairlEintcOvoidmUgR(void *p) {
      typedef pair<int,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,double> : new pair<int,double>;
   }
   static void *newArray_pairlEintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,double>[nElements] : new pair<int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOdoublegR(void *p) {
      delete ((pair<int,double>*)p);
   }
   static void deleteArray_pairlEintcOdoublegR(void *p) {
      delete [] ((pair<int,double>*)p);
   }
   static void destruct_pairlEintcOdoublegR(void *p) {
      typedef pair<int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,float> : new pair<int,float>;
   }
   static void *newArray_pairlEintcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,float>[nElements] : new pair<int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOfloatgR(void *p) {
      delete ((pair<int,float>*)p);
   }
   static void deleteArray_pairlEintcOfloatgR(void *p) {
      delete [] ((pair<int,float>*)p);
   }
   static void destruct_pairlEintcOfloatgR(void *p) {
      typedef pair<int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,long> : new pair<int,long>;
   }
   static void *newArray_pairlEintcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,long>[nElements] : new pair<int,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOlonggR(void *p) {
      delete ((pair<int,long>*)p);
   }
   static void deleteArray_pairlEintcOlonggR(void *p) {
      delete [] ((pair<int,long>*)p);
   }
   static void destruct_pairlEintcOlonggR(void *p) {
      typedef pair<int,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,void*> : new pair<string,void*>;
   }
   static void *newArray_pairlEstringcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,void*>[nElements] : new pair<string,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOvoidmUgR(void *p) {
      delete ((pair<string,void*>*)p);
   }
   static void deleteArray_pairlEstringcOvoidmUgR(void *p) {
      delete [] ((pair<string,void*>*)p);
   }
   static void destruct_pairlEstringcOvoidmUgR(void *p) {
      typedef pair<string,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,double> : new pair<string,double>;
   }
   static void *newArray_pairlEstringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,double>[nElements] : new pair<string,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOdoublegR(void *p) {
      delete ((pair<string,double>*)p);
   }
   static void deleteArray_pairlEstringcOdoublegR(void *p) {
      delete [] ((pair<string,double>*)p);
   }
   static void destruct_pairlEstringcOdoublegR(void *p) {
      typedef pair<string,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,float> : new pair<string,float>;
   }
   static void *newArray_pairlEstringcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,float>[nElements] : new pair<string,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOfloatgR(void *p) {
      delete ((pair<string,float>*)p);
   }
   static void deleteArray_pairlEstringcOfloatgR(void *p) {
      delete [] ((pair<string,float>*)p);
   }
   static void destruct_pairlEstringcOfloatgR(void *p) {
      typedef pair<string,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,long> : new pair<string,long>;
   }
   static void *newArray_pairlEstringcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,long>[nElements] : new pair<string,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOlonggR(void *p) {
      delete ((pair<string,long>*)p);
   }
   static void deleteArray_pairlEstringcOlonggR(void *p) {
      delete [] ((pair<string,long>*)p);
   }
   static void destruct_pairlEstringcOlonggR(void *p) {
      typedef pair<string,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,char*> : new pair<char*,char*>;
   }
   static void *newArray_pairlEcharmUcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,char*>[nElements] : new pair<char*,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOcharmUgR(void *p) {
      delete ((pair<char*,char*>*)p);
   }
   static void deleteArray_pairlEcharmUcOcharmUgR(void *p) {
      delete [] ((pair<char*,char*>*)p);
   }
   static void destruct_pairlEcharmUcOcharmUgR(void *p) {
      typedef pair<char*,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,char*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,void*> : new pair<char*,void*>;
   }
   static void *newArray_pairlEcharmUcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,void*>[nElements] : new pair<char*,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOvoidmUgR(void *p) {
      delete ((pair<char*,void*>*)p);
   }
   static void deleteArray_pairlEcharmUcOvoidmUgR(void *p) {
      delete [] ((pair<char*,void*>*)p);
   }
   static void destruct_pairlEcharmUcOvoidmUgR(void *p) {
      typedef pair<char*,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,void*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,double> : new pair<char*,double>;
   }
   static void *newArray_pairlEcharmUcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,double>[nElements] : new pair<char*,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOdoublegR(void *p) {
      delete ((pair<char*,double>*)p);
   }
   static void deleteArray_pairlEcharmUcOdoublegR(void *p) {
      delete [] ((pair<char*,double>*)p);
   }
   static void destruct_pairlEcharmUcOdoublegR(void *p) {
      typedef pair<char*,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,float> : new pair<char*,float>;
   }
   static void *newArray_pairlEcharmUcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,float>[nElements] : new pair<char*,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOfloatgR(void *p) {
      delete ((pair<char*,float>*)p);
   }
   static void deleteArray_pairlEcharmUcOfloatgR(void *p) {
      delete [] ((pair<char*,float>*)p);
   }
   static void destruct_pairlEcharmUcOfloatgR(void *p) {
      typedef pair<char*,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,long> : new pair<char*,long>;
   }
   static void *newArray_pairlEcharmUcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,long>[nElements] : new pair<char*,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOlonggR(void *p) {
      delete ((pair<char*,long>*)p);
   }
   static void deleteArray_pairlEcharmUcOlonggR(void *p) {
      delete [] ((pair<char*,long>*)p);
   }
   static void destruct_pairlEcharmUcOlonggR(void *p) {
      typedef pair<char*,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,int> : new pair<char*,int>;
   }
   static void *newArray_pairlEcharmUcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<char*,int>[nElements] : new pair<char*,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOintgR(void *p) {
      delete ((pair<char*,int>*)p);
   }
   static void deleteArray_pairlEcharmUcOintgR(void *p) {
      delete [] ((pair<char*,int>*)p);
   }
   static void destruct_pairlEcharmUcOintgR(void *p) {
      typedef pair<char*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > > : new ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >;
   }
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >[nElements] : new ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p) {
      delete ((::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >*)p);
   }
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p) {
      delete [] ((::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >*)p);
   }
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgRsPgR(void *p) {
      typedef ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,vector<TString> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > > : new ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >;
   }
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >[nElements] : new ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p) {
      delete ((::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >*)p);
   }
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p) {
      delete [] ((::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >*)p);
   }
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgRsPgR(void *p) {
      typedef ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::reverse_iterator<__gnu_cxx::__normal_iterator<int*,vector<int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > > : new ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >;
   }
   static void *newArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >[nElements] : new ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >*)p);
   }
   static void deleteArray_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >*)p);
   }
   static void destruct_reverse_iteratorlE__gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::reverse_iterator<__gnu_cxx::__normal_iterator<string*,vector<string> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<char*,string> : new ::__gnu_cxx::__normal_iterator<char*,string>;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<char*,string>[nElements] : new ::__gnu_cxx::__normal_iterator<char*,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<char*,string>*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<char*,string>*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEcharmUcOstringgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<char*,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<char*,string>

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const char*,string> : new ::__gnu_cxx::__normal_iterator<const char*,string>;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const char*,string>[nElements] : new ::__gnu_cxx::__normal_iterator<const char*,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const char*,string>*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const char*,string>*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPcharmUcOstringgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const char*,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const char*,string>

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<TString*,vector<TString> > : new ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >[nElements] : new ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<TString*,vector<TString> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlETStringmUcOvectorlETStringgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<TString*,vector<TString> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<TString*,vector<TString> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> > : new ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >[nElements] : new ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPTStringmUcOvectorlETStringgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const TString*,vector<TString> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const int*,vector<int> > : new ::__gnu_cxx::__normal_iterator<const int*,vector<int> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const int*,vector<int> >[nElements] : new ::__gnu_cxx::__normal_iterator<const int*,vector<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const int*,vector<int> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPintmUcOvectorlEintgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const int*,vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const int*,vector<int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<int*,vector<int> > : new ::__gnu_cxx::__normal_iterator<int*,vector<int> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<int*,vector<int> >[nElements] : new ::__gnu_cxx::__normal_iterator<int*,vector<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<int*,vector<int> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<int*,vector<int> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEintmUcOvectorlEintgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<int*,vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<int*,vector<int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const string*,vector<string> > : new ::__gnu_cxx::__normal_iterator<const string*,vector<string> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const string*,vector<string> >[nElements] : new ::__gnu_cxx::__normal_iterator<const string*,vector<string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const string*,vector<string> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPstringmUcOvectorlEstringgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const string*,vector<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const string*,vector<string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<string*,vector<string> > : new ::__gnu_cxx::__normal_iterator<string*,vector<string> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<string*,vector<string> >[nElements] : new ::__gnu_cxx::__normal_iterator<string*,vector<string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<string*,vector<string> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<string*,vector<string> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEstringmUcOvectorlEstringgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<string*,vector<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<string*,vector<string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_string(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) string : new string;
   }
   static void *newArray_string(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) string[nElements] : new string[nElements];
   }
   // Wrapper around operator delete
   static void delete_string(void *p) {
      delete ((string*)p);
   }
   static void deleteArray_string(void *p) {
      delete [] ((string*)p);
   }
   static void destruct_string(void *p) {
      typedef string current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class string

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualIsAProxy(void *p) {
      delete ((::TVirtualIsAProxy*)p);
   }
   static void deleteArray_TVirtualIsAProxy(void *p) {
      delete [] ((::TVirtualIsAProxy*)p);
   }
   static void destruct_TVirtualIsAProxy(void *p) {
      typedef ::TVirtualIsAProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualIsAProxy

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TIsAProxy(void *p) {
      delete ((::TIsAProxy*)p);
   }
   static void deleteArray_TIsAProxy(void *p) {
      delete [] ((::TIsAProxy*)p);
   }
   static void destruct_TIsAProxy(void *p) {
      typedef ::TIsAProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TIsAProxy

//______________________________________________________________________________
void TStorage::Streamer(TBuffer &R__b)
{
   // Stream an object of class TStorage.

   ::Error("TStorage::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStorage(void *p) {
      return  p ? new(p) ::TStorage : new ::TStorage;
   }
   static void *newArray_TStorage(Long_t nElements, void *p) {
      return p ? new(p) ::TStorage[nElements] : new ::TStorage[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStorage(void *p) {
      delete ((::TStorage*)p);
   }
   static void deleteArray_TStorage(void *p) {
      delete [] ((::TStorage*)p);
   }
   static void destruct_TStorage(void *p) {
      typedef ::TStorage current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStorage(TBuffer &buf, void *obj) {
      ((::TStorage*)obj)->::TStorage::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStorage

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObject(void *p) {
      return  p ? new(p) ::TObject : new ::TObject;
   }
   static void *newArray_TObject(Long_t nElements, void *p) {
      return p ? new(p) ::TObject[nElements] : new ::TObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObject(void *p) {
      delete ((::TObject*)p);
   }
   static void deleteArray_TObject(void *p) {
      delete [] ((::TObject*)p);
   }
   static void destruct_TObject(void *p) {
      typedef ::TObject current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObject(TBuffer &buf, void *obj) {
      ((::TObject*)obj)->::TObject::Streamer(buf);
   }
} // end of namespace ROOT for class ::TObject

//______________________________________________________________________________
void TIterator::Streamer(TBuffer &R__b)
{
   // Stream an object of class TIterator.

   ::Error("TIterator::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TIterator(void *p) {
      delete ((::TIterator*)p);
   }
   static void deleteArray_TIterator(void *p) {
      delete [] ((::TIterator*)p);
   }
   static void destruct_TIterator(void *p) {
      typedef ::TIterator current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TIterator(TBuffer &buf, void *obj) {
      ((::TIterator*)obj)->::TIterator::Streamer(buf);
   }
} // end of namespace ROOT for class ::TIterator

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TSubString(void *p) {
      delete ((::TSubString*)p);
   }
   static void deleteArray_TSubString(void *p) {
      delete [] ((::TSubString*)p);
   }
   static void destruct_TSubString(void *p) {
      typedef ::TSubString current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TSubString

namespace ROOT {
   // Wrappers around operator new
   static void *new_TString(void *p) {
      return  p ? new(p) ::TString : new ::TString;
   }
   static void *newArray_TString(Long_t nElements, void *p) {
      return p ? new(p) ::TString[nElements] : new ::TString[nElements];
   }
   // Wrapper around operator delete
   static void delete_TString(void *p) {
      delete ((::TString*)p);
   }
   static void deleteArray_TString(void *p) {
      delete [] ((::TString*)p);
   }
   static void destruct_TString(void *p) {
      typedef ::TString current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TString(TBuffer &buf, void *obj) {
      ((::TString*)obj)->::TString::Streamer(buf);
   }
} // end of namespace ROOT for class ::TString

//______________________________________________________________________________
void TVirtualMutex::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMutex.

   ::Error("TVirtualMutex::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualMutex(void *p) {
      delete ((::TVirtualMutex*)p);
   }
   static void deleteArray_TVirtualMutex(void *p) {
      delete [] ((::TVirtualMutex*)p);
   }
   static void destruct_TVirtualMutex(void *p) {
      typedef ::TVirtualMutex current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualMutex(TBuffer &buf, void *obj) {
      ((::TVirtualMutex*)obj)->::TVirtualMutex::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualMutex

//______________________________________________________________________________
void TLockGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class TLockGuard.

   ::Error("TLockGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TLockGuard(void *p) {
      delete ((::TLockGuard*)p);
   }
   static void deleteArray_TLockGuard(void *p) {
      delete [] ((::TLockGuard*)p);
   }
   static void destruct_TLockGuard(void *p) {
      typedef ::TLockGuard current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TLockGuard(TBuffer &buf, void *obj) {
      ((::TLockGuard*)obj)->::TLockGuard::Streamer(buf);
   }
} // end of namespace ROOT for class ::TLockGuard

namespace ROOT {
//______________________________________________________________________________
void TVirtualRWMutex::Streamer(TBuffer &R__b)
{
   // Stream an object of class ROOT::TVirtualRWMutex.

   TVirtualMutex::Streamer(R__b);
}

} // namespace ROOT
namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLTVirtualRWMutex(void *p) {
      delete ((::ROOT::TVirtualRWMutex*)p);
   }
   static void deleteArray_ROOTcLcLTVirtualRWMutex(void *p) {
      delete [] ((::ROOT::TVirtualRWMutex*)p);
   }
   static void destruct_ROOTcLcLTVirtualRWMutex(void *p) {
      typedef ::ROOT::TVirtualRWMutex current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_ROOTcLcLTVirtualRWMutex(TBuffer &buf, void *obj) {
      ((::ROOT::TVirtualRWMutex*)obj)->::ROOT::TVirtualRWMutex::Streamer(buf);
   }
} // end of namespace ROOT for class ::ROOT::TVirtualRWMutex

namespace ROOT {
//______________________________________________________________________________
void TReadLockGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class ROOT::TReadLockGuard.

   ::Error("ROOT::TReadLockGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

} // namespace ROOT
namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLTReadLockGuard(void *p) {
      delete ((::ROOT::TReadLockGuard*)p);
   }
   static void deleteArray_ROOTcLcLTReadLockGuard(void *p) {
      delete [] ((::ROOT::TReadLockGuard*)p);
   }
   static void destruct_ROOTcLcLTReadLockGuard(void *p) {
      typedef ::ROOT::TReadLockGuard current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_ROOTcLcLTReadLockGuard(TBuffer &buf, void *obj) {
      ((::ROOT::TReadLockGuard*)obj)->::ROOT::TReadLockGuard::Streamer(buf);
   }
} // end of namespace ROOT for class ::ROOT::TReadLockGuard

namespace ROOT {
//______________________________________________________________________________
void TWriteLockGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class ROOT::TWriteLockGuard.

   ::Error("ROOT::TWriteLockGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

} // namespace ROOT
namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLTWriteLockGuard(void *p) {
      delete ((::ROOT::TWriteLockGuard*)p);
   }
   static void deleteArray_ROOTcLcLTWriteLockGuard(void *p) {
      delete [] ((::ROOT::TWriteLockGuard*)p);
   }
   static void destruct_ROOTcLcLTWriteLockGuard(void *p) {
      typedef ::ROOT::TWriteLockGuard current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_ROOTcLcLTWriteLockGuard(TBuffer &buf, void *obj) {
      ((::ROOT::TWriteLockGuard*)obj)->::ROOT::TWriteLockGuard::Streamer(buf);
   }
} // end of namespace ROOT for class ::ROOT::TWriteLockGuard

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TCollection(void *p) {
      delete ((::TCollection*)p);
   }
   static void deleteArray_TCollection(void *p) {
      delete [] ((::TCollection*)p);
   }
   static void destruct_TCollection(void *p) {
      typedef ::TCollection current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TCollection(TBuffer &buf, void *obj) {
      ((::TCollection*)obj)->::TCollection::Streamer(buf);
   }
} // end of namespace ROOT for class ::TCollection

//______________________________________________________________________________
void TIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TIter.

   ::Error("TIter::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TIter(void *p) {
      delete ((::TIter*)p);
   }
   static void deleteArray_TIter(void *p) {
      delete [] ((::TIter*)p);
   }
   static void destruct_TIter(void *p) {
      typedef ::TIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TIter(TBuffer &buf, void *obj) {
      ((::TIter*)obj)->::TIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TIter

//______________________________________________________________________________
void TSeqCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSeqCollection.

   TCollection::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TSeqCollection(void *p) {
      delete ((::TSeqCollection*)p);
   }
   static void deleteArray_TSeqCollection(void *p) {
      delete [] ((::TSeqCollection*)p);
   }
   static void destruct_TSeqCollection(void *p) {
      typedef ::TSeqCollection current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TSeqCollection(TBuffer &buf, void *obj) {
      ((::TSeqCollection*)obj)->::TSeqCollection::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TSeqCollection(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TSeqCollection*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TSeqCollection

namespace ROOT {
   // Wrappers around operator new
   static void *new_TList(void *p) {
      return  p ? new(p) ::TList : new ::TList;
   }
   static void *newArray_TList(Long_t nElements, void *p) {
      return p ? new(p) ::TList[nElements] : new ::TList[nElements];
   }
   // Wrapper around operator delete
   static void delete_TList(void *p) {
      delete ((::TList*)p);
   }
   static void deleteArray_TList(void *p) {
      delete [] ((::TList*)p);
   }
   static void destruct_TList(void *p) {
      typedef ::TList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TList(TBuffer &buf, void *obj) {
      ((::TList*)obj)->::TList::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TList(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TList*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TList

//______________________________________________________________________________
void TListIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListIter(void *p) {
      delete ((::TListIter*)p);
   }
   static void deleteArray_TListIter(void *p) {
      delete [] ((::TListIter*)p);
   }
   static void destruct_TListIter(void *p) {
      typedef ::TListIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TListIter(TBuffer &buf, void *obj) {
      ((::TListIter*)obj)->::TListIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TListIter

namespace ROOT {
   // Wrappers around operator new
   static void *new_SetWindowAttributes_t(void *p) {
      return  p ? new(p) ::SetWindowAttributes_t : new ::SetWindowAttributes_t;
   }
   static void *newArray_SetWindowAttributes_t(Long_t nElements, void *p) {
      return p ? new(p) ::SetWindowAttributes_t[nElements] : new ::SetWindowAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SetWindowAttributes_t(void *p) {
      delete ((::SetWindowAttributes_t*)p);
   }
   static void deleteArray_SetWindowAttributes_t(void *p) {
      delete [] ((::SetWindowAttributes_t*)p);
   }
   static void destruct_SetWindowAttributes_t(void *p) {
      typedef ::SetWindowAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SetWindowAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_WindowAttributes_t(void *p) {
      return  p ? new(p) ::WindowAttributes_t : new ::WindowAttributes_t;
   }
   static void *newArray_WindowAttributes_t(Long_t nElements, void *p) {
      return p ? new(p) ::WindowAttributes_t[nElements] : new ::WindowAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_WindowAttributes_t(void *p) {
      delete ((::WindowAttributes_t*)p);
   }
   static void deleteArray_WindowAttributes_t(void *p) {
      delete [] ((::WindowAttributes_t*)p);
   }
   static void destruct_WindowAttributes_t(void *p) {
      typedef ::WindowAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::WindowAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Event_t(void *p) {
      return  p ? new(p) ::Event_t : new ::Event_t;
   }
   static void *newArray_Event_t(Long_t nElements, void *p) {
      return p ? new(p) ::Event_t[nElements] : new ::Event_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Event_t(void *p) {
      delete ((::Event_t*)p);
   }
   static void deleteArray_Event_t(void *p) {
      delete [] ((::Event_t*)p);
   }
   static void destruct_Event_t(void *p) {
      typedef ::Event_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Event_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_GCValues_t(void *p) {
      return  p ? new(p) ::GCValues_t : new ::GCValues_t;
   }
   static void *newArray_GCValues_t(Long_t nElements, void *p) {
      return p ? new(p) ::GCValues_t[nElements] : new ::GCValues_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GCValues_t(void *p) {
      delete ((::GCValues_t*)p);
   }
   static void deleteArray_GCValues_t(void *p) {
      delete [] ((::GCValues_t*)p);
   }
   static void destruct_GCValues_t(void *p) {
      typedef ::GCValues_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GCValues_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_ColorStruct_t(void *p) {
      return  p ? new(p) ::ColorStruct_t : new ::ColorStruct_t;
   }
   static void *newArray_ColorStruct_t(Long_t nElements, void *p) {
      return p ? new(p) ::ColorStruct_t[nElements] : new ::ColorStruct_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ColorStruct_t(void *p) {
      delete ((::ColorStruct_t*)p);
   }
   static void deleteArray_ColorStruct_t(void *p) {
      delete [] ((::ColorStruct_t*)p);
   }
   static void destruct_ColorStruct_t(void *p) {
      typedef ::ColorStruct_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ColorStruct_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_PictureAttributes_t(void *p) {
      return  p ? new(p) ::PictureAttributes_t : new ::PictureAttributes_t;
   }
   static void *newArray_PictureAttributes_t(Long_t nElements, void *p) {
      return p ? new(p) ::PictureAttributes_t[nElements] : new ::PictureAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PictureAttributes_t(void *p) {
      delete ((::PictureAttributes_t*)p);
   }
   static void deleteArray_PictureAttributes_t(void *p) {
      delete [] ((::PictureAttributes_t*)p);
   }
   static void destruct_PictureAttributes_t(void *p) {
      typedef ::PictureAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PictureAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Segment_t(void *p) {
      return  p ? new(p) ::Segment_t : new ::Segment_t;
   }
   static void *newArray_Segment_t(Long_t nElements, void *p) {
      return p ? new(p) ::Segment_t[nElements] : new ::Segment_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Segment_t(void *p) {
      delete ((::Segment_t*)p);
   }
   static void deleteArray_Segment_t(void *p) {
      delete [] ((::Segment_t*)p);
   }
   static void destruct_Segment_t(void *p) {
      typedef ::Segment_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Segment_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Point_t(void *p) {
      return  p ? new(p) ::Point_t : new ::Point_t;
   }
   static void *newArray_Point_t(Long_t nElements, void *p) {
      return p ? new(p) ::Point_t[nElements] : new ::Point_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Point_t(void *p) {
      delete ((::Point_t*)p);
   }
   static void deleteArray_Point_t(void *p) {
      delete [] ((::Point_t*)p);
   }
   static void destruct_Point_t(void *p) {
      typedef ::Point_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Point_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Rectangle_t(void *p) {
      return  p ? new(p) ::Rectangle_t : new ::Rectangle_t;
   }
   static void *newArray_Rectangle_t(Long_t nElements, void *p) {
      return p ? new(p) ::Rectangle_t[nElements] : new ::Rectangle_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Rectangle_t(void *p) {
      delete ((::Rectangle_t*)p);
   }
   static void deleteArray_Rectangle_t(void *p) {
      delete [] ((::Rectangle_t*)p);
   }
   static void destruct_Rectangle_t(void *p) {
      typedef ::Rectangle_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Rectangle_t

//______________________________________________________________________________
void TNamed::Streamer(TBuffer &R__b)
{
   // Stream an object of class TNamed.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TNamed::Class(),this);
   } else {
      R__b.WriteClassBuffer(TNamed::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TNamed(void *p) {
      return  p ? new(p) ::TNamed : new ::TNamed;
   }
   static void *newArray_TNamed(Long_t nElements, void *p) {
      return p ? new(p) ::TNamed[nElements] : new ::TNamed[nElements];
   }
   // Wrapper around operator delete
   static void delete_TNamed(void *p) {
      delete ((::TNamed*)p);
   }
   static void deleteArray_TNamed(void *p) {
      delete [] ((::TNamed*)p);
   }
   static void destruct_TNamed(void *p) {
      typedef ::TNamed current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TNamed

//______________________________________________________________________________
void TDictionary::Streamer(TBuffer &R__b)
{
   // Stream an object of class TDictionary.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TDictionary::Class(),this);
   } else {
      R__b.WriteClassBuffer(TDictionary::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TDictionary(void *p) {
      delete ((::TDictionary*)p);
   }
   static void deleteArray_TDictionary(void *p) {
      delete [] ((::TDictionary*)p);
   }
   static void destruct_TDictionary(void *p) {
      typedef ::TDictionary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TDictionary

//______________________________________________________________________________
void TDataType::Streamer(TBuffer &R__b)
{
   // Stream an object of class TDataType.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TDictionary::Streamer(R__b);
      R__b >> fSize;
      void *ptr_fType = (void*)&fType;
      R__b >> *reinterpret_cast<Int_t*>(ptr_fType);
      R__b >> fProperty;
      fTrueName.Streamer(R__b);
      R__b >> fTypeNameIdx;
      R__b >> fTypeNameLen;
      R__b.CheckByteCount(R__s, R__c, TDataType::IsA());
   } else {
      R__c = R__b.WriteVersion(TDataType::IsA(), kTRUE);
      TDictionary::Streamer(R__b);
      R__b << fSize;
      R__b << (Int_t)fType;
      R__b << fProperty;
      fTrueName.Streamer(R__b);
      R__b << fTypeNameIdx;
      R__b << fTypeNameLen;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TDataType(void *p) {
      return  p ? new(p) ::TDataType : new ::TDataType;
   }
   static void *newArray_TDataType(Long_t nElements, void *p) {
      return p ? new(p) ::TDataType[nElements] : new ::TDataType[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDataType(void *p) {
      delete ((::TDataType*)p);
   }
   static void deleteArray_TDataType(void *p) {
      delete [] ((::TDataType*)p);
   }
   static void destruct_TDataType(void *p) {
      typedef ::TDataType current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TDataType(TBuffer &buf, void *obj) {
      ((::TDataType*)obj)->::TDataType::Streamer(buf);
   }
} // end of namespace ROOT for class ::TDataType

//______________________________________________________________________________
void TInterpreter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TInterpreter.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TInterpreter(void *p) {
      delete ((::TInterpreter*)p);
   }
   static void deleteArray_TInterpreter(void *p) {
      delete [] ((::TInterpreter*)p);
   }
   static void destruct_TInterpreter(void *p) {
      typedef ::TInterpreter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TInterpreter(TBuffer &buf, void *obj) {
      ((::TInterpreter*)obj)->::TInterpreter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TInterpreter

namespace ROOT {
   // Wrappers around operator new
   static void *new_TQObject(void *p) {
      return  p ? new(p) ::TQObject : new ::TQObject;
   }
   static void *newArray_TQObject(Long_t nElements, void *p) {
      return p ? new(p) ::TQObject[nElements] : new ::TQObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_TQObject(void *p) {
      delete ((::TQObject*)p);
   }
   static void deleteArray_TQObject(void *p) {
      delete [] ((::TQObject*)p);
   }
   static void destruct_TQObject(void *p) {
      typedef ::TQObject current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQObject(TBuffer &buf, void *obj) {
      ((::TQObject*)obj)->::TQObject::Streamer(buf);
   }
} // end of namespace ROOT for class ::TQObject

//______________________________________________________________________________
void TQObjSender::Streamer(TBuffer &R__b)
{
   // Stream an object of class TQObjSender.

   TQObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TQObjSender(void *p) {
      return  p ? new(p) ::TQObjSender : new ::TQObjSender;
   }
   static void *newArray_TQObjSender(Long_t nElements, void *p) {
      return p ? new(p) ::TQObjSender[nElements] : new ::TQObjSender[nElements];
   }
   // Wrapper around operator delete
   static void delete_TQObjSender(void *p) {
      delete ((::TQObjSender*)p);
   }
   static void deleteArray_TQObjSender(void *p) {
      delete [] ((::TQObjSender*)p);
   }
   static void destruct_TQObjSender(void *p) {
      typedef ::TQObjSender current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQObjSender(TBuffer &buf, void *obj) {
      ((::TQObjSender*)obj)->::TQObjSender::Streamer(buf);
   }
} // end of namespace ROOT for class ::TQObjSender

//______________________________________________________________________________
void TApplicationImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TApplicationImp.

   ::Error("TApplicationImp::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TApplicationImp(void *p) {
      return  p ? new(p) ::TApplicationImp : new ::TApplicationImp;
   }
   static void *newArray_TApplicationImp(Long_t nElements, void *p) {
      return p ? new(p) ::TApplicationImp[nElements] : new ::TApplicationImp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TApplicationImp(void *p) {
      delete ((::TApplicationImp*)p);
   }
   static void deleteArray_TApplicationImp(void *p) {
      delete [] ((::TApplicationImp*)p);
   }
   static void destruct_TApplicationImp(void *p) {
      typedef ::TApplicationImp current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TApplicationImp(TBuffer &buf, void *obj) {
      ((::TApplicationImp*)obj)->::TApplicationImp::Streamer(buf);
   }
} // end of namespace ROOT for class ::TApplicationImp

//______________________________________________________________________________
void TApplication::Streamer(TBuffer &R__b)
{
   // Stream an object of class TApplication.

   TObject::Streamer(R__b);
   TQObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TApplication(void *p) {
      delete ((::TApplication*)p);
   }
   static void deleteArray_TApplication(void *p) {
      delete [] ((::TApplication*)p);
   }
   static void destruct_TApplication(void *p) {
      typedef ::TApplication current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TApplication(TBuffer &buf, void *obj) {
      ((::TApplication*)obj)->::TApplication::Streamer(buf);
   }
} // end of namespace ROOT for class ::TApplication

//______________________________________________________________________________
void TAtt3D::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAtt3D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAtt3D::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAtt3D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAtt3D(void *p) {
      return  p ? new(p) ::TAtt3D : new ::TAtt3D;
   }
   static void *newArray_TAtt3D(Long_t nElements, void *p) {
      return p ? new(p) ::TAtt3D[nElements] : new ::TAtt3D[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAtt3D(void *p) {
      delete ((::TAtt3D*)p);
   }
   static void deleteArray_TAtt3D(void *p) {
      delete [] ((::TAtt3D*)p);
   }
   static void destruct_TAtt3D(void *p) {
      typedef ::TAtt3D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAtt3D

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttAxis(void *p) {
      return  p ? new(p) ::TAttAxis : new ::TAttAxis;
   }
   static void *newArray_TAttAxis(Long_t nElements, void *p) {
      return p ? new(p) ::TAttAxis[nElements] : new ::TAttAxis[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttAxis(void *p) {
      delete ((::TAttAxis*)p);
   }
   static void deleteArray_TAttAxis(void *p) {
      delete [] ((::TAttAxis*)p);
   }
   static void destruct_TAttAxis(void *p) {
      typedef ::TAttAxis current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TAttAxis(TBuffer &buf, void *obj) {
      ((::TAttAxis*)obj)->::TAttAxis::Streamer(buf);
   }
} // end of namespace ROOT for class ::TAttAxis

//______________________________________________________________________________
void TAttBBox2D::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttBBox2D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttBBox2D::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttBBox2D::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TAttBBox2D(void *p) {
      delete ((::TAttBBox2D*)p);
   }
   static void deleteArray_TAttBBox2D(void *p) {
      delete [] ((::TAttBBox2D*)p);
   }
   static void destruct_TAttBBox2D(void *p) {
      typedef ::TAttBBox2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttBBox2D

//______________________________________________________________________________
void TAttBBox::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttBBox.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttBBox::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttBBox::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TAttBBox(void *p) {
      delete ((::TAttBBox*)p);
   }
   static void deleteArray_TAttBBox(void *p) {
      delete [] ((::TAttBBox*)p);
   }
   static void destruct_TAttBBox(void *p) {
      typedef ::TAttBBox current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttBBox

//______________________________________________________________________________
void TAttFill::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttFill.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttFill::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttFill::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttFill(void *p) {
      return  p ? new(p) ::TAttFill : new ::TAttFill;
   }
   static void *newArray_TAttFill(Long_t nElements, void *p) {
      return p ? new(p) ::TAttFill[nElements] : new ::TAttFill[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttFill(void *p) {
      delete ((::TAttFill*)p);
   }
   static void deleteArray_TAttFill(void *p) {
      delete [] ((::TAttFill*)p);
   }
   static void destruct_TAttFill(void *p) {
      typedef ::TAttFill current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttFill

//______________________________________________________________________________
void TAttLine::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttLine.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttLine::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttLine::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttLine(void *p) {
      return  p ? new(p) ::TAttLine : new ::TAttLine;
   }
   static void *newArray_TAttLine(Long_t nElements, void *p) {
      return p ? new(p) ::TAttLine[nElements] : new ::TAttLine[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttLine(void *p) {
      delete ((::TAttLine*)p);
   }
   static void deleteArray_TAttLine(void *p) {
      delete [] ((::TAttLine*)p);
   }
   static void destruct_TAttLine(void *p) {
      typedef ::TAttLine current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttLine

//______________________________________________________________________________
void TAttMarker::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttMarker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttMarker::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttMarker::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttMarker(void *p) {
      return  p ? new(p) ::TAttMarker : new ::TAttMarker;
   }
   static void *newArray_TAttMarker(Long_t nElements, void *p) {
      return p ? new(p) ::TAttMarker[nElements] : new ::TAttMarker[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttMarker(void *p) {
      delete ((::TAttMarker*)p);
   }
   static void deleteArray_TAttMarker(void *p) {
      delete [] ((::TAttMarker*)p);
   }
   static void destruct_TAttMarker(void *p) {
      typedef ::TAttMarker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttMarker

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttPad(void *p) {
      return  p ? new(p) ::TAttPad : new ::TAttPad;
   }
   static void *newArray_TAttPad(Long_t nElements, void *p) {
      return p ? new(p) ::TAttPad[nElements] : new ::TAttPad[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttPad(void *p) {
      delete ((::TAttPad*)p);
   }
   static void deleteArray_TAttPad(void *p) {
      delete [] ((::TAttPad*)p);
   }
   static void destruct_TAttPad(void *p) {
      typedef ::TAttPad current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TAttPad(TBuffer &buf, void *obj) {
      ((::TAttPad*)obj)->::TAttPad::Streamer(buf);
   }
} // end of namespace ROOT for class ::TAttPad

//______________________________________________________________________________
void TAttText::Streamer(TBuffer &R__b)
{
   // Stream an object of class TAttText.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TAttText::Class(),this);
   } else {
      R__b.WriteClassBuffer(TAttText::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TAttText(void *p) {
      return  p ? new(p) ::TAttText : new ::TAttText;
   }
   static void *newArray_TAttText(Long_t nElements, void *p) {
      return p ? new(p) ::TAttText[nElements] : new ::TAttText[nElements];
   }
   // Wrapper around operator delete
   static void delete_TAttText(void *p) {
      delete ((::TAttText*)p);
   }
   static void deleteArray_TAttText(void *p) {
      delete [] ((::TAttText*)p);
   }
   static void destruct_TAttText(void *p) {
      typedef ::TAttText current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TAttText

//______________________________________________________________________________
void TBase64::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBase64.

   ::Error("TBase64::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBase64(void *p) {
      return  p ? new(p) ::TBase64 : new ::TBase64;
   }
   static void *newArray_TBase64(Long_t nElements, void *p) {
      return p ? new(p) ::TBase64[nElements] : new ::TBase64[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBase64(void *p) {
      delete ((::TBase64*)p);
   }
   static void deleteArray_TBase64(void *p) {
      delete [] ((::TBase64*)p);
   }
   static void destruct_TBase64(void *p) {
      typedef ::TBase64 current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBase64(TBuffer &buf, void *obj) {
      ((::TBase64*)obj)->::TBase64::Streamer(buf);
   }
} // end of namespace ROOT for class ::TBase64

//______________________________________________________________________________
void TStopwatch::Streamer(TBuffer &R__b)
{
   // Stream an object of class TStopwatch.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TStopwatch::Class(),this);
   } else {
      R__b.WriteClassBuffer(TStopwatch::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStopwatch(void *p) {
      return  p ? new(p) ::TStopwatch : new ::TStopwatch;
   }
   static void *newArray_TStopwatch(Long_t nElements, void *p) {
      return p ? new(p) ::TStopwatch[nElements] : new ::TStopwatch[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStopwatch(void *p) {
      delete ((::TStopwatch*)p);
   }
   static void deleteArray_TStopwatch(void *p) {
      delete [] ((::TStopwatch*)p);
   }
   static void destruct_TStopwatch(void *p) {
      typedef ::TStopwatch current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TStopwatch

//______________________________________________________________________________
void TBenchmark::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBenchmark.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TBenchmark::Class(),this);
   } else {
      R__b.WriteClassBuffer(TBenchmark::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBenchmark(void *p) {
      return  p ? new(p) ::TBenchmark : new ::TBenchmark;
   }
   static void *newArray_TBenchmark(Long_t nElements, void *p) {
      return p ? new(p) ::TBenchmark[nElements] : new ::TBenchmark[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBenchmark(void *p) {
      delete ((::TBenchmark*)p);
   }
   static void deleteArray_TBenchmark(void *p) {
      delete [] ((::TBenchmark*)p);
   }
   static void destruct_TBenchmark(void *p) {
      typedef ::TBenchmark current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBenchmark

//______________________________________________________________________________
void TBuffer3D::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBuffer3D.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TBuffer3D(void *p) {
      delete ((::TBuffer3D*)p);
   }
   static void deleteArray_TBuffer3D(void *p) {
      delete [] ((::TBuffer3D*)p);
   }
   static void destruct_TBuffer3D(void *p) {
      typedef ::TBuffer3D current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBuffer3D(TBuffer &buf, void *obj) {
      ((::TBuffer3D*)obj)->::TBuffer3D::Streamer(buf);
   }
} // end of namespace ROOT for class ::TBuffer3D

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObjArray(void *p) {
      return  p ? new(p) ::TObjArray : new ::TObjArray;
   }
   static void *newArray_TObjArray(Long_t nElements, void *p) {
      return p ? new(p) ::TObjArray[nElements] : new ::TObjArray[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObjArray(void *p) {
      delete ((::TObjArray*)p);
   }
   static void deleteArray_TObjArray(void *p) {
      delete [] ((::TObjArray*)p);
   }
   static void destruct_TObjArray(void *p) {
      typedef ::TObjArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObjArray(TBuffer &buf, void *obj) {
      ((::TObjArray*)obj)->::TObjArray::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TObjArray(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TObjArray*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TObjArray

//______________________________________________________________________________
void TObjArrayIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjArrayIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TObjArrayIter(void *p) {
      delete ((::TObjArrayIter*)p);
   }
   static void deleteArray_TObjArrayIter(void *p) {
      delete [] ((::TObjArrayIter*)p);
   }
   static void destruct_TObjArrayIter(void *p) {
      typedef ::TObjArrayIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObjArrayIter(TBuffer &buf, void *obj) {
      ((::TObjArrayIter*)obj)->::TObjArrayIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TObjArrayIter

//______________________________________________________________________________
void TClass::Streamer(TBuffer &R__b)
{
   // Stream an object of class TClass.

   TDictionary::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TClass(void *p) {
      return  p ? new(p) ::TClass : new ::TClass;
   }
   static void *newArray_TClass(Long_t nElements, void *p) {
      return p ? new(p) ::TClass[nElements] : new ::TClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_TClass(void *p) {
      delete ((::TClass*)p);
   }
   static void deleteArray_TClass(void *p) {
      delete [] ((::TClass*)p);
   }
   static void destruct_TClass(void *p) {
      typedef ::TClass current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TClass(TBuffer &buf, void *obj) {
      ((::TClass*)obj)->::TClass::Streamer(buf);
   }
} // end of namespace ROOT for class ::TClass

//______________________________________________________________________________
void TBuffer::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBuffer.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TBuffer(void *p) {
      delete ((::TBuffer*)p);
   }
   static void deleteArray_TBuffer(void *p) {
      delete [] ((::TBuffer*)p);
   }
   static void destruct_TBuffer(void *p) {
      typedef ::TBuffer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBuffer(TBuffer &buf, void *obj) {
      ((::TBuffer*)obj)->::TBuffer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TBuffer

//______________________________________________________________________________
void TColor::Streamer(TBuffer &R__b)
{
   // Stream an object of class TColor.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TColor::Class(),this);
   } else {
      R__b.WriteClassBuffer(TColor::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TColor(void *p) {
      return  p ? new(p) ::TColor : new ::TColor;
   }
   static void *newArray_TColor(Long_t nElements, void *p) {
      return p ? new(p) ::TColor[nElements] : new ::TColor[nElements];
   }
   // Wrapper around operator delete
   static void delete_TColor(void *p) {
      delete ((::TColor*)p);
   }
   static void deleteArray_TColor(void *p) {
      delete [] ((::TColor*)p);
   }
   static void destruct_TColor(void *p) {
      typedef ::TColor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TColor

//______________________________________________________________________________
void TColorGradient::Streamer(TBuffer &R__b)
{
   // Stream an object of class TColorGradient.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TColorGradient::Class(),this);
   } else {
      R__b.WriteClassBuffer(TColorGradient::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TColorGradient(void *p) {
      delete ((::TColorGradient*)p);
   }
   static void deleteArray_TColorGradient(void *p) {
      delete [] ((::TColorGradient*)p);
   }
   static void destruct_TColorGradient(void *p) {
      typedef ::TColorGradient current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TColorGradient

//______________________________________________________________________________
void TLinearGradient::Streamer(TBuffer &R__b)
{
   // Stream an object of class TLinearGradient.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TLinearGradient::Class(),this);
   } else {
      R__b.WriteClassBuffer(TLinearGradient::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TLinearGradient(void *p) {
      return  p ? new(p) ::TLinearGradient : new ::TLinearGradient;
   }
   static void *newArray_TLinearGradient(Long_t nElements, void *p) {
      return p ? new(p) ::TLinearGradient[nElements] : new ::TLinearGradient[nElements];
   }
   // Wrapper around operator delete
   static void delete_TLinearGradient(void *p) {
      delete ((::TLinearGradient*)p);
   }
   static void deleteArray_TLinearGradient(void *p) {
      delete [] ((::TLinearGradient*)p);
   }
   static void destruct_TLinearGradient(void *p) {
      typedef ::TLinearGradient current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TLinearGradient

//______________________________________________________________________________
void TRadialGradient::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRadialGradient.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRadialGradient::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRadialGradient::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRadialGradient(void *p) {
      return  p ? new(p) ::TRadialGradient : new ::TRadialGradient;
   }
   static void *newArray_TRadialGradient(Long_t nElements, void *p) {
      return p ? new(p) ::TRadialGradient[nElements] : new ::TRadialGradient[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRadialGradient(void *p) {
      delete ((::TRadialGradient*)p);
   }
   static void deleteArray_TRadialGradient(void *p) {
      delete [] ((::TRadialGradient*)p);
   }
   static void destruct_TRadialGradient(void *p) {
      typedef ::TRadialGradient current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRadialGradient

namespace ROOT {
   // Wrappers around operator new
   static void *new_TDatime(void *p) {
      return  p ? new(p) ::TDatime : new ::TDatime;
   }
   static void *newArray_TDatime(Long_t nElements, void *p) {
      return p ? new(p) ::TDatime[nElements] : new ::TDatime[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDatime(void *p) {
      delete ((::TDatime*)p);
   }
   static void deleteArray_TDatime(void *p) {
      delete [] ((::TDatime*)p);
   }
   static void destruct_TDatime(void *p) {
      typedef ::TDatime current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TDatime(TBuffer &buf, void *obj) {
      ((::TDatime*)obj)->::TDatime::Streamer(buf);
   }
} // end of namespace ROOT for class ::TDatime

//______________________________________________________________________________
void TUUID::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUUID.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TUUID::Class(),this);
   } else {
      R__b.WriteClassBuffer(TUUID::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUUID(void *p) {
      return  p ? new(p) ::TUUID : new ::TUUID;
   }
   static void *newArray_TUUID(Long_t nElements, void *p) {
      return p ? new(p) ::TUUID[nElements] : new ::TUUID[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUUID(void *p) {
      delete ((::TUUID*)p);
   }
   static void deleteArray_TUUID(void *p) {
      delete [] ((::TUUID*)p);
   }
   static void destruct_TUUID(void *p) {
      typedef ::TUUID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TUUID

namespace ROOT {
   // Wrappers around operator new
   static void *new_TDirectory(void *p) {
      return  p ? new(p) ::TDirectory : new ::TDirectory;
   }
   static void *newArray_TDirectory(Long_t nElements, void *p) {
      return p ? new(p) ::TDirectory[nElements] : new ::TDirectory[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDirectory(void *p) {
      delete ((::TDirectory*)p);
   }
   static void deleteArray_TDirectory(void *p) {
      delete [] ((::TDirectory*)p);
   }
   static void destruct_TDirectory(void *p) {
      typedef ::TDirectory current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TDirectory(TBuffer &buf, void *obj) {
      ((::TDirectory*)obj)->::TDirectory::Streamer(buf);
   }
} // end of namespace ROOT for class ::TDirectory

//______________________________________________________________________________
void TEnvRec::Streamer(TBuffer &R__b)
{
   // Stream an object of class TEnvRec.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TEnvRec::Class(),this);
   } else {
      R__b.WriteClassBuffer(TEnvRec::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TEnvRec(void *p) {
      return  p ? new(p) ::TEnvRec : new ::TEnvRec;
   }
   static void *newArray_TEnvRec(Long_t nElements, void *p) {
      return p ? new(p) ::TEnvRec[nElements] : new ::TEnvRec[nElements];
   }
   // Wrapper around operator delete
   static void delete_TEnvRec(void *p) {
      delete ((::TEnvRec*)p);
   }
   static void deleteArray_TEnvRec(void *p) {
      delete [] ((::TEnvRec*)p);
   }
   static void destruct_TEnvRec(void *p) {
      typedef ::TEnvRec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TEnvRec

//______________________________________________________________________________
void TEnv::Streamer(TBuffer &R__b)
{
   // Stream an object of class TEnv.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TEnv::Class(),this);
   } else {
      R__b.WriteClassBuffer(TEnv::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TEnv(void *p) {
      return  p ? new(p) ::TEnv : new ::TEnv;
   }
   static void *newArray_TEnv(Long_t nElements, void *p) {
      return p ? new(p) ::TEnv[nElements] : new ::TEnv[nElements];
   }
   // Wrapper around operator delete
   static void delete_TEnv(void *p) {
      delete ((::TEnv*)p);
   }
   static void deleteArray_TEnv(void *p) {
      delete [] ((::TEnv*)p);
   }
   static void destruct_TEnv(void *p) {
      typedef ::TEnv current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TEnv

//______________________________________________________________________________
void TExec::Streamer(TBuffer &R__b)
{
   // Stream an object of class TExec.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TExec::Class(),this);
   } else {
      R__b.WriteClassBuffer(TExec::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TExec(void *p) {
      return  p ? new(p) ::TExec : new ::TExec;
   }
   static void *newArray_TExec(Long_t nElements, void *p) {
      return p ? new(p) ::TExec[nElements] : new ::TExec[nElements];
   }
   // Wrapper around operator delete
   static void delete_TExec(void *p) {
      delete ((::TExec*)p);
   }
   static void deleteArray_TExec(void *p) {
      delete [] ((::TExec*)p);
   }
   static void destruct_TExec(void *p) {
      typedef ::TExec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TExec

//______________________________________________________________________________
void TFileCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileCollection.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileCollection::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileCollection::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileCollection(void *p) {
      return  p ? new(p) ::TFileCollection : new ::TFileCollection;
   }
   static void *newArray_TFileCollection(Long_t nElements, void *p) {
      return p ? new(p) ::TFileCollection[nElements] : new ::TFileCollection[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileCollection(void *p) {
      delete ((::TFileCollection*)p);
   }
   static void deleteArray_TFileCollection(void *p) {
      delete [] ((::TFileCollection*)p);
   }
   static void destruct_TFileCollection(void *p) {
      typedef ::TFileCollection current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TFileCollection(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TFileCollection*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TFileCollection

//______________________________________________________________________________
void TUrl::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUrl.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      fUrl.Streamer(R__b);
      fProtocol.Streamer(R__b);
      fUser.Streamer(R__b);
      fPasswd.Streamer(R__b);
      fHost.Streamer(R__b);
      fFile.Streamer(R__b);
      fAnchor.Streamer(R__b);
      fOptions.Streamer(R__b);
      R__b >> fPort;
      R__b.CheckByteCount(R__s, R__c, TUrl::IsA());
   } else {
      R__c = R__b.WriteVersion(TUrl::IsA(), kTRUE);
      TObject::Streamer(R__b);
      fUrl.Streamer(R__b);
      fProtocol.Streamer(R__b);
      fUser.Streamer(R__b);
      fPasswd.Streamer(R__b);
      fHost.Streamer(R__b);
      fFile.Streamer(R__b);
      fAnchor.Streamer(R__b);
      fOptions.Streamer(R__b);
      R__b << fPort;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUrl(void *p) {
      return  p ? new(p) ::TUrl : new ::TUrl;
   }
   static void *newArray_TUrl(Long_t nElements, void *p) {
      return p ? new(p) ::TUrl[nElements] : new ::TUrl[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUrl(void *p) {
      delete ((::TUrl*)p);
   }
   static void deleteArray_TUrl(void *p) {
      delete [] ((::TUrl*)p);
   }
   static void destruct_TUrl(void *p) {
      typedef ::TUrl current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TUrl(TBuffer &buf, void *obj) {
      ((::TUrl*)obj)->::TUrl::Streamer(buf);
   }
} // end of namespace ROOT for class ::TUrl

//______________________________________________________________________________
void TMD5::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMD5.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TMD5::Class(),this);
   } else {
      R__b.WriteClassBuffer(TMD5::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMD5(void *p) {
      return  p ? new(p) ::TMD5 : new ::TMD5;
   }
   static void *newArray_TMD5(Long_t nElements, void *p) {
      return p ? new(p) ::TMD5[nElements] : new ::TMD5[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMD5(void *p) {
      delete ((::TMD5*)p);
   }
   static void deleteArray_TMD5(void *p) {
      delete [] ((::TMD5*)p);
   }
   static void destruct_TMD5(void *p) {
      typedef ::TMD5 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TMD5

//______________________________________________________________________________
void TFileInfo::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileInfo.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileInfo::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileInfo::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileInfo(void *p) {
      return  p ? new(p) ::TFileInfo : new ::TFileInfo;
   }
   static void *newArray_TFileInfo(Long_t nElements, void *p) {
      return p ? new(p) ::TFileInfo[nElements] : new ::TFileInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileInfo(void *p) {
      delete ((::TFileInfo*)p);
   }
   static void deleteArray_TFileInfo(void *p) {
      delete [] ((::TFileInfo*)p);
   }
   static void destruct_TFileInfo(void *p) {
      typedef ::TFileInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileInfo

//______________________________________________________________________________
void TFileInfoMeta::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileInfoMeta.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileInfoMeta::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileInfoMeta::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileInfoMeta(void *p) {
      return  p ? new(p) ::TFileInfoMeta : new ::TFileInfoMeta;
   }
   static void *newArray_TFileInfoMeta(Long_t nElements, void *p) {
      return p ? new(p) ::TFileInfoMeta[nElements] : new ::TFileInfoMeta[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileInfoMeta(void *p) {
      delete ((::TFileInfoMeta*)p);
   }
   static void deleteArray_TFileInfoMeta(void *p) {
      delete [] ((::TFileInfoMeta*)p);
   }
   static void destruct_TFileInfoMeta(void *p) {
      typedef ::TFileInfoMeta current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileInfoMeta

//______________________________________________________________________________
void TFolder::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFolder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFolder::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFolder::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFolder(void *p) {
      return  p ? new(p) ::TFolder : new ::TFolder;
   }
   static void *newArray_TFolder(Long_t nElements, void *p) {
      return p ? new(p) ::TFolder[nElements] : new ::TFolder[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFolder(void *p) {
      delete ((::TFolder*)p);
   }
   static void deleteArray_TFolder(void *p) {
      delete [] ((::TFolder*)p);
   }
   static void destruct_TFolder(void *p) {
      typedef ::TFolder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFolder

namespace ROOT {
   // Wrappers around operator new
   static void *new_TInetAddress(void *p) {
      return  p ? new(p) ::TInetAddress : new ::TInetAddress;
   }
   static void *newArray_TInetAddress(Long_t nElements, void *p) {
      return p ? new(p) ::TInetAddress[nElements] : new ::TInetAddress[nElements];
   }
   // Wrapper around operator delete
   static void delete_TInetAddress(void *p) {
      delete ((::TInetAddress*)p);
   }
   static void deleteArray_TInetAddress(void *p) {
      delete [] ((::TInetAddress*)p);
   }
   static void destruct_TInetAddress(void *p) {
      typedef ::TInetAddress current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TInetAddress(TBuffer &buf, void *obj) {
      ((::TInetAddress*)obj)->::TInetAddress::Streamer(buf);
   }
} // end of namespace ROOT for class ::TInetAddress

//______________________________________________________________________________
void TMacro::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMacro.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TMacro::Class(),this);
   } else {
      R__b.WriteClassBuffer(TMacro::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMacro(void *p) {
      return  p ? new(p) ::TMacro : new ::TMacro;
   }
   static void *newArray_TMacro(Long_t nElements, void *p) {
      return p ? new(p) ::TMacro[nElements] : new ::TMacro[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMacro(void *p) {
      delete ((::TMacro*)p);
   }
   static void deleteArray_TMacro(void *p) {
      delete [] ((::TMacro*)p);
   }
   static void destruct_TMacro(void *p) {
      typedef ::TMacro current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TMacro

//______________________________________________________________________________
void TMemberInspector::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMemberInspector.

   ::Error("TMemberInspector::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMemberInspector(void *p) {
      return  p ? new(p) ::TMemberInspector : new ::TMemberInspector;
   }
   static void *newArray_TMemberInspector(Long_t nElements, void *p) {
      return p ? new(p) ::TMemberInspector[nElements] : new ::TMemberInspector[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMemberInspector(void *p) {
      delete ((::TMemberInspector*)p);
   }
   static void deleteArray_TMemberInspector(void *p) {
      delete [] ((::TMemberInspector*)p);
   }
   static void destruct_TMemberInspector(void *p) {
      typedef ::TMemberInspector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMemberInspector(TBuffer &buf, void *obj) {
      ((::TMemberInspector*)obj)->::TMemberInspector::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMemberInspector

//______________________________________________________________________________
void TMessageHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMessageHandler.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TMessageHandler::Class(),this);
   } else {
      R__b.WriteClassBuffer(TMessageHandler::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TMessageHandler(void *p) {
      delete ((::TMessageHandler*)p);
   }
   static void deleteArray_TMessageHandler(void *p) {
      delete [] ((::TMessageHandler*)p);
   }
   static void destruct_TMessageHandler(void *p) {
      typedef ::TMessageHandler current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TMessageHandler

//______________________________________________________________________________
void TNotifyLinkBase::Streamer(TBuffer &R__b)
{
   // Stream an object of class TNotifyLinkBase.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TNotifyLinkBase::Class(),this);
   } else {
      R__b.WriteClassBuffer(TNotifyLinkBase::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TNotifyLinkBase(void *p) {
      return  p ? new(p) ::TNotifyLinkBase : new ::TNotifyLinkBase;
   }
   static void *newArray_TNotifyLinkBase(Long_t nElements, void *p) {
      return p ? new(p) ::TNotifyLinkBase[nElements] : new ::TNotifyLinkBase[nElements];
   }
   // Wrapper around operator delete
   static void delete_TNotifyLinkBase(void *p) {
      delete ((::TNotifyLinkBase*)p);
   }
   static void deleteArray_TNotifyLinkBase(void *p) {
      delete [] ((::TNotifyLinkBase*)p);
   }
   static void destruct_TNotifyLinkBase(void *p) {
      typedef ::TNotifyLinkBase current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TNotifyLinkBase

//______________________________________________________________________________
void TObjString::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjString.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TObjString::Class(),this);
   } else {
      R__b.WriteClassBuffer(TObjString::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObjString(void *p) {
      return  p ? new(p) ::TObjString : new ::TObjString;
   }
   static void *newArray_TObjString(Long_t nElements, void *p) {
      return p ? new(p) ::TObjString[nElements] : new ::TObjString[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObjString(void *p) {
      delete ((::TObjString*)p);
   }
   static void deleteArray_TObjString(void *p) {
      delete [] ((::TObjString*)p);
   }
   static void destruct_TObjString(void *p) {
      typedef ::TObjString current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TObjString

//______________________________________________________________________________
void TROOT::Streamer(TBuffer &R__b)
{
   // Stream an object of class TROOT.

   TDirectory::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TROOT(void *p) {
      delete ((::TROOT*)p);
   }
   static void deleteArray_TROOT(void *p) {
      delete [] ((::TROOT*)p);
   }
   static void destruct_TROOT(void *p) {
      typedef ::TROOT current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TROOT(TBuffer &buf, void *obj) {
      ((::TROOT*)obj)->::TROOT::Streamer(buf);
   }
} // end of namespace ROOT for class ::TROOT

//______________________________________________________________________________
template <> void TParameter<bool>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<bool>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<bool>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<bool>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEboolgR(void *p) {
      return  p ? new(p) ::TParameter<bool> : new ::TParameter<bool>;
   }
   static void *newArray_TParameterlEboolgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<bool>[nElements] : new ::TParameter<bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEboolgR(void *p) {
      delete ((::TParameter<bool>*)p);
   }
   static void deleteArray_TParameterlEboolgR(void *p) {
      delete [] ((::TParameter<bool>*)p);
   }
   static void destruct_TParameterlEboolgR(void *p) {
      typedef ::TParameter<bool> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlEboolgR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<bool>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<bool>

//______________________________________________________________________________
template <> void TParameter<Long64_t>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<Long64_t>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<Long64_t>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<Long64_t>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlELong64_tgR(void *p) {
      return  p ? new(p) ::TParameter<Long64_t> : new ::TParameter<Long64_t>;
   }
   static void *newArray_TParameterlELong64_tgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<Long64_t>[nElements] : new ::TParameter<Long64_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlELong64_tgR(void *p) {
      delete ((::TParameter<Long64_t>*)p);
   }
   static void deleteArray_TParameterlELong64_tgR(void *p) {
      delete [] ((::TParameter<Long64_t>*)p);
   }
   static void destruct_TParameterlELong64_tgR(void *p) {
      typedef ::TParameter<Long64_t> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlELong64_tgR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<Long64_t>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<Long64_t>

//______________________________________________________________________________
template <> void TParameter<long>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<long>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<long>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<long>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlElonggR(void *p) {
      return  p ? new(p) ::TParameter<long> : new ::TParameter<long>;
   }
   static void *newArray_TParameterlElonggR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<long>[nElements] : new ::TParameter<long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlElonggR(void *p) {
      delete ((::TParameter<long>*)p);
   }
   static void deleteArray_TParameterlElonggR(void *p) {
      delete [] ((::TParameter<long>*)p);
   }
   static void destruct_TParameterlElonggR(void *p) {
      typedef ::TParameter<long> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlElonggR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<long>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<long>

//______________________________________________________________________________
template <> void TParameter<int>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<int>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<int>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<int>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEintgR(void *p) {
      return  p ? new(p) ::TParameter<int> : new ::TParameter<int>;
   }
   static void *newArray_TParameterlEintgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<int>[nElements] : new ::TParameter<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEintgR(void *p) {
      delete ((::TParameter<int>*)p);
   }
   static void deleteArray_TParameterlEintgR(void *p) {
      delete [] ((::TParameter<int>*)p);
   }
   static void destruct_TParameterlEintgR(void *p) {
      typedef ::TParameter<int> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlEintgR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<int>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<int>

//______________________________________________________________________________
template <> void TParameter<double>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<double>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<double>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<double>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEdoublegR(void *p) {
      return  p ? new(p) ::TParameter<double> : new ::TParameter<double>;
   }
   static void *newArray_TParameterlEdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<double>[nElements] : new ::TParameter<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEdoublegR(void *p) {
      delete ((::TParameter<double>*)p);
   }
   static void deleteArray_TParameterlEdoublegR(void *p) {
      delete [] ((::TParameter<double>*)p);
   }
   static void destruct_TParameterlEdoublegR(void *p) {
      typedef ::TParameter<double> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlEdoublegR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<double>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<double>

//______________________________________________________________________________
template <> void TParameter<float>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<float>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<float>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<float>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEfloatgR(void *p) {
      return  p ? new(p) ::TParameter<float> : new ::TParameter<float>;
   }
   static void *newArray_TParameterlEfloatgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<float>[nElements] : new ::TParameter<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEfloatgR(void *p) {
      delete ((::TParameter<float>*)p);
   }
   static void deleteArray_TParameterlEfloatgR(void *p) {
      delete [] ((::TParameter<float>*)p);
   }
   static void destruct_TParameterlEfloatgR(void *p) {
      typedef ::TParameter<float> current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TParameterlEfloatgR(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TParameter<float>*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TParameter<float>

//______________________________________________________________________________
void TMethodCall::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMethodCall.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMethodCall(void *p) {
      return  p ? new(p) ::TMethodCall : new ::TMethodCall;
   }
   static void *newArray_TMethodCall(Long_t nElements, void *p) {
      return p ? new(p) ::TMethodCall[nElements] : new ::TMethodCall[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMethodCall(void *p) {
      delete ((::TMethodCall*)p);
   }
   static void deleteArray_TMethodCall(void *p) {
      delete [] ((::TMethodCall*)p);
   }
   static void destruct_TMethodCall(void *p) {
      typedef ::TMethodCall current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMethodCall(TBuffer &buf, void *obj) {
      ((::TMethodCall*)obj)->::TMethodCall::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMethodCall

//______________________________________________________________________________
void TPluginHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TPluginHandler.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      fBase.Streamer(R__b);
      fRegexp.Streamer(R__b);
      fClass.Streamer(R__b);
      fPlugin.Streamer(R__b);
      fCtor.Streamer(R__b);
      fOrigin.Streamer(R__b);
      R__b >> fIsMacro;
      R__b >> fIsGlobal;
      R__b.CheckByteCount(R__s, R__c, TPluginHandler::IsA());
   } else {
      R__c = R__b.WriteVersion(TPluginHandler::IsA(), kTRUE);
      TObject::Streamer(R__b);
      fBase.Streamer(R__b);
      fRegexp.Streamer(R__b);
      fClass.Streamer(R__b);
      fPlugin.Streamer(R__b);
      fCtor.Streamer(R__b);
      fOrigin.Streamer(R__b);
      R__b << fIsMacro;
      R__b << fIsGlobal;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrapper around a custom streamer member function.
   static void streamer_TPluginHandler(TBuffer &buf, void *obj) {
      ((::TPluginHandler*)obj)->::TPluginHandler::Streamer(buf);
   }
} // end of namespace ROOT for class ::TPluginHandler

//______________________________________________________________________________
void TPluginManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class TPluginManager.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      R__b >> fHandlers;
      R__b.CheckByteCount(R__s, R__c, TPluginManager::IsA());
   } else {
      R__c = R__b.WriteVersion(TPluginManager::IsA(), kTRUE);
      TObject::Streamer(R__b);
      R__b << fHandlers;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TPluginManager(void *p) {
      return  p ? new(p) ::TPluginManager : new ::TPluginManager;
   }
   static void *newArray_TPluginManager(Long_t nElements, void *p) {
      return p ? new(p) ::TPluginManager[nElements] : new ::TPluginManager[nElements];
   }
   // Wrapper around operator delete
   static void delete_TPluginManager(void *p) {
      delete ((::TPluginManager*)p);
   }
   static void deleteArray_TPluginManager(void *p) {
      delete [] ((::TPluginManager*)p);
   }
   static void destruct_TPluginManager(void *p) {
      typedef ::TPluginManager current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TPluginManager(TBuffer &buf, void *obj) {
      ((::TPluginManager*)obj)->::TPluginManager::Streamer(buf);
   }
} // end of namespace ROOT for class ::TPluginManager

namespace ROOT {
   // Wrappers around operator new
   static void *new_TPoint(void *p) {
      return  p ? new(p) ::TPoint : new ::TPoint;
   }
   static void *newArray_TPoint(Long_t nElements, void *p) {
      return p ? new(p) ::TPoint[nElements] : new ::TPoint[nElements];
   }
   // Wrapper around operator delete
   static void delete_TPoint(void *p) {
      delete ((::TPoint*)p);
   }
   static void deleteArray_TPoint(void *p) {
      delete [] ((::TPoint*)p);
   }
   static void destruct_TPoint(void *p) {
      typedef ::TPoint current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TPoint

//______________________________________________________________________________
void TArray::Streamer(TBuffer &R__b)
{
   // Stream an object of class TArray.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fN;
      R__b.CheckByteCount(R__s, R__c, TArray::IsA());
   } else {
      R__c = R__b.WriteVersion(TArray::IsA(), kTRUE);
      R__b << fN;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TArray(void *p) {
      delete ((::TArray*)p);
   }
   static void deleteArray_TArray(void *p) {
      delete [] ((::TArray*)p);
   }
   static void destruct_TArray(void *p) {
      typedef ::TArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArray(TBuffer &buf, void *obj) {
      ((::TArray*)obj)->::TArray::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArray

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayI(void *p) {
      return  p ? new(p) ::TArrayI : new ::TArrayI;
   }
   static void *newArray_TArrayI(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayI[nElements] : new ::TArrayI[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayI(void *p) {
      delete ((::TArrayI*)p);
   }
   static void deleteArray_TArrayI(void *p) {
      delete [] ((::TArrayI*)p);
   }
   static void destruct_TArrayI(void *p) {
      typedef ::TArrayI current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayI(TBuffer &buf, void *obj) {
      ((::TArrayI*)obj)->::TArrayI::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayI

//______________________________________________________________________________
void TPRegexp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TPRegexp.

   ::Error("TPRegexp::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TPRegexp(void *p) {
      return  p ? new(p) ::TPRegexp : new ::TPRegexp;
   }
   static void *newArray_TPRegexp(Long_t nElements, void *p) {
      return p ? new(p) ::TPRegexp[nElements] : new ::TPRegexp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TPRegexp(void *p) {
      delete ((::TPRegexp*)p);
   }
   static void deleteArray_TPRegexp(void *p) {
      delete [] ((::TPRegexp*)p);
   }
   static void destruct_TPRegexp(void *p) {
      typedef ::TPRegexp current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TPRegexp(TBuffer &buf, void *obj) {
      ((::TPRegexp*)obj)->::TPRegexp::Streamer(buf);
   }
} // end of namespace ROOT for class ::TPRegexp

//______________________________________________________________________________
void TPMERegexp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TPMERegexp.

   TPRegexp::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TPMERegexp(void *p) {
      return  p ? new(p) ::TPMERegexp : new ::TPMERegexp;
   }
   static void *newArray_TPMERegexp(Long_t nElements, void *p) {
      return p ? new(p) ::TPMERegexp[nElements] : new ::TPMERegexp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TPMERegexp(void *p) {
      delete ((::TPMERegexp*)p);
   }
   static void deleteArray_TPMERegexp(void *p) {
      delete [] ((::TPMERegexp*)p);
   }
   static void destruct_TPMERegexp(void *p) {
      typedef ::TPMERegexp current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TPMERegexp(TBuffer &buf, void *obj) {
      ((::TPMERegexp*)obj)->::TPMERegexp::Streamer(buf);
   }
} // end of namespace ROOT for class ::TPMERegexp

//______________________________________________________________________________
void TStringToken::Streamer(TBuffer &R__b)
{
   // Stream an object of class TStringToken.

   TString::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TStringToken(void *p) {
      delete ((::TStringToken*)p);
   }
   static void deleteArray_TStringToken(void *p) {
      delete [] ((::TStringToken*)p);
   }
   static void destruct_TStringToken(void *p) {
      typedef ::TStringToken current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStringToken(TBuffer &buf, void *obj) {
      ((::TStringToken*)obj)->::TStringToken::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStringToken

//______________________________________________________________________________
void TProcessID::Streamer(TBuffer &R__b)
{
   // Stream an object of class TProcessID.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TProcessID::Class(),this);
   } else {
      R__b.WriteClassBuffer(TProcessID::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TProcessID(void *p) {
      return  p ? new(p) ::TProcessID : new ::TProcessID;
   }
   static void *newArray_TProcessID(Long_t nElements, void *p) {
      return p ? new(p) ::TProcessID[nElements] : new ::TProcessID[nElements];
   }
   // Wrapper around operator delete
   static void delete_TProcessID(void *p) {
      delete ((::TProcessID*)p);
   }
   static void deleteArray_TProcessID(void *p) {
      delete [] ((::TProcessID*)p);
   }
   static void destruct_TProcessID(void *p) {
      typedef ::TProcessID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TProcessID

//______________________________________________________________________________
void TProcessUUID::Streamer(TBuffer &R__b)
{
   // Stream an object of class TProcessUUID.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TProcessUUID::Class(),this);
   } else {
      R__b.WriteClassBuffer(TProcessUUID::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TProcessUUID(void *p) {
      return  p ? new(p) ::TProcessUUID : new ::TProcessUUID;
   }
   static void *newArray_TProcessUUID(Long_t nElements, void *p) {
      return p ? new(p) ::TProcessUUID[nElements] : new ::TProcessUUID[nElements];
   }
   // Wrapper around operator delete
   static void delete_TProcessUUID(void *p) {
      delete ((::TProcessUUID*)p);
   }
   static void deleteArray_TProcessUUID(void *p) {
      delete [] ((::TProcessUUID*)p);
   }
   static void destruct_TProcessUUID(void *p) {
      typedef ::TProcessUUID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TProcessUUID

//______________________________________________________________________________
void TQClass::Streamer(TBuffer &R__b)
{
   // Stream an object of class TQClass.

   TQObject::Streamer(R__b);
   TClass::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TQClass(void *p) {
      delete ((::TQClass*)p);
   }
   static void deleteArray_TQClass(void *p) {
      delete [] ((::TQClass*)p);
   }
   static void destruct_TQClass(void *p) {
      typedef ::TQClass current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQClass(TBuffer &buf, void *obj) {
      ((::TQClass*)obj)->::TQClass::Streamer(buf);
   }
} // end of namespace ROOT for class ::TQClass

//______________________________________________________________________________
void TQCommand::Streamer(TBuffer &R__b)
{
   // Stream an object of class TQCommand.

   TList::Streamer(R__b);
   TQObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TQCommand(void *p) {
      return  p ? new(p) ::TQCommand : new ::TQCommand;
   }
   static void *newArray_TQCommand(Long_t nElements, void *p) {
      return p ? new(p) ::TQCommand[nElements] : new ::TQCommand[nElements];
   }
   // Wrapper around operator delete
   static void delete_TQCommand(void *p) {
      delete ((::TQCommand*)p);
   }
   static void deleteArray_TQCommand(void *p) {
      delete [] ((::TQCommand*)p);
   }
   static void destruct_TQCommand(void *p) {
      typedef ::TQCommand current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQCommand(TBuffer &buf, void *obj) {
      ((::TQCommand*)obj)->::TQCommand::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t merge_TQCommand(void *obj,TCollection *coll,TFileMergeInfo *info) {
      return ((::TQCommand*)obj)->Merge(coll,info);
   }
} // end of namespace ROOT for class ::TQCommand

//______________________________________________________________________________
void TQUndoManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class TQUndoManager.

   TQCommand::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TQUndoManager(void *p) {
      return  p ? new(p) ::TQUndoManager : new ::TQUndoManager;
   }
   static void *newArray_TQUndoManager(Long_t nElements, void *p) {
      return p ? new(p) ::TQUndoManager[nElements] : new ::TQUndoManager[nElements];
   }
   // Wrapper around operator delete
   static void delete_TQUndoManager(void *p) {
      delete ((::TQUndoManager*)p);
   }
   static void deleteArray_TQUndoManager(void *p) {
      delete [] ((::TQUndoManager*)p);
   }
   static void destruct_TQUndoManager(void *p) {
      typedef ::TQUndoManager current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQUndoManager(TBuffer &buf, void *obj) {
      ((::TQUndoManager*)obj)->::TQUndoManager::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t merge_TQUndoManager(void *obj,TCollection *coll,TFileMergeInfo *info) {
      return ((::TQUndoManager*)obj)->Merge(coll,info);
   }
} // end of namespace ROOT for class ::TQUndoManager

//______________________________________________________________________________
void TQConnection::Streamer(TBuffer &R__b)
{
   // Stream an object of class TQConnection.

   TQObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TQConnection(void *p) {
      return  p ? new(p) ::TQConnection : new ::TQConnection;
   }
   static void *newArray_TQConnection(Long_t nElements, void *p) {
      return p ? new(p) ::TQConnection[nElements] : new ::TQConnection[nElements];
   }
   // Wrapper around operator delete
   static void delete_TQConnection(void *p) {
      delete ((::TQConnection*)p);
   }
   static void deleteArray_TQConnection(void *p) {
      delete [] ((::TQConnection*)p);
   }
   static void destruct_TQConnection(void *p) {
      typedef ::TQConnection current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TQConnection(TBuffer &buf, void *obj) {
      ((::TQConnection*)obj)->::TQConnection::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TQConnection(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TQConnection*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TQConnection

//______________________________________________________________________________
void TSysEvtHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSysEvtHandler.

   TObject::Streamer(R__b);
   TQObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TSysEvtHandler(void *p) {
      delete ((::TSysEvtHandler*)p);
   }
   static void deleteArray_TSysEvtHandler(void *p) {
      delete [] ((::TSysEvtHandler*)p);
   }
   static void destruct_TSysEvtHandler(void *p) {
      typedef ::TSysEvtHandler current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TSysEvtHandler(TBuffer &buf, void *obj) {
      ((::TSysEvtHandler*)obj)->::TSysEvtHandler::Streamer(buf);
   }
} // end of namespace ROOT for class ::TSysEvtHandler

//______________________________________________________________________________
void TFileHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileHandler.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileHandler::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileHandler::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TFileHandler(void *p) {
      delete ((::TFileHandler*)p);
   }
   static void deleteArray_TFileHandler(void *p) {
      delete [] ((::TFileHandler*)p);
   }
   static void destruct_TFileHandler(void *p) {
      typedef ::TFileHandler current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileHandler

//______________________________________________________________________________
void TSignalHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSignalHandler.

   TSysEvtHandler::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TSignalHandler(void *p) {
      delete ((::TSignalHandler*)p);
   }
   static void deleteArray_TSignalHandler(void *p) {
      delete [] ((::TSignalHandler*)p);
   }
   static void destruct_TSignalHandler(void *p) {
      typedef ::TSignalHandler current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TSignalHandler(TBuffer &buf, void *obj) {
      ((::TSignalHandler*)obj)->::TSignalHandler::Streamer(buf);
   }
} // end of namespace ROOT for class ::TSignalHandler

//______________________________________________________________________________
void TStdExceptionHandler::Streamer(TBuffer &R__b)
{
   // Stream an object of class TStdExceptionHandler.

   TSysEvtHandler::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TStdExceptionHandler(void *p) {
      delete ((::TStdExceptionHandler*)p);
   }
   static void deleteArray_TStdExceptionHandler(void *p) {
      delete [] ((::TStdExceptionHandler*)p);
   }
   static void destruct_TStdExceptionHandler(void *p) {
      typedef ::TStdExceptionHandler current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStdExceptionHandler(TBuffer &buf, void *obj) {
      ((::TStdExceptionHandler*)obj)->::TStdExceptionHandler::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStdExceptionHandler

//______________________________________________________________________________
void TTime::Streamer(TBuffer &R__b)
{
   // Stream an object of class TTime.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fMilliSec;
      R__b.CheckByteCount(R__s, R__c, TTime::IsA());
   } else {
      R__c = R__b.WriteVersion(TTime::IsA(), kTRUE);
      R__b << fMilliSec;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TTime(void *p) {
      return  p ? new(p) ::TTime : new ::TTime;
   }
   static void *newArray_TTime(Long_t nElements, void *p) {
      return p ? new(p) ::TTime[nElements] : new ::TTime[nElements];
   }
   // Wrapper around operator delete
   static void delete_TTime(void *p) {
      delete ((::TTime*)p);
   }
   static void deleteArray_TTime(void *p) {
      delete [] ((::TTime*)p);
   }
   static void destruct_TTime(void *p) {
      typedef ::TTime current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TTime(TBuffer &buf, void *obj) {
      ((::TTime*)obj)->::TTime::Streamer(buf);
   }
} // end of namespace ROOT for class ::TTime

//______________________________________________________________________________
void TTimer::Streamer(TBuffer &R__b)
{
   // Stream an object of class TTimer.

   TSysEvtHandler::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TTimer(void *p) {
      return  p ? new(p) ::TTimer : new ::TTimer;
   }
   static void *newArray_TTimer(Long_t nElements, void *p) {
      return p ? new(p) ::TTimer[nElements] : new ::TTimer[nElements];
   }
   // Wrapper around operator delete
   static void delete_TTimer(void *p) {
      delete ((::TTimer*)p);
   }
   static void deleteArray_TTimer(void *p) {
      delete [] ((::TTimer*)p);
   }
   static void destruct_TTimer(void *p) {
      typedef ::TTimer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TTimer(TBuffer &buf, void *obj) {
      ((::TTimer*)obj)->::TTimer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TTimer

namespace ROOT {
   // Wrappers around operator new
   static void *new_FileStat_t(void *p) {
      return  p ? new(p) ::FileStat_t : new ::FileStat_t;
   }
   static void *newArray_FileStat_t(Long_t nElements, void *p) {
      return p ? new(p) ::FileStat_t[nElements] : new ::FileStat_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_FileStat_t(void *p) {
      delete ((::FileStat_t*)p);
   }
   static void deleteArray_FileStat_t(void *p) {
      delete [] ((::FileStat_t*)p);
   }
   static void destruct_FileStat_t(void *p) {
      typedef ::FileStat_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FileStat_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_UserGroup_t(void *p) {
      return  p ? new(p) ::UserGroup_t : new ::UserGroup_t;
   }
   static void *newArray_UserGroup_t(Long_t nElements, void *p) {
      return p ? new(p) ::UserGroup_t[nElements] : new ::UserGroup_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_UserGroup_t(void *p) {
      delete ((::UserGroup_t*)p);
   }
   static void deleteArray_UserGroup_t(void *p) {
      delete [] ((::UserGroup_t*)p);
   }
   static void destruct_UserGroup_t(void *p) {
      typedef ::UserGroup_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::UserGroup_t

//______________________________________________________________________________
void SysInfo_t::Streamer(TBuffer &R__b)
{
   // Stream an object of class SysInfo_t.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      fOS.Streamer(R__b);
      fModel.Streamer(R__b);
      fCpuType.Streamer(R__b);
      R__b >> fCpus;
      R__b >> fCpuSpeed;
      R__b >> fBusSpeed;
      R__b >> fL2Cache;
      R__b >> fPhysRam;
      R__b.CheckByteCount(R__s, R__c, SysInfo_t::IsA());
   } else {
      R__c = R__b.WriteVersion(SysInfo_t::IsA(), kTRUE);
      fOS.Streamer(R__b);
      fModel.Streamer(R__b);
      fCpuType.Streamer(R__b);
      R__b << fCpus;
      R__b << fCpuSpeed;
      R__b << fBusSpeed;
      R__b << fL2Cache;
      R__b << fPhysRam;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SysInfo_t(void *p) {
      return  p ? new(p) ::SysInfo_t : new ::SysInfo_t;
   }
   static void *newArray_SysInfo_t(Long_t nElements, void *p) {
      return p ? new(p) ::SysInfo_t[nElements] : new ::SysInfo_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SysInfo_t(void *p) {
      delete ((::SysInfo_t*)p);
   }
   static void deleteArray_SysInfo_t(void *p) {
      delete [] ((::SysInfo_t*)p);
   }
   static void destruct_SysInfo_t(void *p) {
      typedef ::SysInfo_t current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_SysInfo_t(TBuffer &buf, void *obj) {
      ((::SysInfo_t*)obj)->::SysInfo_t::Streamer(buf);
   }
} // end of namespace ROOT for class ::SysInfo_t

//______________________________________________________________________________
void CpuInfo_t::Streamer(TBuffer &R__b)
{
   // Stream an object of class CpuInfo_t.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fLoad1m;
      R__b >> fLoad5m;
      R__b >> fLoad15m;
      R__b >> fUser;
      R__b >> fSys;
      R__b >> fTotal;
      R__b >> fIdle;
      R__b.CheckByteCount(R__s, R__c, CpuInfo_t::IsA());
   } else {
      R__c = R__b.WriteVersion(CpuInfo_t::IsA(), kTRUE);
      R__b << fLoad1m;
      R__b << fLoad5m;
      R__b << fLoad15m;
      R__b << fUser;
      R__b << fSys;
      R__b << fTotal;
      R__b << fIdle;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_CpuInfo_t(void *p) {
      return  p ? new(p) ::CpuInfo_t : new ::CpuInfo_t;
   }
   static void *newArray_CpuInfo_t(Long_t nElements, void *p) {
      return p ? new(p) ::CpuInfo_t[nElements] : new ::CpuInfo_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_CpuInfo_t(void *p) {
      delete ((::CpuInfo_t*)p);
   }
   static void deleteArray_CpuInfo_t(void *p) {
      delete [] ((::CpuInfo_t*)p);
   }
   static void destruct_CpuInfo_t(void *p) {
      typedef ::CpuInfo_t current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_CpuInfo_t(TBuffer &buf, void *obj) {
      ((::CpuInfo_t*)obj)->::CpuInfo_t::Streamer(buf);
   }
} // end of namespace ROOT for class ::CpuInfo_t

//______________________________________________________________________________
void MemInfo_t::Streamer(TBuffer &R__b)
{
   // Stream an object of class MemInfo_t.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fMemTotal;
      R__b >> fMemUsed;
      R__b >> fMemFree;
      R__b >> fSwapTotal;
      R__b >> fSwapUsed;
      R__b >> fSwapFree;
      R__b.CheckByteCount(R__s, R__c, MemInfo_t::IsA());
   } else {
      R__c = R__b.WriteVersion(MemInfo_t::IsA(), kTRUE);
      R__b << fMemTotal;
      R__b << fMemUsed;
      R__b << fMemFree;
      R__b << fSwapTotal;
      R__b << fSwapUsed;
      R__b << fSwapFree;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_MemInfo_t(void *p) {
      return  p ? new(p) ::MemInfo_t : new ::MemInfo_t;
   }
   static void *newArray_MemInfo_t(Long_t nElements, void *p) {
      return p ? new(p) ::MemInfo_t[nElements] : new ::MemInfo_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_MemInfo_t(void *p) {
      delete ((::MemInfo_t*)p);
   }
   static void deleteArray_MemInfo_t(void *p) {
      delete [] ((::MemInfo_t*)p);
   }
   static void destruct_MemInfo_t(void *p) {
      typedef ::MemInfo_t current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_MemInfo_t(TBuffer &buf, void *obj) {
      ((::MemInfo_t*)obj)->::MemInfo_t::Streamer(buf);
   }
} // end of namespace ROOT for class ::MemInfo_t

//______________________________________________________________________________
void ProcInfo_t::Streamer(TBuffer &R__b)
{
   // Stream an object of class ProcInfo_t.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fCpuUser;
      R__b >> fCpuSys;
      R__b >> fMemResident;
      R__b >> fMemVirtual;
      R__b.CheckByteCount(R__s, R__c, ProcInfo_t::IsA());
   } else {
      R__c = R__b.WriteVersion(ProcInfo_t::IsA(), kTRUE);
      R__b << fCpuUser;
      R__b << fCpuSys;
      R__b << fMemResident;
      R__b << fMemVirtual;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ProcInfo_t(void *p) {
      return  p ? new(p) ::ProcInfo_t : new ::ProcInfo_t;
   }
   static void *newArray_ProcInfo_t(Long_t nElements, void *p) {
      return p ? new(p) ::ProcInfo_t[nElements] : new ::ProcInfo_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ProcInfo_t(void *p) {
      delete ((::ProcInfo_t*)p);
   }
   static void deleteArray_ProcInfo_t(void *p) {
      delete [] ((::ProcInfo_t*)p);
   }
   static void destruct_ProcInfo_t(void *p) {
      typedef ::ProcInfo_t current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_ProcInfo_t(TBuffer &buf, void *obj) {
      ((::ProcInfo_t*)obj)->::ProcInfo_t::Streamer(buf);
   }
} // end of namespace ROOT for class ::ProcInfo_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_RedirectHandle_t(void *p) {
      return  p ? new(p) ::RedirectHandle_t : new ::RedirectHandle_t;
   }
   static void *newArray_RedirectHandle_t(Long_t nElements, void *p) {
      return p ? new(p) ::RedirectHandle_t[nElements] : new ::RedirectHandle_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_RedirectHandle_t(void *p) {
      delete ((::RedirectHandle_t*)p);
   }
   static void deleteArray_RedirectHandle_t(void *p) {
      delete [] ((::RedirectHandle_t*)p);
   }
   static void destruct_RedirectHandle_t(void *p) {
      typedef ::RedirectHandle_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RedirectHandle_t

//______________________________________________________________________________
void TProcessEventTimer::Streamer(TBuffer &R__b)
{
   // Stream an object of class TProcessEventTimer.

   TTimer::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TProcessEventTimer(void *p) {
      delete ((::TProcessEventTimer*)p);
   }
   static void deleteArray_TProcessEventTimer(void *p) {
      delete [] ((::TProcessEventTimer*)p);
   }
   static void destruct_TProcessEventTimer(void *p) {
      typedef ::TProcessEventTimer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TProcessEventTimer(TBuffer &buf, void *obj) {
      ((::TProcessEventTimer*)obj)->::TProcessEventTimer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TProcessEventTimer

//______________________________________________________________________________
void TSystem::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSystem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TSystem::Class(),this);
   } else {
      R__b.WriteClassBuffer(TSystem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TSystem(void *p) {
      return  p ? new(p) ::TSystem : new ::TSystem;
   }
   static void *newArray_TSystem(Long_t nElements, void *p) {
      return p ? new(p) ::TSystem[nElements] : new ::TSystem[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSystem(void *p) {
      delete ((::TSystem*)p);
   }
   static void deleteArray_TSystem(void *p) {
      delete [] ((::TSystem*)p);
   }
   static void destruct_TSystem(void *p) {
      typedef ::TSystem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TSystem

//______________________________________________________________________________
void TRedirectOutputGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRedirectOutputGuard.

   ::Error("TRedirectOutputGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TRedirectOutputGuard(void *p) {
      delete ((::TRedirectOutputGuard*)p);
   }
   static void deleteArray_TRedirectOutputGuard(void *p) {
      delete [] ((::TRedirectOutputGuard*)p);
   }
   static void destruct_TRedirectOutputGuard(void *p) {
      typedef ::TRedirectOutputGuard current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRedirectOutputGuard(TBuffer &buf, void *obj) {
      ((::TRedirectOutputGuard*)obj)->::TRedirectOutputGuard::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRedirectOutputGuard

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRefCnt(void *p) {
      return  p ? new(p) ::TRefCnt : new ::TRefCnt;
   }
   static void *newArray_TRefCnt(Long_t nElements, void *p) {
      return p ? new(p) ::TRefCnt[nElements] : new ::TRefCnt[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRefCnt(void *p) {
      delete ((::TRefCnt*)p);
   }
   static void deleteArray_TRefCnt(void *p) {
      delete [] ((::TRefCnt*)p);
   }
   static void destruct_TRefCnt(void *p) {
      typedef ::TRefCnt current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRefCnt

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRef(void *p) {
      return  p ? new(p) ::TRef : new ::TRef;
   }
   static void *newArray_TRef(Long_t nElements, void *p) {
      return p ? new(p) ::TRef[nElements] : new ::TRef[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRef(void *p) {
      delete ((::TRef*)p);
   }
   static void deleteArray_TRef(void *p) {
      delete [] ((::TRef*)p);
   }
   static void destruct_TRef(void *p) {
      typedef ::TRef current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRef(TBuffer &buf, void *obj) {
      ((::TRef*)obj)->::TRef::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRef

//______________________________________________________________________________
void TRegexp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRegexp.

   ::Error("TRegexp::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TRegexp(void *p) {
      delete ((::TRegexp*)p);
   }
   static void deleteArray_TRegexp(void *p) {
      delete [] ((::TRegexp*)p);
   }
   static void destruct_TRegexp(void *p) {
      typedef ::TRegexp current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRegexp(TBuffer &buf, void *obj) {
      ((::TRegexp*)obj)->::TRegexp::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRegexp

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRemoteObject(void *p) {
      return  p ? new(p) ::TRemoteObject : new ::TRemoteObject;
   }
   static void *newArray_TRemoteObject(Long_t nElements, void *p) {
      return p ? new(p) ::TRemoteObject[nElements] : new ::TRemoteObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRemoteObject(void *p) {
      delete ((::TRemoteObject*)p);
   }
   static void deleteArray_TRemoteObject(void *p) {
      delete [] ((::TRemoteObject*)p);
   }
   static void destruct_TRemoteObject(void *p) {
      typedef ::TRemoteObject current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRemoteObject(TBuffer &buf, void *obj) {
      ((::TRemoteObject*)obj)->::TRemoteObject::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRemoteObject

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRootIOCtor(void *p) {
      return  p ? new(p) ::TRootIOCtor : new ::TRootIOCtor;
   }
   static void *newArray_TRootIOCtor(Long_t nElements, void *p) {
      return p ? new(p) ::TRootIOCtor[nElements] : new ::TRootIOCtor[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRootIOCtor(void *p) {
      delete ((::TRootIOCtor*)p);
   }
   static void deleteArray_TRootIOCtor(void *p) {
      delete [] ((::TRootIOCtor*)p);
   }
   static void destruct_TRootIOCtor(void *p) {
      typedef ::TRootIOCtor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRootIOCtor

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStringLong(void *p) {
      return  p ? new(p) ::TStringLong : new ::TStringLong;
   }
   static void *newArray_TStringLong(Long_t nElements, void *p) {
      return p ? new(p) ::TStringLong[nElements] : new ::TStringLong[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStringLong(void *p) {
      delete ((::TStringLong*)p);
   }
   static void deleteArray_TStringLong(void *p) {
      delete [] ((::TStringLong*)p);
   }
   static void destruct_TStringLong(void *p) {
      typedef ::TStringLong current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStringLong(TBuffer &buf, void *obj) {
      ((::TStringLong*)obj)->::TStringLong::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStringLong

//______________________________________________________________________________
void TStyle::Streamer(TBuffer &R__b)
{
   // Stream an object of class TStyle.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TStyle::Class(),this);
   } else {
      R__b.WriteClassBuffer(TStyle::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStyle(void *p) {
      return  p ? new(p) ::TStyle : new ::TStyle;
   }
   static void *newArray_TStyle(Long_t nElements, void *p) {
      return p ? new(p) ::TStyle[nElements] : new ::TStyle[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStyle(void *p) {
      delete ((::TStyle*)p);
   }
   static void deleteArray_TStyle(void *p) {
      delete [] ((::TStyle*)p);
   }
   static void destruct_TStyle(void *p) {
      typedef ::TStyle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TStyle

//______________________________________________________________________________
void TSystemFile::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSystemFile.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TSystemFile::Class(),this);
   } else {
      R__b.WriteClassBuffer(TSystemFile::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TSystemFile(void *p) {
      return  p ? new(p) ::TSystemFile : new ::TSystemFile;
   }
   static void *newArray_TSystemFile(Long_t nElements, void *p) {
      return p ? new(p) ::TSystemFile[nElements] : new ::TSystemFile[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSystemFile(void *p) {
      delete ((::TSystemFile*)p);
   }
   static void deleteArray_TSystemFile(void *p) {
      delete [] ((::TSystemFile*)p);
   }
   static void destruct_TSystemFile(void *p) {
      typedef ::TSystemFile current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TSystemFile

//______________________________________________________________________________
void TSystemDirectory::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSystemDirectory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TSystemDirectory::Class(),this);
   } else {
      R__b.WriteClassBuffer(TSystemDirectory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TSystemDirectory(void *p) {
      return  p ? new(p) ::TSystemDirectory : new ::TSystemDirectory;
   }
   static void *newArray_TSystemDirectory(Long_t nElements, void *p) {
      return p ? new(p) ::TSystemDirectory[nElements] : new ::TSystemDirectory[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSystemDirectory(void *p) {
      delete ((::TSystemDirectory*)p);
   }
   static void deleteArray_TSystemDirectory(void *p) {
      delete [] ((::TSystemDirectory*)p);
   }
   static void destruct_TSystemDirectory(void *p) {
      typedef ::TSystemDirectory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TSystemDirectory

//______________________________________________________________________________
void TTask::Streamer(TBuffer &R__b)
{
   // Stream an object of class TTask.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TTask::Class(),this);
   } else {
      R__b.WriteClassBuffer(TTask::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TTask(void *p) {
      return  p ? new(p) ::TTask : new ::TTask;
   }
   static void *newArray_TTask(Long_t nElements, void *p) {
      return p ? new(p) ::TTask[nElements] : new ::TTask[nElements];
   }
   // Wrapper around operator delete
   static void delete_TTask(void *p) {
      delete ((::TTask*)p);
   }
   static void deleteArray_TTask(void *p) {
      delete [] ((::TTask*)p);
   }
   static void destruct_TTask(void *p) {
      typedef ::TTask current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TTask

//______________________________________________________________________________
void TTimeStamp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TTimeStamp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TTimeStamp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TTimeStamp::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TTimeStamp(void *p) {
      return  p ? new(p) ::TTimeStamp : new ::TTimeStamp;
   }
   static void *newArray_TTimeStamp(Long_t nElements, void *p) {
      return p ? new(p) ::TTimeStamp[nElements] : new ::TTimeStamp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TTimeStamp(void *p) {
      delete ((::TTimeStamp*)p);
   }
   static void deleteArray_TTimeStamp(void *p) {
      delete [] ((::TTimeStamp*)p);
   }
   static void destruct_TTimeStamp(void *p) {
      typedef ::TTimeStamp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TTimeStamp

//______________________________________________________________________________
void TUri::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUri.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      fScheme.Streamer(R__b);
      fUserinfo.Streamer(R__b);
      fHost.Streamer(R__b);
      fPort.Streamer(R__b);
      fPath.Streamer(R__b);
      fQuery.Streamer(R__b);
      fFragment.Streamer(R__b);
      R__b >> fHasScheme;
      R__b >> fHasUserinfo;
      R__b >> fHasHost;
      R__b >> fHasPort;
      R__b >> fHasPath;
      R__b >> fHasQuery;
      R__b >> fHasFragment;
      R__b.CheckByteCount(R__s, R__c, TUri::IsA());
   } else {
      R__c = R__b.WriteVersion(TUri::IsA(), kTRUE);
      TObject::Streamer(R__b);
      fScheme.Streamer(R__b);
      fUserinfo.Streamer(R__b);
      fHost.Streamer(R__b);
      fPort.Streamer(R__b);
      fPath.Streamer(R__b);
      fQuery.Streamer(R__b);
      fFragment.Streamer(R__b);
      R__b << fHasScheme;
      R__b << fHasUserinfo;
      R__b << fHasHost;
      R__b << fHasPort;
      R__b << fHasPath;
      R__b << fHasQuery;
      R__b << fHasFragment;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUri(void *p) {
      return  p ? new(p) ::TUri : new ::TUri;
   }
   static void *newArray_TUri(Long_t nElements, void *p) {
      return p ? new(p) ::TUri[nElements] : new ::TUri[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUri(void *p) {
      delete ((::TUri*)p);
   }
   static void deleteArray_TUri(void *p) {
      delete [] ((::TUri*)p);
   }
   static void destruct_TUri(void *p) {
      typedef ::TUri current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TUri(TBuffer &buf, void *obj) {
      ((::TUri*)obj)->::TUri::Streamer(buf);
   }
} // end of namespace ROOT for class ::TUri

//______________________________________________________________________________
void TVirtualAuth::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualAuth.

   ::Error("TVirtualAuth::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualAuth(void *p) {
      delete ((::TVirtualAuth*)p);
   }
   static void deleteArray_TVirtualAuth(void *p) {
      delete [] ((::TVirtualAuth*)p);
   }
   static void destruct_TVirtualAuth(void *p) {
      typedef ::TVirtualAuth current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualAuth(TBuffer &buf, void *obj) {
      ((::TVirtualAuth*)obj)->::TVirtualAuth::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualAuth

//______________________________________________________________________________
void TVirtualFFT::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualFFT.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualFFT(void *p) {
      delete ((::TVirtualFFT*)p);
   }
   static void deleteArray_TVirtualFFT(void *p) {
      delete [] ((::TVirtualFFT*)p);
   }
   static void destruct_TVirtualFFT(void *p) {
      typedef ::TVirtualFFT current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualFFT(TBuffer &buf, void *obj) {
      ((::TVirtualFFT*)obj)->::TVirtualFFT::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualFFT

//______________________________________________________________________________
void TVirtualGLPainter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualGLPainter.

   ::Error("TVirtualGLPainter::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualGLPainter(void *p) {
      delete ((::TVirtualGLPainter*)p);
   }
   static void deleteArray_TVirtualGLPainter(void *p) {
      delete [] ((::TVirtualGLPainter*)p);
   }
   static void destruct_TVirtualGLPainter(void *p) {
      typedef ::TVirtualGLPainter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualGLPainter(TBuffer &buf, void *obj) {
      ((::TVirtualGLPainter*)obj)->::TVirtualGLPainter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualGLPainter

//______________________________________________________________________________
void TVirtualGLManip::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualGLManip.

   ::Error("TVirtualGLManip::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualGLManip(void *p) {
      delete ((::TVirtualGLManip*)p);
   }
   static void deleteArray_TVirtualGLManip(void *p) {
      delete [] ((::TVirtualGLManip*)p);
   }
   static void destruct_TVirtualGLManip(void *p) {
      typedef ::TVirtualGLManip current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualGLManip(TBuffer &buf, void *obj) {
      ((::TVirtualGLManip*)obj)->::TVirtualGLManip::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualGLManip

//______________________________________________________________________________
void TGLManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class TGLManager.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TGLManager(void *p) {
      delete ((::TGLManager*)p);
   }
   static void deleteArray_TGLManager(void *p) {
      delete [] ((::TGLManager*)p);
   }
   static void destruct_TGLManager(void *p) {
      typedef ::TGLManager current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TGLManager(TBuffer &buf, void *obj) {
      ((::TGLManager*)obj)->::TGLManager::Streamer(buf);
   }
} // end of namespace ROOT for class ::TGLManager

//______________________________________________________________________________
void TGLPaintDevice::Streamer(TBuffer &R__b)
{
   // Stream an object of class TGLPaintDevice.

   ::Error("TGLPaintDevice::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TGLPaintDevice(void *p) {
      delete ((::TGLPaintDevice*)p);
   }
   static void deleteArray_TGLPaintDevice(void *p) {
      delete [] ((::TGLPaintDevice*)p);
   }
   static void destruct_TGLPaintDevice(void *p) {
      typedef ::TGLPaintDevice current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TGLPaintDevice(TBuffer &buf, void *obj) {
      ((::TGLPaintDevice*)obj)->::TGLPaintDevice::Streamer(buf);
   }
} // end of namespace ROOT for class ::TGLPaintDevice

//______________________________________________________________________________
void THashTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class THashTable.

   TCollection::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_THashTable(void *p) {
      return  p ? new(p) ::THashTable : new ::THashTable;
   }
   static void *newArray_THashTable(Long_t nElements, void *p) {
      return p ? new(p) ::THashTable[nElements] : new ::THashTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_THashTable(void *p) {
      delete ((::THashTable*)p);
   }
   static void deleteArray_THashTable(void *p) {
      delete [] ((::THashTable*)p);
   }
   static void destruct_THashTable(void *p) {
      typedef ::THashTable current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_THashTable(TBuffer &buf, void *obj) {
      ((::THashTable*)obj)->::THashTable::Streamer(buf);
   }
} // end of namespace ROOT for class ::THashTable

//______________________________________________________________________________
void THashTableIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class THashTableIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_THashTableIter(void *p) {
      delete ((::THashTableIter*)p);
   }
   static void deleteArray_THashTableIter(void *p) {
      delete [] ((::THashTableIter*)p);
   }
   static void destruct_THashTableIter(void *p) {
      typedef ::THashTableIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_THashTableIter(TBuffer &buf, void *obj) {
      ((::THashTableIter*)obj)->::THashTableIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::THashTableIter

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMap(void *p) {
      return  p ? new(p) ::TMap : new ::TMap;
   }
   static void *newArray_TMap(Long_t nElements, void *p) {
      return p ? new(p) ::TMap[nElements] : new ::TMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMap(void *p) {
      delete ((::TMap*)p);
   }
   static void deleteArray_TMap(void *p) {
      delete [] ((::TMap*)p);
   }
   static void destruct_TMap(void *p) {
      typedef ::TMap current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMap(TBuffer &buf, void *obj) {
      ((::TMap*)obj)->::TMap::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMap

//______________________________________________________________________________
void TPair::Streamer(TBuffer &R__b)
{
   // Stream an object of class TPair.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TPair(void *p) {
      delete ((::TPair*)p);
   }
   static void deleteArray_TPair(void *p) {
      delete [] ((::TPair*)p);
   }
   static void destruct_TPair(void *p) {
      typedef ::TPair current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TPair(TBuffer &buf, void *obj) {
      ((::TPair*)obj)->::TPair::Streamer(buf);
   }
} // end of namespace ROOT for class ::TPair

//______________________________________________________________________________
void TMapIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMapIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TMapIter(void *p) {
      delete ((::TMapIter*)p);
   }
   static void deleteArray_TMapIter(void *p) {
      delete [] ((::TMapIter*)p);
   }
   static void destruct_TMapIter(void *p) {
      typedef ::TMapIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMapIter(TBuffer &buf, void *obj) {
      ((::TMapIter*)obj)->::TMapIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMapIter

//______________________________________________________________________________
void TVirtualMonitoringWriter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMonitoringWriter.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TVirtualMonitoringWriter(void *p) {
      return  p ? new(p) ::TVirtualMonitoringWriter : new ::TVirtualMonitoringWriter;
   }
   static void *newArray_TVirtualMonitoringWriter(Long_t nElements, void *p) {
      return p ? new(p) ::TVirtualMonitoringWriter[nElements] : new ::TVirtualMonitoringWriter[nElements];
   }
   // Wrapper around operator delete
   static void delete_TVirtualMonitoringWriter(void *p) {
      delete ((::TVirtualMonitoringWriter*)p);
   }
   static void deleteArray_TVirtualMonitoringWriter(void *p) {
      delete [] ((::TVirtualMonitoringWriter*)p);
   }
   static void destruct_TVirtualMonitoringWriter(void *p) {
      typedef ::TVirtualMonitoringWriter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualMonitoringWriter(TBuffer &buf, void *obj) {
      ((::TVirtualMonitoringWriter*)obj)->::TVirtualMonitoringWriter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualMonitoringWriter

//______________________________________________________________________________
void TVirtualMonitoringReader::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMonitoringReader.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TNamed::Streamer(R__b);
      R__b.CheckByteCount(R__s, R__c, TVirtualMonitoringReader::IsA());
   } else {
      R__c = R__b.WriteVersion(TVirtualMonitoringReader::IsA(), kTRUE);
      TNamed::Streamer(R__b);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TVirtualMonitoringReader(void *p) {
      return  p ? new(p) ::TVirtualMonitoringReader : new ::TVirtualMonitoringReader;
   }
   static void *newArray_TVirtualMonitoringReader(Long_t nElements, void *p) {
      return p ? new(p) ::TVirtualMonitoringReader[nElements] : new ::TVirtualMonitoringReader[nElements];
   }
   // Wrapper around operator delete
   static void delete_TVirtualMonitoringReader(void *p) {
      delete ((::TVirtualMonitoringReader*)p);
   }
   static void deleteArray_TVirtualMonitoringReader(void *p) {
      delete [] ((::TVirtualMonitoringReader*)p);
   }
   static void destruct_TVirtualMonitoringReader(void *p) {
      typedef ::TVirtualMonitoringReader current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualMonitoringReader(TBuffer &buf, void *obj) {
      ((::TVirtualMonitoringReader*)obj)->::TVirtualMonitoringReader::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualMonitoringReader

//______________________________________________________________________________
void TVirtualPadEditor::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualPadEditor.

   ::Error("TVirtualPadEditor::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPadEditor(void *p) {
      delete ((::TVirtualPadEditor*)p);
   }
   static void deleteArray_TVirtualPadEditor(void *p) {
      delete [] ((::TVirtualPadEditor*)p);
   }
   static void destruct_TVirtualPadEditor(void *p) {
      typedef ::TVirtualPadEditor current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualPadEditor(TBuffer &buf, void *obj) {
      ((::TVirtualPadEditor*)obj)->::TVirtualPadEditor::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualPadEditor

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPad(void *p) {
      delete ((::TVirtualPad*)p);
   }
   static void deleteArray_TVirtualPad(void *p) {
      delete [] ((::TVirtualPad*)p);
   }
   static void destruct_TVirtualPad(void *p) {
      typedef ::TVirtualPad current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualPad(TBuffer &buf, void *obj) {
      ((::TVirtualPad*)obj)->::TVirtualPad::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualPad

//______________________________________________________________________________
void TVirtualPadPainter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualPadPainter.

   ::Error("TVirtualPadPainter::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPadPainter(void *p) {
      delete ((::TVirtualPadPainter*)p);
   }
   static void deleteArray_TVirtualPadPainter(void *p) {
      delete [] ((::TVirtualPadPainter*)p);
   }
   static void destruct_TVirtualPadPainter(void *p) {
      typedef ::TVirtualPadPainter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualPadPainter(TBuffer &buf, void *obj) {
      ((::TVirtualPadPainter*)obj)->::TVirtualPadPainter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualPadPainter

//______________________________________________________________________________
void TVirtualPerfStats::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualPerfStats.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPerfStats(void *p) {
      delete ((::TVirtualPerfStats*)p);
   }
   static void deleteArray_TVirtualPerfStats(void *p) {
      delete [] ((::TVirtualPerfStats*)p);
   }
   static void destruct_TVirtualPerfStats(void *p) {
      typedef ::TVirtualPerfStats current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualPerfStats(TBuffer &buf, void *obj) {
      ((::TVirtualPerfStats*)obj)->::TVirtualPerfStats::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualPerfStats

//______________________________________________________________________________
void TVirtualPS::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualPS.

   TNamed::Streamer(R__b);
   TAttLine::Streamer(R__b);
   TAttFill::Streamer(R__b);
   TAttMarker::Streamer(R__b);
   TAttText::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPS(void *p) {
      delete ((::TVirtualPS*)p);
   }
   static void deleteArray_TVirtualPS(void *p) {
      delete [] ((::TVirtualPS*)p);
   }
   static void destruct_TVirtualPS(void *p) {
      typedef ::TVirtualPS current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualPS(TBuffer &buf, void *obj) {
      ((::TVirtualPS*)obj)->::TVirtualPS::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualPS

//______________________________________________________________________________
void TVirtualTableInterface::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualTableInterface.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TVirtualTableInterface::Class(),this);
   } else {
      R__b.WriteClassBuffer(TVirtualTableInterface::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualTableInterface(void *p) {
      delete ((::TVirtualTableInterface*)p);
   }
   static void deleteArray_TVirtualTableInterface(void *p) {
      delete [] ((::TVirtualTableInterface*)p);
   }
   static void destruct_TVirtualTableInterface(void *p) {
      typedef ::TVirtualTableInterface current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualTableInterface

//______________________________________________________________________________
void TVirtualViewer3D::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualViewer3D.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualViewer3D(void *p) {
      delete ((::TVirtualViewer3D*)p);
   }
   static void deleteArray_TVirtualViewer3D(void *p) {
      delete [] ((::TVirtualViewer3D*)p);
   }
   static void destruct_TVirtualViewer3D(void *p) {
      typedef ::TVirtualViewer3D current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualViewer3D(TBuffer &buf, void *obj) {
      ((::TVirtualViewer3D*)obj)->::TVirtualViewer3D::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualViewer3D

//______________________________________________________________________________
void TVirtualX::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualX.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TVirtualX::Class(),this);
   } else {
      R__b.WriteClassBuffer(TVirtualX::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TVirtualX(void *p) {
      return  p ? new(p) ::TVirtualX : new ::TVirtualX;
   }
   static void *newArray_TVirtualX(Long_t nElements, void *p) {
      return p ? new(p) ::TVirtualX[nElements] : new ::TVirtualX[nElements];
   }
   // Wrapper around operator delete
   static void delete_TVirtualX(void *p) {
      delete ((::TVirtualX*)p);
   }
   static void deleteArray_TVirtualX(void *p) {
      delete [] ((::TVirtualX*)p);
   }
   static void destruct_TVirtualX(void *p) {
      typedef ::TVirtualX current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualX

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayC(void *p) {
      return  p ? new(p) ::TArrayC : new ::TArrayC;
   }
   static void *newArray_TArrayC(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayC[nElements] : new ::TArrayC[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayC(void *p) {
      delete ((::TArrayC*)p);
   }
   static void deleteArray_TArrayC(void *p) {
      delete [] ((::TArrayC*)p);
   }
   static void destruct_TArrayC(void *p) {
      typedef ::TArrayC current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayC(TBuffer &buf, void *obj) {
      ((::TArrayC*)obj)->::TArrayC::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayC

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayD(void *p) {
      return  p ? new(p) ::TArrayD : new ::TArrayD;
   }
   static void *newArray_TArrayD(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayD[nElements] : new ::TArrayD[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayD(void *p) {
      delete ((::TArrayD*)p);
   }
   static void deleteArray_TArrayD(void *p) {
      delete [] ((::TArrayD*)p);
   }
   static void destruct_TArrayD(void *p) {
      typedef ::TArrayD current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayD(TBuffer &buf, void *obj) {
      ((::TArrayD*)obj)->::TArrayD::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayD

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayF(void *p) {
      return  p ? new(p) ::TArrayF : new ::TArrayF;
   }
   static void *newArray_TArrayF(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayF[nElements] : new ::TArrayF[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayF(void *p) {
      delete ((::TArrayF*)p);
   }
   static void deleteArray_TArrayF(void *p) {
      delete [] ((::TArrayF*)p);
   }
   static void destruct_TArrayF(void *p) {
      typedef ::TArrayF current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayF(TBuffer &buf, void *obj) {
      ((::TArrayF*)obj)->::TArrayF::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayF

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayL64(void *p) {
      return  p ? new(p) ::TArrayL64 : new ::TArrayL64;
   }
   static void *newArray_TArrayL64(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayL64[nElements] : new ::TArrayL64[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayL64(void *p) {
      delete ((::TArrayL64*)p);
   }
   static void deleteArray_TArrayL64(void *p) {
      delete [] ((::TArrayL64*)p);
   }
   static void destruct_TArrayL64(void *p) {
      typedef ::TArrayL64 current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayL64(TBuffer &buf, void *obj) {
      ((::TArrayL64*)obj)->::TArrayL64::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayL64

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayL(void *p) {
      return  p ? new(p) ::TArrayL : new ::TArrayL;
   }
   static void *newArray_TArrayL(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayL[nElements] : new ::TArrayL[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayL(void *p) {
      delete ((::TArrayL*)p);
   }
   static void deleteArray_TArrayL(void *p) {
      delete [] ((::TArrayL*)p);
   }
   static void destruct_TArrayL(void *p) {
      typedef ::TArrayL current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayL(TBuffer &buf, void *obj) {
      ((::TArrayL*)obj)->::TArrayL::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayL

namespace ROOT {
   // Wrappers around operator new
   static void *new_TArrayS(void *p) {
      return  p ? new(p) ::TArrayS : new ::TArrayS;
   }
   static void *newArray_TArrayS(Long_t nElements, void *p) {
      return p ? new(p) ::TArrayS[nElements] : new ::TArrayS[nElements];
   }
   // Wrapper around operator delete
   static void delete_TArrayS(void *p) {
      delete ((::TArrayS*)p);
   }
   static void deleteArray_TArrayS(void *p) {
      delete [] ((::TArrayS*)p);
   }
   static void destruct_TArrayS(void *p) {
      typedef ::TArrayS current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TArrayS(TBuffer &buf, void *obj) {
      ((::TArrayS*)obj)->::TArrayS::Streamer(buf);
   }
} // end of namespace ROOT for class ::TArrayS

//______________________________________________________________________________
void TBits::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBits.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TBits::Class(),this);
   } else {
      R__b.WriteClassBuffer(TBits::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBits(void *p) {
      return  p ? new(p) ::TBits : new ::TBits;
   }
   static void *newArray_TBits(Long_t nElements, void *p) {
      return p ? new(p) ::TBits[nElements] : new ::TBits[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBits(void *p) {
      delete ((::TBits*)p);
   }
   static void deleteArray_TBits(void *p) {
      delete [] ((::TBits*)p);
   }
   static void destruct_TBits(void *p) {
      typedef ::TBits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBits

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TBitscLcLTReference(void *p) {
      delete ((::TBits::TReference*)p);
   }
   static void deleteArray_TBitscLcLTReference(void *p) {
      delete [] ((::TBits::TReference*)p);
   }
   static void destruct_TBitscLcLTReference(void *p) {
      typedef ::TBits::TReference current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBits::TReference

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBtree(void *p) {
      return  p ? new(p) ::TBtree : new ::TBtree;
   }
   static void *newArray_TBtree(Long_t nElements, void *p) {
      return p ? new(p) ::TBtree[nElements] : new ::TBtree[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBtree(void *p) {
      delete ((::TBtree*)p);
   }
   static void deleteArray_TBtree(void *p) {
      delete [] ((::TBtree*)p);
   }
   static void destruct_TBtree(void *p) {
      typedef ::TBtree current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBtree(TBuffer &buf, void *obj) {
      ((::TBtree*)obj)->::TBtree::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TBtree(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TBtree*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TBtree

//______________________________________________________________________________
void TBtreeIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBtreeIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TBtreeIter(void *p) {
      delete ((::TBtreeIter*)p);
   }
   static void deleteArray_TBtreeIter(void *p) {
      delete [] ((::TBtreeIter*)p);
   }
   static void destruct_TBtreeIter(void *p) {
      typedef ::TBtreeIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBtreeIter(TBuffer &buf, void *obj) {
      ((::TBtreeIter*)obj)->::TBtreeIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TBtreeIter

//______________________________________________________________________________
void TClassTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class TClassTable.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TClassTable(void *p) {
      delete ((::TClassTable*)p);
   }
   static void deleteArray_TClassTable(void *p) {
      delete [] ((::TClassTable*)p);
   }
   static void destruct_TClassTable(void *p) {
      typedef ::TClassTable current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TClassTable(TBuffer &buf, void *obj) {
      ((::TClassTable*)obj)->::TClassTable::Streamer(buf);
   }
} // end of namespace ROOT for class ::TClassTable

namespace ROOT {
   // Wrappers around operator new
   static void *new_TClonesArray(void *p) {
      return  p ? new(p) ::TClonesArray : new ::TClonesArray;
   }
   static void *newArray_TClonesArray(Long_t nElements, void *p) {
      return p ? new(p) ::TClonesArray[nElements] : new ::TClonesArray[nElements];
   }
   // Wrapper around operator delete
   static void delete_TClonesArray(void *p) {
      delete ((::TClonesArray*)p);
   }
   static void deleteArray_TClonesArray(void *p) {
      delete [] ((::TClonesArray*)p);
   }
   static void destruct_TClonesArray(void *p) {
      typedef ::TClonesArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TClonesArray(TBuffer &buf, void *obj) {
      ((::TClonesArray*)obj)->::TClonesArray::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TClonesArray(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TClonesArray*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TClonesArray

namespace ROOT {
   // Wrappers around operator new
   static void *new_TExMap(void *p) {
      return  p ? new(p) ::TExMap : new ::TExMap;
   }
   static void *newArray_TExMap(Long_t nElements, void *p) {
      return p ? new(p) ::TExMap[nElements] : new ::TExMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_TExMap(void *p) {
      delete ((::TExMap*)p);
   }
   static void deleteArray_TExMap(void *p) {
      delete [] ((::TExMap*)p);
   }
   static void destruct_TExMap(void *p) {
      typedef ::TExMap current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TExMap(TBuffer &buf, void *obj) {
      ((::TExMap*)obj)->::TExMap::Streamer(buf);
   }
} // end of namespace ROOT for class ::TExMap

//______________________________________________________________________________
void TExMapIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TExMapIter.

   ::Error("TExMapIter::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TExMapIter(void *p) {
      delete ((::TExMapIter*)p);
   }
   static void deleteArray_TExMapIter(void *p) {
      delete [] ((::TExMapIter*)p);
   }
   static void destruct_TExMapIter(void *p) {
      typedef ::TExMapIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TExMapIter(TBuffer &buf, void *obj) {
      ((::TExMapIter*)obj)->::TExMapIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TExMapIter

//______________________________________________________________________________
void THashList::Streamer(TBuffer &R__b)
{
   // Stream an object of class THashList.

   TList::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_THashList(void *p) {
      return  p ? new(p) ::THashList : new ::THashList;
   }
   static void *newArray_THashList(Long_t nElements, void *p) {
      return p ? new(p) ::THashList[nElements] : new ::THashList[nElements];
   }
   // Wrapper around operator delete
   static void delete_THashList(void *p) {
      delete ((::THashList*)p);
   }
   static void deleteArray_THashList(void *p) {
      delete [] ((::THashList*)p);
   }
   static void destruct_THashList(void *p) {
      typedef ::THashList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_THashList(TBuffer &buf, void *obj) {
      ((::THashList*)obj)->::THashList::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_THashList(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::THashList*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::THashList

//______________________________________________________________________________
void TObjectTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjectTable.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObjectTable(void *p) {
      return  p ? new(p) ::TObjectTable : new ::TObjectTable;
   }
   static void *newArray_TObjectTable(Long_t nElements, void *p) {
      return p ? new(p) ::TObjectTable[nElements] : new ::TObjectTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObjectTable(void *p) {
      delete ((::TObjectTable*)p);
   }
   static void deleteArray_TObjectTable(void *p) {
      delete [] ((::TObjectTable*)p);
   }
   static void destruct_TObjectTable(void *p) {
      typedef ::TObjectTable current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObjectTable(TBuffer &buf, void *obj) {
      ((::TObjectTable*)obj)->::TObjectTable::Streamer(buf);
   }
} // end of namespace ROOT for class ::TObjectTable

//______________________________________________________________________________
void TOrdCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class TOrdCollection.

   TSeqCollection::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TOrdCollection(void *p) {
      return  p ? new(p) ::TOrdCollection : new ::TOrdCollection;
   }
   static void *newArray_TOrdCollection(Long_t nElements, void *p) {
      return p ? new(p) ::TOrdCollection[nElements] : new ::TOrdCollection[nElements];
   }
   // Wrapper around operator delete
   static void delete_TOrdCollection(void *p) {
      delete ((::TOrdCollection*)p);
   }
   static void deleteArray_TOrdCollection(void *p) {
      delete [] ((::TOrdCollection*)p);
   }
   static void destruct_TOrdCollection(void *p) {
      typedef ::TOrdCollection current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TOrdCollection(TBuffer &buf, void *obj) {
      ((::TOrdCollection*)obj)->::TOrdCollection::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TOrdCollection(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TOrdCollection*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TOrdCollection

//______________________________________________________________________________
void TOrdCollectionIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TOrdCollectionIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TOrdCollectionIter(void *p) {
      delete ((::TOrdCollectionIter*)p);
   }
   static void deleteArray_TOrdCollectionIter(void *p) {
      delete [] ((::TOrdCollectionIter*)p);
   }
   static void destruct_TOrdCollectionIter(void *p) {
      typedef ::TOrdCollectionIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TOrdCollectionIter(TBuffer &buf, void *obj) {
      ((::TOrdCollectionIter*)obj)->::TOrdCollectionIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TOrdCollectionIter

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRefArray(void *p) {
      return  p ? new(p) ::TRefArray : new ::TRefArray;
   }
   static void *newArray_TRefArray(Long_t nElements, void *p) {
      return p ? new(p) ::TRefArray[nElements] : new ::TRefArray[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRefArray(void *p) {
      delete ((::TRefArray*)p);
   }
   static void deleteArray_TRefArray(void *p) {
      delete [] ((::TRefArray*)p);
   }
   static void destruct_TRefArray(void *p) {
      typedef ::TRefArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRefArray(TBuffer &buf, void *obj) {
      ((::TRefArray*)obj)->::TRefArray::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TRefArray(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TRefArray*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TRefArray

//______________________________________________________________________________
void TRefArrayIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRefArrayIter.

   TIterator::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TRefArrayIter(void *p) {
      delete ((::TRefArrayIter*)p);
   }
   static void deleteArray_TRefArrayIter(void *p) {
      delete [] ((::TRefArrayIter*)p);
   }
   static void destruct_TRefArrayIter(void *p) {
      typedef ::TRefArrayIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRefArrayIter(TBuffer &buf, void *obj) {
      ((::TRefArrayIter*)obj)->::TRefArrayIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRefArrayIter

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRefTable(void *p) {
      return  p ? new(p) ::TRefTable : new ::TRefTable;
   }
   static void *newArray_TRefTable(Long_t nElements, void *p) {
      return p ? new(p) ::TRefTable[nElements] : new ::TRefTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRefTable(void *p) {
      delete ((::TRefTable*)p);
   }
   static void deleteArray_TRefTable(void *p) {
      delete [] ((::TRefTable*)p);
   }
   static void destruct_TRefTable(void *p) {
      typedef ::TRefTable current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRefTable(TBuffer &buf, void *obj) {
      ((::TRefTable*)obj)->::TRefTable::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRefTable

//______________________________________________________________________________
void TSortedList::Streamer(TBuffer &R__b)
{
   // Stream an object of class TSortedList.

   TList::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TSortedList(void *p) {
      return  p ? new(p) ::TSortedList : new ::TSortedList;
   }
   static void *newArray_TSortedList(Long_t nElements, void *p) {
      return p ? new(p) ::TSortedList[nElements] : new ::TSortedList[nElements];
   }
   // Wrapper around operator delete
   static void delete_TSortedList(void *p) {
      delete ((::TSortedList*)p);
   }
   static void deleteArray_TSortedList(void *p) {
      delete [] ((::TSortedList*)p);
   }
   static void destruct_TSortedList(void *p) {
      typedef ::TSortedList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TSortedList(TBuffer &buf, void *obj) {
      ((::TSortedList*)obj)->::TSortedList::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TSortedList(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TSortedList*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TSortedList

namespace ROOT {
   // Wrappers around operator new
   static void *new_TClassRef(void *p) {
      return  p ? new(p) ::TClassRef : new ::TClassRef;
   }
   static void *newArray_TClassRef(Long_t nElements, void *p) {
      return p ? new(p) ::TClassRef[nElements] : new ::TClassRef[nElements];
   }
   // Wrapper around operator delete
   static void delete_TClassRef(void *p) {
      delete ((::TClassRef*)p);
   }
   static void deleteArray_TClassRef(void *p) {
      delete [] ((::TClassRef*)p);
   }
   static void destruct_TClassRef(void *p) {
      typedef ::TClassRef current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TClassRef

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualCollectionProxy(void *p) {
      delete ((::TVirtualCollectionProxy*)p);
   }
   static void deleteArray_TVirtualCollectionProxy(void *p) {
      delete [] ((::TVirtualCollectionProxy*)p);
   }
   static void destruct_TVirtualCollectionProxy(void *p) {
      typedef ::TVirtualCollectionProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualCollectionProxy

//______________________________________________________________________________
void TUnixSystem::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUnixSystem.

   TSystem::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUnixSystem(void *p) {
      return  p ? new(p) ::TUnixSystem : new ::TUnixSystem;
   }
   static void *newArray_TUnixSystem(Long_t nElements, void *p) {
      return p ? new(p) ::TUnixSystem[nElements] : new ::TUnixSystem[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUnixSystem(void *p) {
      delete ((::TUnixSystem*)p);
   }
   static void deleteArray_TUnixSystem(void *p) {
      delete [] ((::TUnixSystem*)p);
   }
   static void destruct_TUnixSystem(void *p) {
      typedef ::TUnixSystem current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TUnixSystem(TBuffer &buf, void *obj) {
      ((::TUnixSystem*)obj)->::TUnixSystem::Streamer(buf);
   }
} // end of namespace ROOT for class ::TUnixSystem

//______________________________________________________________________________
void TBrowserImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBrowserImp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TBrowserImp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TBrowserImp::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBrowserImp(void *p) {
      return  p ? new(p) ::TBrowserImp : new ::TBrowserImp;
   }
   static void *newArray_TBrowserImp(Long_t nElements, void *p) {
      return p ? new(p) ::TBrowserImp[nElements] : new ::TBrowserImp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBrowserImp(void *p) {
      delete ((::TBrowserImp*)p);
   }
   static void deleteArray_TBrowserImp(void *p) {
      delete [] ((::TBrowserImp*)p);
   }
   static void destruct_TBrowserImp(void *p) {
      typedef ::TBrowserImp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBrowserImp

//______________________________________________________________________________
void TBrowser::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBrowser.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TBrowser::Class(),this);
   } else {
      R__b.WriteClassBuffer(TBrowser::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBrowser(void *p) {
      return  p ? new(p) ::TBrowser : new ::TBrowser;
   }
   static void *newArray_TBrowser(Long_t nElements, void *p) {
      return p ? new(p) ::TBrowser[nElements] : new ::TBrowser[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBrowser(void *p) {
      delete ((::TBrowser*)p);
   }
   static void deleteArray_TBrowser(void *p) {
      delete [] ((::TBrowser*)p);
   }
   static void destruct_TBrowser(void *p) {
      typedef ::TBrowser current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBrowser

//______________________________________________________________________________
void TCanvasImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TCanvasImp.

   ::Error("TCanvasImp::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TCanvasImp(void *p) {
      return  p ? new(p) ::TCanvasImp : new ::TCanvasImp;
   }
   static void *newArray_TCanvasImp(Long_t nElements, void *p) {
      return p ? new(p) ::TCanvasImp[nElements] : new ::TCanvasImp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TCanvasImp(void *p) {
      delete ((::TCanvasImp*)p);
   }
   static void deleteArray_TCanvasImp(void *p) {
      delete [] ((::TCanvasImp*)p);
   }
   static void destruct_TCanvasImp(void *p) {
      typedef ::TCanvasImp current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TCanvasImp(TBuffer &buf, void *obj) {
      ((::TCanvasImp*)obj)->::TCanvasImp::Streamer(buf);
   }
} // end of namespace ROOT for class ::TCanvasImp

//______________________________________________________________________________
void TClassMenuItem::Streamer(TBuffer &R__b)
{
   // Stream an object of class TClassMenuItem.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TClassMenuItem(void *p) {
      return  p ? new(p) ::TClassMenuItem : new ::TClassMenuItem;
   }
   static void *newArray_TClassMenuItem(Long_t nElements, void *p) {
      return p ? new(p) ::TClassMenuItem[nElements] : new ::TClassMenuItem[nElements];
   }
   // Wrapper around operator delete
   static void delete_TClassMenuItem(void *p) {
      delete ((::TClassMenuItem*)p);
   }
   static void deleteArray_TClassMenuItem(void *p) {
      delete [] ((::TClassMenuItem*)p);
   }
   static void destruct_TClassMenuItem(void *p) {
      typedef ::TClassMenuItem current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TClassMenuItem(TBuffer &buf, void *obj) {
      ((::TClassMenuItem*)obj)->::TClassMenuItem::Streamer(buf);
   }
} // end of namespace ROOT for class ::TClassMenuItem

//______________________________________________________________________________
void TContextMenuImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TContextMenuImp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TContextMenuImp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TContextMenuImp::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TContextMenuImp(void *p) {
      return  p ? new(p) ::TContextMenuImp : new ::TContextMenuImp;
   }
   static void *newArray_TContextMenuImp(Long_t nElements, void *p) {
      return p ? new(p) ::TContextMenuImp[nElements] : new ::TContextMenuImp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TContextMenuImp(void *p) {
      delete ((::TContextMenuImp*)p);
   }
   static void deleteArray_TContextMenuImp(void *p) {
      delete [] ((::TContextMenuImp*)p);
   }
   static void destruct_TContextMenuImp(void *p) {
      typedef ::TContextMenuImp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TContextMenuImp

//______________________________________________________________________________
void TContextMenu::Streamer(TBuffer &R__b)
{
   // Stream an object of class TContextMenu.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TContextMenu::Class(),this);
   } else {
      R__b.WriteClassBuffer(TContextMenu::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TContextMenu(void *p) {
      delete ((::TContextMenu*)p);
   }
   static void deleteArray_TContextMenu(void *p) {
      delete [] ((::TContextMenu*)p);
   }
   static void destruct_TContextMenu(void *p) {
      typedef ::TContextMenu current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TContextMenu

//______________________________________________________________________________
void TControlBarImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TControlBarImp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TControlBarImp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TControlBarImp::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TControlBarImp(void *p) {
      delete ((::TControlBarImp*)p);
   }
   static void deleteArray_TControlBarImp(void *p) {
      delete [] ((::TControlBarImp*)p);
   }
   static void destruct_TControlBarImp(void *p) {
      typedef ::TControlBarImp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TControlBarImp

//______________________________________________________________________________
void TGuiFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class TGuiFactory.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TGuiFactory(void *p) {
      return  p ? new(p) ::TGuiFactory : new ::TGuiFactory;
   }
   static void *newArray_TGuiFactory(Long_t nElements, void *p) {
      return p ? new(p) ::TGuiFactory[nElements] : new ::TGuiFactory[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGuiFactory(void *p) {
      delete ((::TGuiFactory*)p);
   }
   static void deleteArray_TGuiFactory(void *p) {
      delete [] ((::TGuiFactory*)p);
   }
   static void destruct_TGuiFactory(void *p) {
      typedef ::TGuiFactory current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TGuiFactory(TBuffer &buf, void *obj) {
      ((::TGuiFactory*)obj)->::TGuiFactory::Streamer(buf);
   }
} // end of namespace ROOT for class ::TGuiFactory

//______________________________________________________________________________
void TInspectorImp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TInspectorImp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TInspectorImp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TInspectorImp::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TInspectorImp(void *p) {
      return  p ? new(p) ::TInspectorImp : new ::TInspectorImp;
   }
   static void *newArray_TInspectorImp(Long_t nElements, void *p) {
      return p ? new(p) ::TInspectorImp[nElements] : new ::TInspectorImp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TInspectorImp(void *p) {
      delete ((::TInspectorImp*)p);
   }
   static void deleteArray_TInspectorImp(void *p) {
      delete [] ((::TInspectorImp*)p);
   }
   static void destruct_TInspectorImp(void *p) {
      typedef ::TInspectorImp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TInspectorImp

//______________________________________________________________________________
void TObjectSpy::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjectSpy.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObjectSpy(void *p) {
      return  p ? new(p) ::TObjectSpy : new ::TObjectSpy;
   }
   static void *newArray_TObjectSpy(Long_t nElements, void *p) {
      return p ? new(p) ::TObjectSpy[nElements] : new ::TObjectSpy[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObjectSpy(void *p) {
      delete ((::TObjectSpy*)p);
   }
   static void deleteArray_TObjectSpy(void *p) {
      delete [] ((::TObjectSpy*)p);
   }
   static void destruct_TObjectSpy(void *p) {
      typedef ::TObjectSpy current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObjectSpy(TBuffer &buf, void *obj) {
      ((::TObjectSpy*)obj)->::TObjectSpy::Streamer(buf);
   }
} // end of namespace ROOT for class ::TObjectSpy

//______________________________________________________________________________
void TObjectRefSpy::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjectRefSpy.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TObjectRefSpy(void *p) {
      delete ((::TObjectRefSpy*)p);
   }
   static void deleteArray_TObjectRefSpy(void *p) {
      delete [] ((::TObjectRefSpy*)p);
   }
   static void destruct_TObjectRefSpy(void *p) {
      typedef ::TObjectRefSpy current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TObjectRefSpy(TBuffer &buf, void *obj) {
      ((::TObjectRefSpy*)obj)->::TObjectRefSpy::Streamer(buf);
   }
} // end of namespace ROOT for class ::TObjectRefSpy

//______________________________________________________________________________
void TFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFunction.

   TDictionary::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFunction(void *p) {
      return  p ? new(p) ::TFunction : new ::TFunction;
   }
   static void *newArray_TFunction(Long_t nElements, void *p) {
      return p ? new(p) ::TFunction[nElements] : new ::TFunction[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFunction(void *p) {
      delete ((::TFunction*)p);
   }
   static void deleteArray_TFunction(void *p) {
      delete [] ((::TFunction*)p);
   }
   static void destruct_TFunction(void *p) {
      typedef ::TFunction current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TFunction(TBuffer &buf, void *obj) {
      ((::TFunction*)obj)->::TFunction::Streamer(buf);
   }
} // end of namespace ROOT for class ::TFunction

//______________________________________________________________________________
void TMethod::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMethod.

   TFunction::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMethod(void *p) {
      return  p ? new(p) ::TMethod : new ::TMethod;
   }
   static void *newArray_TMethod(Long_t nElements, void *p) {
      return p ? new(p) ::TMethod[nElements] : new ::TMethod[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMethod(void *p) {
      delete ((::TMethod*)p);
   }
   static void deleteArray_TMethod(void *p) {
      delete [] ((::TMethod*)p);
   }
   static void destruct_TMethod(void *p) {
      typedef ::TMethod current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMethod(TBuffer &buf, void *obj) {
      ((::TMethod*)obj)->::TMethod::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMethod

//______________________________________________________________________________
void TToggle::Streamer(TBuffer &R__b)
{
   // Stream an object of class TToggle.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TToggle(void *p) {
      return  p ? new(p) ::TToggle : new ::TToggle;
   }
   static void *newArray_TToggle(Long_t nElements, void *p) {
      return p ? new(p) ::TToggle[nElements] : new ::TToggle[nElements];
   }
   // Wrapper around operator delete
   static void delete_TToggle(void *p) {
      delete ((::TToggle*)p);
   }
   static void deleteArray_TToggle(void *p) {
      delete [] ((::TToggle*)p);
   }
   static void destruct_TToggle(void *p) {
      typedef ::TToggle current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TToggle(TBuffer &buf, void *obj) {
      ((::TToggle*)obj)->::TToggle::Streamer(buf);
   }
} // end of namespace ROOT for class ::TToggle

//______________________________________________________________________________
void TToggleGroup::Streamer(TBuffer &R__b)
{
   // Stream an object of class TToggleGroup.

   TNamed::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TToggleGroup(void *p) {
      return  p ? new(p) ::TToggleGroup : new ::TToggleGroup;
   }
   static void *newArray_TToggleGroup(Long_t nElements, void *p) {
      return p ? new(p) ::TToggleGroup[nElements] : new ::TToggleGroup[nElements];
   }
   // Wrapper around operator delete
   static void delete_TToggleGroup(void *p) {
      delete ((::TToggleGroup*)p);
   }
   static void deleteArray_TToggleGroup(void *p) {
      delete [] ((::TToggleGroup*)p);
   }
   static void destruct_TToggleGroup(void *p) {
      typedef ::TToggleGroup current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TToggleGroup(TBuffer &buf, void *obj) {
      ((::TToggleGroup*)obj)->::TToggleGroup::Streamer(buf);
   }
} // end of namespace ROOT for class ::TToggleGroup

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBaseClass(void *p) {
      return  p ? new(p) ::TBaseClass : new ::TBaseClass;
   }
   static void *newArray_TBaseClass(Long_t nElements, void *p) {
      return p ? new(p) ::TBaseClass[nElements] : new ::TBaseClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBaseClass(void *p) {
      delete ((::TBaseClass*)p);
   }
   static void deleteArray_TBaseClass(void *p) {
      delete [] ((::TBaseClass*)p);
   }
   static void destruct_TBaseClass(void *p) {
      typedef ::TBaseClass current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TBaseClass(TBuffer &buf, void *obj) {
      ((::TBaseClass*)obj)->::TBaseClass::Streamer(buf);
   }
} // end of namespace ROOT for class ::TBaseClass

//______________________________________________________________________________
void TClassGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class TClassGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TClassGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(TClassGenerator::Class(),this);
   }
}

namespace ROOT {
} // end of namespace ROOT for class ::TClassGenerator

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TClassStreamer(void *p) {
      delete ((::TClassStreamer*)p);
   }
   static void deleteArray_TClassStreamer(void *p) {
      delete [] ((::TClassStreamer*)p);
   }
   static void destruct_TClassStreamer(void *p) {
      typedef ::TClassStreamer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TClassStreamer

namespace ROOT {
   // Wrappers around operator new
   static void *new_TDataMember(void *p) {
      return  p ? new(p) ::TDataMember : new ::TDataMember;
   }
   static void *newArray_TDataMember(Long_t nElements, void *p) {
      return p ? new(p) ::TDataMember[nElements] : new ::TDataMember[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDataMember(void *p) {
      delete ((::TDataMember*)p);
   }
   static void deleteArray_TDataMember(void *p) {
      delete [] ((::TDataMember*)p);
   }
   static void destruct_TDataMember(void *p) {
      typedef ::TDataMember current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TDataMember(TBuffer &buf, void *obj) {
      ((::TDataMember*)obj)->::TDataMember::Streamer(buf);
   }
} // end of namespace ROOT for class ::TDataMember

//______________________________________________________________________________
void TOptionListItem::Streamer(TBuffer &R__b)
{
   // Stream an object of class TOptionListItem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TOptionListItem::Class(),this);
   } else {
      R__b.WriteClassBuffer(TOptionListItem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TOptionListItem(void *p) {
      return  p ? new(p) ::TOptionListItem : new ::TOptionListItem;
   }
   static void *newArray_TOptionListItem(Long_t nElements, void *p) {
      return p ? new(p) ::TOptionListItem[nElements] : new ::TOptionListItem[nElements];
   }
   // Wrapper around operator delete
   static void delete_TOptionListItem(void *p) {
      delete ((::TOptionListItem*)p);
   }
   static void deleteArray_TOptionListItem(void *p) {
      delete [] ((::TOptionListItem*)p);
   }
   static void destruct_TOptionListItem(void *p) {
      typedef ::TOptionListItem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TOptionListItem

//______________________________________________________________________________
void TDictAttributeMap::Streamer(TBuffer &R__b)
{
   // Stream an object of class TDictAttributeMap.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TDictAttributeMap::Class(),this);
   } else {
      R__b.WriteClassBuffer(TDictAttributeMap::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TDictAttributeMap(void *p) {
      return  p ? new(p) ::TDictAttributeMap : new ::TDictAttributeMap;
   }
   static void *newArray_TDictAttributeMap(Long_t nElements, void *p) {
      return p ? new(p) ::TDictAttributeMap[nElements] : new ::TDictAttributeMap[nElements];
   }
   // Wrapper around operator delete
   static void delete_TDictAttributeMap(void *p) {
      delete ((::TDictAttributeMap*)p);
   }
   static void deleteArray_TDictAttributeMap(void *p) {
      delete [] ((::TDictAttributeMap*)p);
   }
   static void destruct_TDictAttributeMap(void *p) {
      typedef ::TDictAttributeMap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TDictAttributeMap

//______________________________________________________________________________
void TGlobal::Streamer(TBuffer &R__b)
{
   // Stream an object of class TGlobal.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TDictionary::Streamer(R__b);
      R__b.CheckByteCount(R__s, R__c, TGlobal::IsA());
   } else {
      R__c = R__b.WriteVersion(TGlobal::IsA(), kTRUE);
      TDictionary::Streamer(R__b);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TGlobal(void *p) {
      return  p ? new(p) ::TGlobal : new ::TGlobal;
   }
   static void *newArray_TGlobal(Long_t nElements, void *p) {
      return p ? new(p) ::TGlobal[nElements] : new ::TGlobal[nElements];
   }
   // Wrapper around operator delete
   static void delete_TGlobal(void *p) {
      delete ((::TGlobal*)p);
   }
   static void deleteArray_TGlobal(void *p) {
      delete [] ((::TGlobal*)p);
   }
   static void destruct_TGlobal(void *p) {
      typedef ::TGlobal current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TGlobal(TBuffer &buf, void *obj) {
      ((::TGlobal*)obj)->::TGlobal::Streamer(buf);
   }
} // end of namespace ROOT for class ::TGlobal

//______________________________________________________________________________
void TEnum::Streamer(TBuffer &R__b)
{
   // Stream an object of class TEnum.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TEnum::Class(),this);
   } else {
      R__b.WriteClassBuffer(TEnum::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TEnum(void *p) {
      return  p ? new(p) ::TEnum : new ::TEnum;
   }
   static void *newArray_TEnum(Long_t nElements, void *p) {
      return p ? new(p) ::TEnum[nElements] : new ::TEnum[nElements];
   }
   // Wrapper around operator delete
   static void delete_TEnum(void *p) {
      delete ((::TEnum*)p);
   }
   static void deleteArray_TEnum(void *p) {
      delete [] ((::TEnum*)p);
   }
   static void destruct_TEnum(void *p) {
      typedef ::TEnum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TEnum

//______________________________________________________________________________
void TEnumConstant::Streamer(TBuffer &R__b)
{
   // Stream an object of class TEnumConstant.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TEnumConstant::Class(),this);
   } else {
      R__b.WriteClassBuffer(TEnumConstant::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TEnumConstant(void *p) {
      return  p ? new(p) ::TEnumConstant : new ::TEnumConstant;
   }
   static void *newArray_TEnumConstant(Long_t nElements, void *p) {
      return p ? new(p) ::TEnumConstant[nElements] : new ::TEnumConstant[nElements];
   }
   // Wrapper around operator delete
   static void delete_TEnumConstant(void *p) {
      delete ((::TEnumConstant*)p);
   }
   static void deleteArray_TEnumConstant(void *p) {
      delete [] ((::TEnumConstant*)p);
   }
   static void destruct_TEnumConstant(void *p) {
      typedef ::TEnumConstant current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TEnumConstant

//______________________________________________________________________________
void TFileMergeInfo::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileMergeInfo.

   ::Error("TFileMergeInfo::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TFileMergeInfo(void *p) {
      delete ((::TFileMergeInfo*)p);
   }
   static void deleteArray_TFileMergeInfo(void *p) {
      delete [] ((::TFileMergeInfo*)p);
   }
   static void destruct_TFileMergeInfo(void *p) {
      typedef ::TFileMergeInfo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TFileMergeInfo(TBuffer &buf, void *obj) {
      ((::TFileMergeInfo*)obj)->::TFileMergeInfo::Streamer(buf);
   }
} // end of namespace ROOT for class ::TFileMergeInfo

//______________________________________________________________________________
void TFunctionTemplate::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFunctionTemplate.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFunctionTemplate::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFunctionTemplate::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TFunctionTemplate(void *p) {
      delete ((::TFunctionTemplate*)p);
   }
   static void deleteArray_TFunctionTemplate(void *p) {
      delete [] ((::TFunctionTemplate*)p);
   }
   static void destruct_TFunctionTemplate(void *p) {
      typedef ::TFunctionTemplate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFunctionTemplate

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListOfDataMembers(void *p) {
      delete ((::TListOfDataMembers*)p);
   }
   static void deleteArray_TListOfDataMembers(void *p) {
      delete [] ((::TListOfDataMembers*)p);
   }
   static void destruct_TListOfDataMembers(void *p) {
      typedef ::TListOfDataMembers current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TListOfDataMembers(TBuffer &buf, void *obj) {
      ((::TListOfDataMembers*)obj)->::TListOfDataMembers::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TListOfDataMembers(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TListOfDataMembers*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TListOfDataMembers

//______________________________________________________________________________
void TListOfEnums::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfEnums.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TListOfEnums::Class(),this);
   } else {
      R__b.WriteClassBuffer(TListOfEnums::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TListOfEnums(void *p) {
      return  p ? new(p) ::TListOfEnums : new ::TListOfEnums;
   }
   static void *newArray_TListOfEnums(Long_t nElements, void *p) {
      return p ? new(p) ::TListOfEnums[nElements] : new ::TListOfEnums[nElements];
   }
   // Wrapper around operator delete
   static void delete_TListOfEnums(void *p) {
      delete ((::TListOfEnums*)p);
   }
   static void deleteArray_TListOfEnums(void *p) {
      delete [] ((::TListOfEnums*)p);
   }
   static void destruct_TListOfEnums(void *p) {
      typedef ::TListOfEnums current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TListOfEnums(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TListOfEnums*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TListOfEnums

//______________________________________________________________________________
void TListOfEnumsWithLock::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfEnumsWithLock.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TListOfEnumsWithLock::Class(),this);
   } else {
      R__b.WriteClassBuffer(TListOfEnumsWithLock::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TListOfEnumsWithLock(void *p) {
      return  p ? new(p) ::TListOfEnumsWithLock : new ::TListOfEnumsWithLock;
   }
   static void *newArray_TListOfEnumsWithLock(Long_t nElements, void *p) {
      return p ? new(p) ::TListOfEnumsWithLock[nElements] : new ::TListOfEnumsWithLock[nElements];
   }
   // Wrapper around operator delete
   static void delete_TListOfEnumsWithLock(void *p) {
      delete ((::TListOfEnumsWithLock*)p);
   }
   static void deleteArray_TListOfEnumsWithLock(void *p) {
      delete [] ((::TListOfEnumsWithLock*)p);
   }
   static void destruct_TListOfEnumsWithLock(void *p) {
      typedef ::TListOfEnumsWithLock current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TListOfEnumsWithLock(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TListOfEnumsWithLock*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TListOfEnumsWithLock

//______________________________________________________________________________
void TListOfEnumsWithLockIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfEnumsWithLockIter.

   TListIter::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListOfEnumsWithLockIter(void *p) {
      delete ((::TListOfEnumsWithLockIter*)p);
   }
   static void deleteArray_TListOfEnumsWithLockIter(void *p) {
      delete [] ((::TListOfEnumsWithLockIter*)p);
   }
   static void destruct_TListOfEnumsWithLockIter(void *p) {
      typedef ::TListOfEnumsWithLockIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TListOfEnumsWithLockIter(TBuffer &buf, void *obj) {
      ((::TListOfEnumsWithLockIter*)obj)->::TListOfEnumsWithLockIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TListOfEnumsWithLockIter

//______________________________________________________________________________
void TListOfFunctions::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfFunctions.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TListOfFunctions::Class(),this);
   } else {
      R__b.WriteClassBuffer(TListOfFunctions::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListOfFunctions(void *p) {
      delete ((::TListOfFunctions*)p);
   }
   static void deleteArray_TListOfFunctions(void *p) {
      delete [] ((::TListOfFunctions*)p);
   }
   static void destruct_TListOfFunctions(void *p) {
      typedef ::TListOfFunctions current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TListOfFunctions(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TListOfFunctions*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TListOfFunctions

//______________________________________________________________________________
void TListOfFunctionsIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfFunctionsIter.

   TListIter::Streamer(R__b);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListOfFunctionsIter(void *p) {
      delete ((::TListOfFunctionsIter*)p);
   }
   static void deleteArray_TListOfFunctionsIter(void *p) {
      delete [] ((::TListOfFunctionsIter*)p);
   }
   static void destruct_TListOfFunctionsIter(void *p) {
      typedef ::TListOfFunctionsIter current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TListOfFunctionsIter(TBuffer &buf, void *obj) {
      ((::TListOfFunctionsIter*)obj)->::TListOfFunctionsIter::Streamer(buf);
   }
} // end of namespace ROOT for class ::TListOfFunctionsIter

//______________________________________________________________________________
void TListOfFunctionTemplates::Streamer(TBuffer &R__b)
{
   // Stream an object of class TListOfFunctionTemplates.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TListOfFunctionTemplates::Class(),this);
   } else {
      R__b.WriteClassBuffer(TListOfFunctionTemplates::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TListOfFunctionTemplates(void *p) {
      delete ((::TListOfFunctionTemplates*)p);
   }
   static void deleteArray_TListOfFunctionTemplates(void *p) {
      delete [] ((::TListOfFunctionTemplates*)p);
   }
   static void destruct_TListOfFunctionTemplates(void *p) {
      typedef ::TListOfFunctionTemplates current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_TListOfFunctionTemplates(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::TListOfFunctionTemplates*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::TListOfFunctionTemplates

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TMemberStreamer(void *p) {
      delete ((::TMemberStreamer*)p);
   }
   static void deleteArray_TMemberStreamer(void *p) {
      delete [] ((::TMemberStreamer*)p);
   }
   static void destruct_TMemberStreamer(void *p) {
      typedef ::TMemberStreamer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TMemberStreamer

//______________________________________________________________________________
void TMethodArg::Streamer(TBuffer &R__b)
{
   // Stream an object of class TMethodArg.

   TDictionary::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TMethodArg(void *p) {
      return  p ? new(p) ::TMethodArg : new ::TMethodArg;
   }
   static void *newArray_TMethodArg(Long_t nElements, void *p) {
      return p ? new(p) ::TMethodArg[nElements] : new ::TMethodArg[nElements];
   }
   // Wrapper around operator delete
   static void delete_TMethodArg(void *p) {
      delete ((::TMethodArg*)p);
   }
   static void deleteArray_TMethodArg(void *p) {
      delete [] ((::TMethodArg*)p);
   }
   static void destruct_TMethodArg(void *p) {
      typedef ::TMethodArg current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TMethodArg(TBuffer &buf, void *obj) {
      ((::TMethodArg*)obj)->::TMethodArg::Streamer(buf);
   }
} // end of namespace ROOT for class ::TMethodArg

//______________________________________________________________________________
void TProtoClass::Streamer(TBuffer &R__b)
{
   // Stream an object of class TProtoClass.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TProtoClass::Class(),this);
   } else {
      R__b.WriteClassBuffer(TProtoClass::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TProtoClass(void *p) {
      return  p ? new(p) ::TProtoClass : new ::TProtoClass;
   }
   static void *newArray_TProtoClass(Long_t nElements, void *p) {
      return p ? new(p) ::TProtoClass[nElements] : new ::TProtoClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_TProtoClass(void *p) {
      delete ((::TProtoClass*)p);
   }
   static void deleteArray_TProtoClass(void *p) {
      delete [] ((::TProtoClass*)p);
   }
   static void destruct_TProtoClass(void *p) {
      typedef ::TProtoClass current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TProtoClass

//______________________________________________________________________________
void TProtoClass::TProtoRealData::Streamer(TBuffer &R__b)
{
   // Stream an object of class TProtoClass::TProtoRealData.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TProtoClass::TProtoRealData::Class(),this);
   } else {
      R__b.WriteClassBuffer(TProtoClass::TProtoRealData::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TProtoClasscLcLTProtoRealData(void *p) {
      return  p ? new(p) ::TProtoClass::TProtoRealData : new ::TProtoClass::TProtoRealData;
   }
   static void *newArray_TProtoClasscLcLTProtoRealData(Long_t nElements, void *p) {
      return p ? new(p) ::TProtoClass::TProtoRealData[nElements] : new ::TProtoClass::TProtoRealData[nElements];
   }
   // Wrapper around operator delete
   static void delete_TProtoClasscLcLTProtoRealData(void *p) {
      delete ((::TProtoClass::TProtoRealData*)p);
   }
   static void deleteArray_TProtoClasscLcLTProtoRealData(void *p) {
      delete [] ((::TProtoClass::TProtoRealData*)p);
   }
   static void destruct_TProtoClasscLcLTProtoRealData(void *p) {
      typedef ::TProtoClass::TProtoRealData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TProtoClass::TProtoRealData

//______________________________________________________________________________
void TRealData::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRealData.

   TObject::Streamer(R__b);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRealData(void *p) {
      return  p ? new(p) ::TRealData : new ::TRealData;
   }
   static void *newArray_TRealData(Long_t nElements, void *p) {
      return p ? new(p) ::TRealData[nElements] : new ::TRealData[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRealData(void *p) {
      delete ((::TRealData*)p);
   }
   static void deleteArray_TRealData(void *p) {
      delete [] ((::TRealData*)p);
   }
   static void destruct_TRealData(void *p) {
      typedef ::TRealData current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TRealData(TBuffer &buf, void *obj) {
      ((::TRealData*)obj)->::TRealData::Streamer(buf);
   }
} // end of namespace ROOT for class ::TRealData

namespace ROOT {
//______________________________________________________________________________
void TSchemaRule::Streamer(TBuffer &R__b)
{
   // Stream an object of class ROOT::TSchemaRule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ROOT::TSchemaRule::Class(),this);
   } else {
      R__b.WriteClassBuffer(ROOT::TSchemaRule::Class(),this);
   }
}

} // namespace ROOT
namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLTSchemaRule(void *p) {
      return  p ? new(p) ::ROOT::TSchemaRule : new ::ROOT::TSchemaRule;
   }
   static void *newArray_ROOTcLcLTSchemaRule(Long_t nElements, void *p) {
      return p ? new(p) ::ROOT::TSchemaRule[nElements] : new ::ROOT::TSchemaRule[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLTSchemaRule(void *p) {
      delete ((::ROOT::TSchemaRule*)p);
   }
   static void deleteArray_ROOTcLcLTSchemaRule(void *p) {
      delete [] ((::ROOT::TSchemaRule*)p);
   }
   static void destruct_ROOTcLcLTSchemaRule(void *p) {
      typedef ::ROOT::TSchemaRule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::TSchemaRule

namespace ROOT {
//______________________________________________________________________________
void TSchemaRule::TSources::Streamer(TBuffer &R__b)
{
   // Stream an object of class ROOT::TSchemaRule::TSources.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(ROOT::TSchemaRule::TSources::Class(),this);
   } else {
      R__b.WriteClassBuffer(ROOT::TSchemaRule::TSources::Class(),this);
   }
}

} // namespace ROOT
namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLTSchemaRulecLcLTSources(void *p) {
      return  p ? new(p) ::ROOT::TSchemaRule::TSources : new ::ROOT::TSchemaRule::TSources;
   }
   static void *newArray_ROOTcLcLTSchemaRulecLcLTSources(Long_t nElements, void *p) {
      return p ? new(p) ::ROOT::TSchemaRule::TSources[nElements] : new ::ROOT::TSchemaRule::TSources[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLTSchemaRulecLcLTSources(void *p) {
      delete ((::ROOT::TSchemaRule::TSources*)p);
   }
   static void deleteArray_ROOTcLcLTSchemaRulecLcLTSources(void *p) {
      delete [] ((::ROOT::TSchemaRule::TSources*)p);
   }
   static void destruct_ROOTcLcLTSchemaRulecLcLTSources(void *p) {
      typedef ::ROOT::TSchemaRule::TSources current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::TSchemaRule::TSources

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p) {
      return  p ? new(p) ::ROOT::Detail::TSchemaRuleSet : new ::ROOT::Detail::TSchemaRuleSet;
   }
   static void *newArray_ROOTcLcLDetailcLcLTSchemaRuleSet(Long_t nElements, void *p) {
      return p ? new(p) ::ROOT::Detail::TSchemaRuleSet[nElements] : new ::ROOT::Detail::TSchemaRuleSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p) {
      delete ((::ROOT::Detail::TSchemaRuleSet*)p);
   }
   static void deleteArray_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p) {
      delete [] ((::ROOT::Detail::TSchemaRuleSet*)p);
   }
   static void destruct_ROOTcLcLDetailcLcLTSchemaRuleSet(void *p) {
      typedef ::ROOT::Detail::TSchemaRuleSet current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_ROOTcLcLDetailcLcLTSchemaRuleSet(TBuffer &buf, void *obj) {
      ((::ROOT::Detail::TSchemaRuleSet*)obj)->::ROOT::Detail::TSchemaRuleSet::Streamer(buf);
   }
} // end of namespace ROOT for class ::ROOT::Detail::TSchemaRuleSet

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::ROOT::Detail::TStatusBitsChecker : new ::ROOT::Detail::TStatusBitsChecker;
   }
   static void *newArray_ROOTcLcLDetailcLcLTStatusBitsChecker(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::ROOT::Detail::TStatusBitsChecker[nElements] : new ::ROOT::Detail::TStatusBitsChecker[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p) {
      delete ((::ROOT::Detail::TStatusBitsChecker*)p);
   }
   static void deleteArray_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p) {
      delete [] ((::ROOT::Detail::TStatusBitsChecker*)p);
   }
   static void destruct_ROOTcLcLDetailcLcLTStatusBitsChecker(void *p) {
      typedef ::ROOT::Detail::TStatusBitsChecker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Detail::TStatusBitsChecker

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerElement(void *p) {
      return  p ? new(p) ::TStreamerElement : new ::TStreamerElement;
   }
   static void *newArray_TStreamerElement(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerElement[nElements] : new ::TStreamerElement[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerElement(void *p) {
      delete ((::TStreamerElement*)p);
   }
   static void deleteArray_TStreamerElement(void *p) {
      delete [] ((::TStreamerElement*)p);
   }
   static void destruct_TStreamerElement(void *p) {
      typedef ::TStreamerElement current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerElement(TBuffer &buf, void *obj) {
      ((::TStreamerElement*)obj)->::TStreamerElement::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerElement

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerBase(void *p) {
      return  p ? new(p) ::TStreamerBase : new ::TStreamerBase;
   }
   static void *newArray_TStreamerBase(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerBase[nElements] : new ::TStreamerBase[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerBase(void *p) {
      delete ((::TStreamerBase*)p);
   }
   static void deleteArray_TStreamerBase(void *p) {
      delete [] ((::TStreamerBase*)p);
   }
   static void destruct_TStreamerBase(void *p) {
      typedef ::TStreamerBase current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerBase(TBuffer &buf, void *obj) {
      ((::TStreamerBase*)obj)->::TStreamerBase::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerBase

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerBasicPointer(void *p) {
      return  p ? new(p) ::TStreamerBasicPointer : new ::TStreamerBasicPointer;
   }
   static void *newArray_TStreamerBasicPointer(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerBasicPointer[nElements] : new ::TStreamerBasicPointer[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerBasicPointer(void *p) {
      delete ((::TStreamerBasicPointer*)p);
   }
   static void deleteArray_TStreamerBasicPointer(void *p) {
      delete [] ((::TStreamerBasicPointer*)p);
   }
   static void destruct_TStreamerBasicPointer(void *p) {
      typedef ::TStreamerBasicPointer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerBasicPointer(TBuffer &buf, void *obj) {
      ((::TStreamerBasicPointer*)obj)->::TStreamerBasicPointer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerBasicPointer

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerLoop(void *p) {
      return  p ? new(p) ::TStreamerLoop : new ::TStreamerLoop;
   }
   static void *newArray_TStreamerLoop(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerLoop[nElements] : new ::TStreamerLoop[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerLoop(void *p) {
      delete ((::TStreamerLoop*)p);
   }
   static void deleteArray_TStreamerLoop(void *p) {
      delete [] ((::TStreamerLoop*)p);
   }
   static void destruct_TStreamerLoop(void *p) {
      typedef ::TStreamerLoop current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerLoop(TBuffer &buf, void *obj) {
      ((::TStreamerLoop*)obj)->::TStreamerLoop::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerLoop

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerBasicType(void *p) {
      return  p ? new(p) ::TStreamerBasicType : new ::TStreamerBasicType;
   }
   static void *newArray_TStreamerBasicType(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerBasicType[nElements] : new ::TStreamerBasicType[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerBasicType(void *p) {
      delete ((::TStreamerBasicType*)p);
   }
   static void deleteArray_TStreamerBasicType(void *p) {
      delete [] ((::TStreamerBasicType*)p);
   }
   static void destruct_TStreamerBasicType(void *p) {
      typedef ::TStreamerBasicType current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerBasicType(TBuffer &buf, void *obj) {
      ((::TStreamerBasicType*)obj)->::TStreamerBasicType::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerBasicType

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerObject(void *p) {
      return  p ? new(p) ::TStreamerObject : new ::TStreamerObject;
   }
   static void *newArray_TStreamerObject(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerObject[nElements] : new ::TStreamerObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerObject(void *p) {
      delete ((::TStreamerObject*)p);
   }
   static void deleteArray_TStreamerObject(void *p) {
      delete [] ((::TStreamerObject*)p);
   }
   static void destruct_TStreamerObject(void *p) {
      typedef ::TStreamerObject current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerObject(TBuffer &buf, void *obj) {
      ((::TStreamerObject*)obj)->::TStreamerObject::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerObject

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerObjectAny(void *p) {
      return  p ? new(p) ::TStreamerObjectAny : new ::TStreamerObjectAny;
   }
   static void *newArray_TStreamerObjectAny(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerObjectAny[nElements] : new ::TStreamerObjectAny[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerObjectAny(void *p) {
      delete ((::TStreamerObjectAny*)p);
   }
   static void deleteArray_TStreamerObjectAny(void *p) {
      delete [] ((::TStreamerObjectAny*)p);
   }
   static void destruct_TStreamerObjectAny(void *p) {
      typedef ::TStreamerObjectAny current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerObjectAny(TBuffer &buf, void *obj) {
      ((::TStreamerObjectAny*)obj)->::TStreamerObjectAny::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerObjectAny

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerObjectPointer(void *p) {
      return  p ? new(p) ::TStreamerObjectPointer : new ::TStreamerObjectPointer;
   }
   static void *newArray_TStreamerObjectPointer(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerObjectPointer[nElements] : new ::TStreamerObjectPointer[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerObjectPointer(void *p) {
      delete ((::TStreamerObjectPointer*)p);
   }
   static void deleteArray_TStreamerObjectPointer(void *p) {
      delete [] ((::TStreamerObjectPointer*)p);
   }
   static void destruct_TStreamerObjectPointer(void *p) {
      typedef ::TStreamerObjectPointer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerObjectPointer(TBuffer &buf, void *obj) {
      ((::TStreamerObjectPointer*)obj)->::TStreamerObjectPointer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerObjectPointer

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerObjectAnyPointer(void *p) {
      return  p ? new(p) ::TStreamerObjectAnyPointer : new ::TStreamerObjectAnyPointer;
   }
   static void *newArray_TStreamerObjectAnyPointer(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerObjectAnyPointer[nElements] : new ::TStreamerObjectAnyPointer[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerObjectAnyPointer(void *p) {
      delete ((::TStreamerObjectAnyPointer*)p);
   }
   static void deleteArray_TStreamerObjectAnyPointer(void *p) {
      delete [] ((::TStreamerObjectAnyPointer*)p);
   }
   static void destruct_TStreamerObjectAnyPointer(void *p) {
      typedef ::TStreamerObjectAnyPointer current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerObjectAnyPointer(TBuffer &buf, void *obj) {
      ((::TStreamerObjectAnyPointer*)obj)->::TStreamerObjectAnyPointer::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerObjectAnyPointer

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerString(void *p) {
      return  p ? new(p) ::TStreamerString : new ::TStreamerString;
   }
   static void *newArray_TStreamerString(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerString[nElements] : new ::TStreamerString[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerString(void *p) {
      delete ((::TStreamerString*)p);
   }
   static void deleteArray_TStreamerString(void *p) {
      delete [] ((::TStreamerString*)p);
   }
   static void destruct_TStreamerString(void *p) {
      typedef ::TStreamerString current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerString(TBuffer &buf, void *obj) {
      ((::TStreamerString*)obj)->::TStreamerString::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerString

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerSTL(void *p) {
      return  p ? new(p) ::TStreamerSTL : new ::TStreamerSTL;
   }
   static void *newArray_TStreamerSTL(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerSTL[nElements] : new ::TStreamerSTL[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerSTL(void *p) {
      delete ((::TStreamerSTL*)p);
   }
   static void deleteArray_TStreamerSTL(void *p) {
      delete [] ((::TStreamerSTL*)p);
   }
   static void destruct_TStreamerSTL(void *p) {
      typedef ::TStreamerSTL current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerSTL(TBuffer &buf, void *obj) {
      ((::TStreamerSTL*)obj)->::TStreamerSTL::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerSTL

namespace ROOT {
   // Wrappers around operator new
   static void *new_TStreamerSTLstring(void *p) {
      return  p ? new(p) ::TStreamerSTLstring : new ::TStreamerSTLstring;
   }
   static void *newArray_TStreamerSTLstring(Long_t nElements, void *p) {
      return p ? new(p) ::TStreamerSTLstring[nElements] : new ::TStreamerSTLstring[nElements];
   }
   // Wrapper around operator delete
   static void delete_TStreamerSTLstring(void *p) {
      delete ((::TStreamerSTLstring*)p);
   }
   static void deleteArray_TStreamerSTLstring(void *p) {
      delete [] ((::TStreamerSTLstring*)p);
   }
   static void destruct_TStreamerSTLstring(void *p) {
      typedef ::TStreamerSTLstring current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerSTLstring(TBuffer &buf, void *obj) {
      ((::TStreamerSTLstring*)obj)->::TStreamerSTLstring::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerSTLstring

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TStreamerArtificial(void *p) {
      delete ((::TStreamerArtificial*)p);
   }
   static void deleteArray_TStreamerArtificial(void *p) {
      delete [] ((::TStreamerArtificial*)p);
   }
   static void destruct_TStreamerArtificial(void *p) {
      typedef ::TStreamerArtificial current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TStreamerArtificial(TBuffer &buf, void *obj) {
      ((::TStreamerArtificial*)obj)->::TStreamerArtificial::Streamer(buf);
   }
} // end of namespace ROOT for class ::TStreamerArtificial

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualStreamerInfo(void *p) {
      delete ((::TVirtualStreamerInfo*)p);
   }
   static void deleteArray_TVirtualStreamerInfo(void *p) {
      delete [] ((::TVirtualStreamerInfo*)p);
   }
   static void destruct_TVirtualStreamerInfo(void *p) {
      typedef ::TVirtualStreamerInfo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_TVirtualStreamerInfo(TBuffer &buf, void *obj) {
      ((::TVirtualStreamerInfo*)obj)->::TVirtualStreamerInfo::Streamer(buf);
   }
} // end of namespace ROOT for class ::TVirtualStreamerInfo

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualArray(void *p) {
      delete ((::TVirtualArray*)p);
   }
   static void deleteArray_TVirtualArray(void *p) {
      delete [] ((::TVirtualArray*)p);
   }
   static void destruct_TVirtualArray(void *p) {
      typedef ::TVirtualArray current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualArray

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualObject(void *p) {
      delete ((::TVirtualObject*)p);
   }
   static void deleteArray_TVirtualObject(void *p) {
      delete [] ((::TVirtualObject*)p);
   }
   static void destruct_TVirtualObject(void *p) {
      typedef ::TVirtualObject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualObject

namespace ROOT {
   static TClass *vectorlEunsignedsPintgR_Dictionary();
   static void vectorlEunsignedsPintgR_TClassManip(TClass*);
   static void *new_vectorlEunsignedsPintgR(void *p = nullptr);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "vector", 386,
                  typeid(vector<unsigned int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));

      ::ROOT::AddClassAlternate("vector<unsigned int>","std::vector<unsigned int, std::allocator<unsigned int> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEunsignedsPintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)nullptr)->GetClass();
      vectorlEunsignedsPintgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEunsignedsPintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

namespace ROOT {
   static TClass *vectorlEstringgR_Dictionary();
   static void vectorlEstringgR_TClassManip(TClass*);
   static void *new_vectorlEstringgR(void *p = nullptr);
   static void *newArray_vectorlEstringgR(Long_t size, void *p);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<string>*)
   {
      vector<string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<string>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<string>", -2, "vector", 386,
                  typeid(vector<string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEstringgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<string> >()));

      ::ROOT::AddClassAlternate("vector<string>","std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<string>*)nullptr)->GetClass();
      vectorlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<string>[nElements] : new vector<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<string>

namespace ROOT {
   static TClass *vectorlEpairlEintcOintgRsPgR_Dictionary();
   static void vectorlEpairlEintcOintgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEintcOintgRsPgR(void *p = nullptr);
   static void *newArray_vectorlEpairlEintcOintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEintcOintgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEintcOintgRsPgR(void *p);
   static void destruct_vectorlEpairlEintcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<int,int> >*)
   {
      vector<pair<int,int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<int,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<int,int> >", -2, "vector", 386,
                  typeid(vector<pair<int,int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEintcOintgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<int,int> >) );
      instance.SetNew(&new_vectorlEpairlEintcOintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEintcOintgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEintcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEintcOintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEintcOintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<int,int> > >()));

      ::ROOT::AddClassAlternate("vector<pair<int,int> >","std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<pair<int,int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEintcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<int,int> >*)nullptr)->GetClass();
      vectorlEpairlEintcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEintcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEintcOintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<int,int> > : new vector<pair<int,int> >;
   }
   static void *newArray_vectorlEpairlEintcOintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<int,int> >[nElements] : new vector<pair<int,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEintcOintgRsPgR(void *p) {
      delete ((vector<pair<int,int> >*)p);
   }
   static void deleteArray_vectorlEpairlEintcOintgRsPgR(void *p) {
      delete [] ((vector<pair<int,int> >*)p);
   }
   static void destruct_vectorlEpairlEintcOintgRsPgR(void *p) {
      typedef vector<pair<int,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<int,int> >

namespace ROOT {
   static TClass *vectorlEintgR_Dictionary();
   static void vectorlEintgR_TClassManip(TClass*);
   static void *new_vectorlEintgR(void *p = nullptr);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "vector", 386,
                  typeid(vector<int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEintgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));

      ::ROOT::AddClassAlternate("vector<int>","std::vector<int, std::allocator<int> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<int>*)nullptr)->GetClass();
      vectorlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   static TClass *vectorlETStringgR_Dictionary();
   static void vectorlETStringgR_TClassManip(TClass*);
   static void *new_vectorlETStringgR(void *p = nullptr);
   static void *newArray_vectorlETStringgR(Long_t size, void *p);
   static void delete_vectorlETStringgR(void *p);
   static void deleteArray_vectorlETStringgR(void *p);
   static void destruct_vectorlETStringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TString>*)
   {
      vector<TString> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TString>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<TString>", -2, "vector", 386,
                  typeid(vector<TString>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlETStringgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<TString>) );
      instance.SetNew(&new_vectorlETStringgR);
      instance.SetNewArray(&newArray_vectorlETStringgR);
      instance.SetDelete(&delete_vectorlETStringgR);
      instance.SetDeleteArray(&deleteArray_vectorlETStringgR);
      instance.SetDestructor(&destruct_vectorlETStringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TString> >()));

      ::ROOT::AddClassAlternate("vector<TString>","std::vector<TString, std::allocator<TString> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<TString>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlETStringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<TString>*)nullptr)->GetClass();
      vectorlETStringgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlETStringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETStringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TString> : new vector<TString>;
   }
   static void *newArray_vectorlETStringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TString>[nElements] : new vector<TString>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETStringgR(void *p) {
      delete ((vector<TString>*)p);
   }
   static void deleteArray_vectorlETStringgR(void *p) {
      delete [] ((vector<TString>*)p);
   }
   static void destruct_vectorlETStringgR(void *p) {
      typedef vector<TString> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TString>

namespace ROOT {
   static TClass *vectorlETProtoClasscLcLTProtoRealDatagR_Dictionary();
   static void vectorlETProtoClasscLcLTProtoRealDatagR_TClassManip(TClass*);
   static void *new_vectorlETProtoClasscLcLTProtoRealDatagR(void *p = nullptr);
   static void *newArray_vectorlETProtoClasscLcLTProtoRealDatagR(Long_t size, void *p);
   static void delete_vectorlETProtoClasscLcLTProtoRealDatagR(void *p);
   static void deleteArray_vectorlETProtoClasscLcLTProtoRealDatagR(void *p);
   static void destruct_vectorlETProtoClasscLcLTProtoRealDatagR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TProtoClass::TProtoRealData>*)
   {
      vector<TProtoClass::TProtoRealData> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TProtoClass::TProtoRealData>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<TProtoClass::TProtoRealData>", -2, "vector", 386,
                  typeid(vector<TProtoClass::TProtoRealData>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlETProtoClasscLcLTProtoRealDatagR_Dictionary, isa_proxy, 4,
                  sizeof(vector<TProtoClass::TProtoRealData>) );
      instance.SetNew(&new_vectorlETProtoClasscLcLTProtoRealDatagR);
      instance.SetNewArray(&newArray_vectorlETProtoClasscLcLTProtoRealDatagR);
      instance.SetDelete(&delete_vectorlETProtoClasscLcLTProtoRealDatagR);
      instance.SetDeleteArray(&deleteArray_vectorlETProtoClasscLcLTProtoRealDatagR);
      instance.SetDestructor(&destruct_vectorlETProtoClasscLcLTProtoRealDatagR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TProtoClass::TProtoRealData> >()));

      ::ROOT::AddClassAlternate("vector<TProtoClass::TProtoRealData>","std::vector<TProtoClass::TProtoRealData, std::allocator<TProtoClass::TProtoRealData> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<TProtoClass::TProtoRealData>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlETProtoClasscLcLTProtoRealDatagR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<TProtoClass::TProtoRealData>*)nullptr)->GetClass();
      vectorlETProtoClasscLcLTProtoRealDatagR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlETProtoClasscLcLTProtoRealDatagR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETProtoClasscLcLTProtoRealDatagR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TProtoClass::TProtoRealData> : new vector<TProtoClass::TProtoRealData>;
   }
   static void *newArray_vectorlETProtoClasscLcLTProtoRealDatagR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TProtoClass::TProtoRealData>[nElements] : new vector<TProtoClass::TProtoRealData>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETProtoClasscLcLTProtoRealDatagR(void *p) {
      delete ((vector<TProtoClass::TProtoRealData>*)p);
   }
   static void deleteArray_vectorlETProtoClasscLcLTProtoRealDatagR(void *p) {
      delete [] ((vector<TProtoClass::TProtoRealData>*)p);
   }
   static void destruct_vectorlETProtoClasscLcLTProtoRealDatagR(void *p) {
      typedef vector<TProtoClass::TProtoRealData> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TProtoClass::TProtoRealData>

namespace ROOT {
   static TClass *vectorlETDataMembermUgR_Dictionary();
   static void vectorlETDataMembermUgR_TClassManip(TClass*);
   static void *new_vectorlETDataMembermUgR(void *p = nullptr);
   static void *newArray_vectorlETDataMembermUgR(Long_t size, void *p);
   static void delete_vectorlETDataMembermUgR(void *p);
   static void deleteArray_vectorlETDataMembermUgR(void *p);
   static void destruct_vectorlETDataMembermUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TDataMember*>*)
   {
      vector<TDataMember*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TDataMember*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<TDataMember*>", -2, "vector", 386,
                  typeid(vector<TDataMember*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlETDataMembermUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<TDataMember*>) );
      instance.SetNew(&new_vectorlETDataMembermUgR);
      instance.SetNewArray(&newArray_vectorlETDataMembermUgR);
      instance.SetDelete(&delete_vectorlETDataMembermUgR);
      instance.SetDeleteArray(&deleteArray_vectorlETDataMembermUgR);
      instance.SetDestructor(&destruct_vectorlETDataMembermUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TDataMember*> >()));

      ::ROOT::AddClassAlternate("vector<TDataMember*>","std::vector<TDataMember*, std::allocator<TDataMember*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<TDataMember*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlETDataMembermUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<TDataMember*>*)nullptr)->GetClass();
      vectorlETDataMembermUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlETDataMembermUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETDataMembermUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TDataMember*> : new vector<TDataMember*>;
   }
   static void *newArray_vectorlETDataMembermUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<TDataMember*>[nElements] : new vector<TDataMember*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETDataMembermUgR(void *p) {
      delete ((vector<TDataMember*>*)p);
   }
   static void deleteArray_vectorlETDataMembermUgR(void *p) {
      delete [] ((vector<TDataMember*>*)p);
   }
   static void destruct_vectorlETDataMembermUgR(void *p) {
      typedef vector<TDataMember*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TDataMember*>

namespace {
  void TriggerDictionaryInitialization_libCore_Impl() {
    static const char* headers[] = {
nullptr
    };
    static const char* includePaths[] = {
nullptr
    };
    static const char* fwdDeclCode = "";
    static const char* payloadCode = "";
    static const char* classesHeaders[] = {
""
};
    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("libCore",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_libCore_Impl, {}, classesHeaders, /*hasCxxModule*/true);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_libCore_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_libCore() {
  TriggerDictionaryInitialization_libCore_Impl();
}
