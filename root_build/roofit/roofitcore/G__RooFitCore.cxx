// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME G__RooFitCore
#define R__NO_DEPRECATION

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"

#include <RooFitLegacy/RooCatTypeLegacy.h>
#include <RooLinkedList.h>
#include <TSortedList.h>

// Header files passed as explicit arguments
#include "RooFit/Floats.h"
#include "Roo1DTable.h"
#include "RooAbsAnaConvPdf.h"
#include "RooAbsArg.h"
#include "RooAbsBinning.h"
#include "RooAbsCachedPdf.h"
#include "RooAbsCachedReal.h"
#include "RooAbsCacheElement.h"
#include "RooAbsCache.h"
#include "RooAbsCategory.h"
#include "RooAbsCategoryLValue.h"
#include "RooAbsCollection.h"
#include "RooAbsData.h"
#include "RooAbsDataStore.h"
#include "RooAbsFunc.h"
#include "RooAbsGenContext.h"
#include "RooAbsHiddenReal.h"
#include "RooAbsIntegrator.h"
#include "RooAbsLValue.h"
#include "RooAbsMCStudyModule.h"
#include "RooAbsMinimizerFcn.h"
#include "RooAbsMoment.h"
#include "RooAbsNumGenerator.h"
#include "RooAbsOptTestStatistic.h"
#include "RooAbsPdf.h"
#include "RooAbsProxy.h"
#include "RooAbsReal.h"
#include "RooAbsRealLValue.h"
#include "RooAbsRootFinder.h"
#include "RooAbsSelfCachedPdf.h"
#include "RooAbsSelfCachedReal.h"
#include "RooAbsString.h"
#include "RooAbsStudy.h"
#include "RooAbsTestStatistic.h"
#include "RooAcceptReject.h"
#include "RooAdaptiveIntegratorND.h"
#include "RooAddGenContext.h"
#include "RooAddition.h"
#include "RooAddModel.h"
#include "RooAddPdf.h"
#include "RooAICRegistry.h"
#include "RooArgList.h"
#include "RooArgProxy.h"
#include "RooArgSet.h"
#include "RooBinIntegrator.h"
#include "RooBinnedGenContext.h"
#include "RooBinningCategory.h"
#include "RooBinning.h"
#include "RooBrentRootFinder.h"
#include "RooCachedPdf.h"
#include "RooCachedReal.h"
#include "RooCacheManager.h"
#include "RooCategory.h"
#include "RooCategoryProxy.h"
#include "RooChangeTracker.h"
#include "RooChi2Var.h"
#include "RooClassFactory.h"
#include "RooCmdArg.h"
#include "RooCmdConfig.h"
#include "RooCompositeDataStore.h"
#include "RooConstraintSum.h"
#include "RooConstVar.h"
#include "RooConvCoefVar.h"
#include "RooConvGenContext.h"
#include "RooConvIntegrandBinding.h"
#include "RooCurve.h"
#include "RooCustomizer.h"
#include "RooDataHist.h"
#include "RooDataHistSliceIter.h"
#include "RooDataProjBinding.h"
#include "RooDataSet.h"
#include "RooDataWeightedAverage.h"
#include "RooDerivative.h"
#include "RooDirItem.h"
#include "RooDLLSignificanceMCSModule.h"
#include "RooDouble.h"
#include "RooEffGenContext.h"
#include "RooEfficiency.h"
#include "RooEffProd.h"
#include "RooEllipse.h"
#include "RooErrorHandler.h"
#include "RooErrorVar.h"
#include "RooExpensiveObjectCache.h"
#include "RooExtendedBinding.h"
#include "RooExtendedTerm.h"
#include "RooExtendPdf.h"
#include "RooFactoryWSTool.h"
#include "RooFFTConvPdf.h"
#include "RooFirstMoment.h"
#include "RooFit.h"
#include "RooFitResult.h"
#include "RooFoamGenerator.h"
#include "RooFormula.h"
#include "RooFormulaVar.h"
#include "RooFracRemainder.h"
#include "RooFunctor.h"
#include "RooGenContext.h"
#include "RooGenericPdf.h"
#include "RooGenFitStudy.h"
#include "RooGenFunction.h"
#include "RooGenProdProj.h"
#include "RooGlobalFunc.h"
#include "RooGrid.h"
#include "RooHistError.h"
#include "RooHistFunc.h"
#include "RooHist.h"
#include "RooHistPdf.h"
#include "RooImproperIntegrator1D.h"
#include "RooIntegrator1D.h"
#include "RooIntegrator2D.h"
#include "RooIntegratorBinding.h"
#include "RooInt.h"
#include "RooInvTransform.h"
#include "RooLinearCombination.h"
#include "RooLinearVar.h"
#include "RooLinkedListElem.h"
#include "RooLinkedList.h"
#include "RooLinkedListIter.h"
#include "RooLinTransBinning.h"
#include "RooList.h"
#include "RooListProxy.h"
#include "RooMappedCategory.h"
#include "RooMCIntegrator.h"
#include "RooMCStudy.h"
#include "RooMinimizerFcn.h"
#include "RooMinimizer.h"
#include "RooMoment.h"
#include "RooMPSentinel.h"
#include "RooMsgService.h"
#include "RooMultiCategory.h"
#include "RooMultiGenFunction.h"
#include "RooMultiVarGaussian.h"
#include "RooNameReg.h"
#include "RooNLLVar.h"
#include "RooNormSetCache.h"
#include "RooNumber.h"
#include "RooNumCdf.h"
#include "RooNumConvolution.h"
#include "RooNumConvPdf.h"
#include "RooNumGenConfig.h"
#include "RooNumGenFactory.h"
#include "RooNumIntConfig.h"
#include "RooNumIntFactory.h"
#include "RooNumRunningInt.h"
#include "RooObjCacheManager.h"
#include "RooParamBinning.h"
#include "RooPlotable.h"
#include "RooPlot.h"
#include "RooPolyFunc.h"
#include "RooPolyVar.h"
#include "RooPrintable.h"
#include "RooProdGenContext.h"
#include "RooProdPdf.h"
#include "RooProduct.h"
#include "RooProfileLL.h"
#include "RooProjectedPdf.h"
#include "RooProofDriverSelector.h"
#include "RooPullVar.h"
#include "RooQuasiRandomGenerator.h"
#include "RooRatio.h"
#include "RooRandom.h"
#include "RooRandomizeParamMCSModule.h"
#include "RooRangeBinning.h"
#include "RooRangeBoolean.h"
#include "RooRealAnalytic.h"
#include "RooRealBinding.h"
#include "RooRealConstant.h"
#include "RooRealIntegral.h"
#include "RooRealMPFE.h"
#include "RooTemplateProxy.h"
#include "RooRealProxy.h"
#include "RooRealSumFunc.h"
#include "RooRealSumPdf.h"
#include "RooRealVar.h"
#include "RooRealVarSharedProperties.h"
#include "RooRecursiveFraction.h"
#include "RooRefCountList.h"
#include "RooSTLRefCountList.h"
#include "RooResolutionModel.h"
#include "RooScaledFunc.h"
#include "RooSecondMoment.h"
#include "RooSegmentedIntegrator1D.h"
#include "RooSegmentedIntegrator2D.h"
#include "RooSentinel.h"
#include "RooSetProxy.h"
#include "RooSharedProperties.h"
#include "RooSimGenContext.h"
#include "RooSimPdfBuilder.h"
#include "RooSimSplitGenContext.h"
#include "RooSimultaneous.h"
#include "RooSimWSTool.h"
#include "RooStreamParser.h"
#include "RooStringVar.h"
#include "RooStudyManager.h"
#include "RooStudyPackage.h"
#include "RooSuperCategory.h"
#include "RooTable.h"
#include "RooTFoamBinding.h"
#include "RooThresholdCategory.h"
#include "RooTObjWrap.h"
#include "RooTrace.h"
#include "RooTreeDataStore.h"
#include "RooTruthModel.h"
#include "RooUniformBinning.h"
#include "RooUnitTest.h"
#include "RooVectorDataStore.h"
#include "RooWorkspace.h"
#include "RooWorkspaceHandle.h"
#include "RooXYChi2Var.h"
#include "RooHelpers.h"
#include "RooWrapperPdf.h"
#include "RooNaNPacker.h"
#include "RooBinSamplingPdf.h"
#include "RooBinWidthFunction.h"
#include "RooFitLegacy/RooCatTypeLegacy.h"
#include "RooFitLegacy/RooCategorySharedProperties.h"
#include "RooFitLegacy/RooHashTable.h"
#include "RooFitLegacy/RooMinuit.h"
#include "RooFitLegacy/RooNameSet.h"
#include "RooFitLegacy/RooSetPair.h"
#include "RooFitLegacy/RooTreeData.h"
#include "RooFit/TestStatistics/LikelihoodGradientWrapper.h"
#include "RooFit/TestStatistics/LikelihoodWrapper.h"
#include "RooFit/TestStatistics/RooAbsL.h"
#include "RooFit/TestStatistics/RooBinnedL.h"
#include "RooFit/TestStatistics/RooSubsidiaryL.h"
#include "RooFit/TestStatistics/RooSumL.h"
#include "RooFit/TestStatistics/RooRealL.h"
#include "RooFit/TestStatistics/RooUnbinnedL.h"
#include "RooFit/TestStatistics/optional_parameter_types.h"
#include "RooFit/TestStatistics/buildLikelihood.h"

// Header files passed via #pragma extra_include

// The generated code does not explicitly qualify STL entities
namespace std {} using namespace std;

namespace RooFit {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *RooFit_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("RooFit", 0 /*version*/, "RooFit/Floats.h", 23,
                     ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),
                     &RooFit_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *RooFit_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace RooFitShortHand {
   namespace ROOTDict {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static TClass *RooFitShortHand_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("RooFitShortHand", 0 /*version*/, "RooArgSet.h", 216,
                     ::ROOT::Internal::DefineBehavior((void*)nullptr,(void*)nullptr),
                     &RooFitShortHand_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_DICT_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_DICT_(Init));

      // Dictionary for non-ClassDef classes
      static TClass *RooFitShortHand_Dictionary() {
         return GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOT {
   static TClass *pairlEintcORooLinkedListElemmUgR_Dictionary();
   static void pairlEintcORooLinkedListElemmUgR_TClassManip(TClass*);
   static void *new_pairlEintcORooLinkedListElemmUgR(void *p = nullptr);
   static void *newArray_pairlEintcORooLinkedListElemmUgR(Long_t size, void *p);
   static void delete_pairlEintcORooLinkedListElemmUgR(void *p);
   static void deleteArray_pairlEintcORooLinkedListElemmUgR(void *p);
   static void destruct_pairlEintcORooLinkedListElemmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,RooLinkedListElem*>*)
   {
      pair<int,RooLinkedListElem*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,RooLinkedListElem*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,RooLinkedListElem*>", "utility", 208,
                  typeid(pair<int,RooLinkedListElem*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEintcORooLinkedListElemmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,RooLinkedListElem*>) );
      instance.SetNew(&new_pairlEintcORooLinkedListElemmUgR);
      instance.SetNewArray(&newArray_pairlEintcORooLinkedListElemmUgR);
      instance.SetDelete(&delete_pairlEintcORooLinkedListElemmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcORooLinkedListElemmUgR);
      instance.SetDestructor(&destruct_pairlEintcORooLinkedListElemmUgR);

      ::ROOT::AddClassAlternate("pair<int,RooLinkedListElem*>","std::pair<int, RooLinkedListElem*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<int,RooLinkedListElem*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEintcORooLinkedListElemmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<int,RooLinkedListElem*>*)nullptr)->GetClass();
      pairlEintcORooLinkedListElemmUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEintcORooLinkedListElemmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEstringcORooAbsDatamUgR_Dictionary();
   static void pairlEstringcORooAbsDatamUgR_TClassManip(TClass*);
   static void *new_pairlEstringcORooAbsDatamUgR(void *p = nullptr);
   static void *newArray_pairlEstringcORooAbsDatamUgR(Long_t size, void *p);
   static void delete_pairlEstringcORooAbsDatamUgR(void *p);
   static void deleteArray_pairlEstringcORooAbsDatamUgR(void *p);
   static void destruct_pairlEstringcORooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,RooAbsData*>*)
   {
      pair<string,RooAbsData*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,RooAbsData*>", "utility", 208,
                  typeid(pair<string,RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEstringcORooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,RooAbsData*>) );
      instance.SetNew(&new_pairlEstringcORooAbsDatamUgR);
      instance.SetNewArray(&newArray_pairlEstringcORooAbsDatamUgR);
      instance.SetDelete(&delete_pairlEstringcORooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcORooAbsDatamUgR);
      instance.SetDestructor(&destruct_pairlEstringcORooAbsDatamUgR);

      ::ROOT::AddClassAlternate("pair<string,RooAbsData*>","pair<std::string,RooAbsData*>");

      ::ROOT::AddClassAlternate("pair<string,RooAbsData*>","std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsData*>");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const pair<string,RooAbsData*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEstringcORooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<string,RooAbsData*>*)nullptr)->GetClass();
      pairlEstringcORooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEstringcORooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary();
   static void stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(TClass*);
   static void *new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p = nullptr);
   static void *newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(Long_t size, void *p);
   static void delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);
   static void deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);
   static void destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)
   {
      ::stack<RooAbsArg*,deque<RooAbsArg*> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::stack<RooAbsArg*,deque<RooAbsArg*> >));
      static ::ROOT::TGenericClassInfo 
         instance("stack<RooAbsArg*,deque<RooAbsArg*> >", "stack", 99,
                  typeid(::stack<RooAbsArg*,deque<RooAbsArg*> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::stack<RooAbsArg*,deque<RooAbsArg*> >) );
      instance.SetNew(&new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetNewArray(&newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDelete(&delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDeleteArray(&deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);
      instance.SetDestructor(&destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR);

      ::ROOT::AddClassAlternate("stack<RooAbsArg*,deque<RooAbsArg*> >","std::stack<RooAbsArg*, std::deque<RooAbsArg*, std::allocator<RooAbsArg*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::stack<RooAbsArg*,deque<RooAbsArg*> >*)nullptr)->GetClass();
      stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPrintable(void *p = nullptr);
   static void *newArray_RooPrintable(Long_t size, void *p);
   static void delete_RooPrintable(void *p);
   static void deleteArray_RooPrintable(void *p);
   static void destruct_RooPrintable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPrintable*)
   {
      ::RooPrintable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPrintable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPrintable", ::RooPrintable::Class_Version(), "RooPrintable.h", 25,
                  typeid(::RooPrintable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPrintable::Dictionary, isa_proxy, 4,
                  sizeof(::RooPrintable) );
      instance.SetNew(&new_RooPrintable);
      instance.SetNewArray(&newArray_RooPrintable);
      instance.SetDelete(&delete_RooPrintable);
      instance.SetDeleteArray(&deleteArray_RooPrintable);
      instance.SetDestructor(&destruct_RooPrintable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPrintable*)
   {
      return GenerateInitInstanceLocal((::RooPrintable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPrintable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooSTLRefCountListlERooAbsArggR_Dictionary();
   static void RooSTLRefCountListlERooAbsArggR_TClassManip(TClass*);
   static void *new_RooSTLRefCountListlERooAbsArggR(void *p = nullptr);
   static void *newArray_RooSTLRefCountListlERooAbsArggR(Long_t size, void *p);
   static void delete_RooSTLRefCountListlERooAbsArggR(void *p);
   static void deleteArray_RooSTLRefCountListlERooAbsArggR(void *p);
   static void destruct_RooSTLRefCountListlERooAbsArggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSTLRefCountList<RooAbsArg>*)
   {
      ::RooSTLRefCountList<RooAbsArg> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSTLRefCountList<RooAbsArg> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSTLRefCountList<RooAbsArg>", ::RooSTLRefCountList<RooAbsArg>::Class_Version(), "RooSTLRefCountList.h", 39,
                  typeid(::RooSTLRefCountList<RooAbsArg>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooSTLRefCountListlERooAbsArggR_Dictionary, isa_proxy, 4,
                  sizeof(::RooSTLRefCountList<RooAbsArg>) );
      instance.SetNew(&new_RooSTLRefCountListlERooAbsArggR);
      instance.SetNewArray(&newArray_RooSTLRefCountListlERooAbsArggR);
      instance.SetDelete(&delete_RooSTLRefCountListlERooAbsArggR);
      instance.SetDeleteArray(&deleteArray_RooSTLRefCountListlERooAbsArggR);
      instance.SetDestructor(&destruct_RooSTLRefCountListlERooAbsArggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSTLRefCountList<RooAbsArg>*)
   {
      return GenerateInitInstanceLocal((::RooSTLRefCountList<RooAbsArg>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooSTLRefCountListlERooAbsArggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr)->GetClass();
      RooSTLRefCountListlERooAbsArggR_TClassManip(theClass);
   return theClass;
   }

   static void RooSTLRefCountListlERooAbsArggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAbsCache(void *p = nullptr);
   static void *newArray_RooAbsCache(Long_t size, void *p);
   static void delete_RooAbsCache(void *p);
   static void deleteArray_RooAbsCache(void *p);
   static void destruct_RooAbsCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCache*)
   {
      ::RooAbsCache *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCache >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCache", ::RooAbsCache::Class_Version(), "RooAbsCache.h", 27,
                  typeid(::RooAbsCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCache) );
      instance.SetNew(&new_RooAbsCache);
      instance.SetNewArray(&newArray_RooAbsCache);
      instance.SetDelete(&delete_RooAbsCache);
      instance.SetDeleteArray(&deleteArray_RooAbsCache);
      instance.SetDestructor(&destruct_RooAbsCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCache*)
   {
      return GenerateInitInstanceLocal((::RooAbsCache*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCache*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinkedListElem(void *p = nullptr);
   static void *newArray_RooLinkedListElem(Long_t size, void *p);
   static void delete_RooLinkedListElem(void *p);
   static void deleteArray_RooLinkedListElem(void *p);
   static void destruct_RooLinkedListElem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinkedListElem*)
   {
      ::RooLinkedListElem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinkedListElem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinkedListElem", ::RooLinkedListElem::Class_Version(), "RooLinkedListElem.h", 30,
                  typeid(::RooLinkedListElem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinkedListElem::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinkedListElem) );
      instance.SetNew(&new_RooLinkedListElem);
      instance.SetNewArray(&newArray_RooLinkedListElem);
      instance.SetDelete(&delete_RooLinkedListElem);
      instance.SetDeleteArray(&deleteArray_RooLinkedListElem);
      instance.SetDestructor(&destruct_RooLinkedListElem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinkedListElem*)
   {
      return GenerateInitInstanceLocal((::RooLinkedListElem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinkedListElem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinkedList(void *p = nullptr);
   static void *newArray_RooLinkedList(Long_t size, void *p);
   static void delete_RooLinkedList(void *p);
   static void deleteArray_RooLinkedList(void *p);
   static void destruct_RooLinkedList(void *p);
   static void streamer_RooLinkedList(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinkedList*)
   {
      ::RooLinkedList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinkedList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinkedList", ::RooLinkedList::Class_Version(), "RooLinkedList.h", 38,
                  typeid(::RooLinkedList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinkedList::Dictionary, isa_proxy, 17,
                  sizeof(::RooLinkedList) );
      instance.SetNew(&new_RooLinkedList);
      instance.SetNewArray(&newArray_RooLinkedList);
      instance.SetDelete(&delete_RooLinkedList);
      instance.SetDeleteArray(&deleteArray_RooLinkedList);
      instance.SetDestructor(&destruct_RooLinkedList);
      instance.SetStreamerFunc(&streamer_RooLinkedList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinkedList*)
   {
      return GenerateInitInstanceLocal((::RooLinkedList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinkedList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooFIter_Dictionary();
   static void RooFIter_TClassManip(TClass*);
   static void delete_RooFIter(void *p);
   static void deleteArray_RooFIter(void *p);
   static void destruct_RooFIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFIter*)
   {
      ::RooFIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooFIter));
      static ::ROOT::TGenericClassInfo 
         instance("RooFIter", "RooLinkedListIter.h", 39,
                  typeid(::RooFIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooFIter_Dictionary, isa_proxy, 4,
                  sizeof(::RooFIter) );
      instance.SetDelete(&delete_RooFIter);
      instance.SetDeleteArray(&deleteArray_RooFIter);
      instance.SetDestructor(&destruct_RooFIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFIter*)
   {
      return GenerateInitInstanceLocal((::RooFIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooFIter_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooFIter*)nullptr)->GetClass();
      RooFIter_TClassManip(theClass);
   return theClass;
   }

   static void RooFIter_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRefArray(void *p = nullptr);
   static void *newArray_RooRefArray(Long_t size, void *p);
   static void delete_RooRefArray(void *p);
   static void deleteArray_RooRefArray(void *p);
   static void destruct_RooRefArray(void *p);
   static void streamer_RooRefArray(TBuffer &buf, void *obj);
   static Long64_t merge_RooRefArray(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRefArray*)
   {
      ::RooRefArray *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRefArray >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRefArray", ::RooRefArray::Class_Version(), "RooAbsArg.h", 57,
                  typeid(::RooRefArray), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRefArray::Dictionary, isa_proxy, 17,
                  sizeof(::RooRefArray) );
      instance.SetNew(&new_RooRefArray);
      instance.SetNewArray(&newArray_RooRefArray);
      instance.SetDelete(&delete_RooRefArray);
      instance.SetDeleteArray(&deleteArray_RooRefArray);
      instance.SetDestructor(&destruct_RooRefArray);
      instance.SetStreamerFunc(&streamer_RooRefArray);
      instance.SetMerge(&merge_RooRefArray);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRefArray*)
   {
      return GenerateInitInstanceLocal((::RooRefArray*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRefArray*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsArg(void *p);
   static void deleteArray_RooAbsArg(void *p);
   static void destruct_RooAbsArg(void *p);
   static void streamer_RooAbsArg(TBuffer &buf, void *obj);

   // Schema evolution read functions
   static void read_RooAbsArg_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__proxyList = oldObj->GetId("_proxyList");
#endif
      struct RooAbsArg_Onfile {
         TList &_proxyList;
         RooAbsArg_Onfile(TList &onfile__proxyList ): _proxyList(onfile__proxyList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__proxyList = oldObj->GetClass()->GetDataMemberOffset("_proxyList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(TList*)(onfile_add+offset_Onfile_RooAbsArg__proxyList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__proxyList = cls->GetDataMemberOffset("_proxyList");
      RooRefArray& _proxyList = *(RooRefArray*)(target+offset__proxyList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      TIterator* iter = onfile._proxyList.MakeIterator() ; TObject* tmpObj ; while ((tmpObj = iter->Next())) { _proxyList.Add(tmpObj) ; } delete iter ; 
   }
   static void read_RooAbsArg_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__proxyList = oldObj->GetId("_proxyList");
#endif
      struct RooAbsArg_Onfile {
         TRefArray &_proxyList;
         RooAbsArg_Onfile(TRefArray &onfile__proxyList ): _proxyList(onfile__proxyList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__proxyList = oldObj->GetClass()->GetDataMemberOffset("_proxyList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(TRefArray*)(onfile_add+offset_Onfile_RooAbsArg__proxyList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__proxyList = cls->GetDataMemberOffset("_proxyList");
      RooRefArray& _proxyList = *(RooRefArray*)(target+offset__proxyList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _proxyList.GetSize() ; if (onfile._proxyList.GetSize()>0) { RooAbsArg::_ioEvoList[newObj] = std::make_unique<TRefArray>(onfile._proxyList); } 
   }
   static void read_RooAbsArg_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__serverList = oldObj->GetId("_serverList");
#endif
      struct RooAbsArg_Onfile {
         RooRefCountList &_serverList;
         RooAbsArg_Onfile(RooRefCountList &onfile__serverList ): _serverList(onfile__serverList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__serverList = oldObj->GetClass()->GetDataMemberOffset("_serverList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(RooRefCountList*)(onfile_add+offset_Onfile_RooAbsArg__serverList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__serverList = cls->GetDataMemberOffset("_serverList");
      RooAbsArg::RefCountList_t& _serverList = *(RooAbsArg::RefCountList_t*)(target+offset__serverList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _serverList = RooFit::STLRefCountListHelpers::convert(onfile._serverList); 
   }
   static void read_RooAbsArg_3( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__clientList = oldObj->GetId("_clientList");
#endif
      struct RooAbsArg_Onfile {
         RooRefCountList &_clientList;
         RooAbsArg_Onfile(RooRefCountList &onfile__clientList ): _clientList(onfile__clientList) {}
      };
      static Long_t offset_Onfile_RooAbsArg__clientList = oldObj->GetClass()->GetDataMemberOffset("_clientList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(RooRefCountList*)(onfile_add+offset_Onfile_RooAbsArg__clientList) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__clientList = cls->GetDataMemberOffset("_clientList");
      RooAbsArg::RefCountList_t& _clientList = *(RooAbsArg::RefCountList_t*)(target+offset__clientList);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _clientList = RooFit::STLRefCountListHelpers::convert(onfile._clientList); 
   }
   static void read_RooAbsArg_4( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__clientListValue = oldObj->GetId("_clientListValue");
#endif
      struct RooAbsArg_Onfile {
         RooRefCountList &_clientListValue;
         RooAbsArg_Onfile(RooRefCountList &onfile__clientListValue ): _clientListValue(onfile__clientListValue) {}
      };
      static Long_t offset_Onfile_RooAbsArg__clientListValue = oldObj->GetClass()->GetDataMemberOffset("_clientListValue");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(RooRefCountList*)(onfile_add+offset_Onfile_RooAbsArg__clientListValue) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__clientListValue = cls->GetDataMemberOffset("_clientListValue");
      RooAbsArg::RefCountList_t& _clientListValue = *(RooAbsArg::RefCountList_t*)(target+offset__clientListValue);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _clientListValue = RooFit::STLRefCountListHelpers::convert(onfile._clientListValue); 
   }
   static void read_RooAbsArg_5( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__clientListShape = oldObj->GetId("_clientListShape");
#endif
      struct RooAbsArg_Onfile {
         RooRefCountList &_clientListShape;
         RooAbsArg_Onfile(RooRefCountList &onfile__clientListShape ): _clientListShape(onfile__clientListShape) {}
      };
      static Long_t offset_Onfile_RooAbsArg__clientListShape = oldObj->GetClass()->GetDataMemberOffset("_clientListShape");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsArg_Onfile onfile(
         *(RooRefCountList*)(onfile_add+offset_Onfile_RooAbsArg__clientListShape) );

      static TClassRef cls("RooAbsArg");
      static Long_t offset__clientListShape = cls->GetDataMemberOffset("_clientListShape");
      RooAbsArg::RefCountList_t& _clientListShape = *(RooAbsArg::RefCountList_t*)(target+offset__clientListShape);
      RooAbsArg* newObj = (RooAbsArg*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _clientListShape = RooFit::STLRefCountListHelpers::convert(onfile._clientListShape); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsArg*)
   {
      ::RooAbsArg *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsArg >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsArg", ::RooAbsArg::Class_Version(), "RooAbsArg.h", 75,
                  typeid(::RooAbsArg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsArg::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsArg) );
      instance.SetDelete(&delete_RooAbsArg);
      instance.SetDeleteArray(&deleteArray_RooAbsArg);
      instance.SetDestructor(&destruct_RooAbsArg);
      instance.SetStreamerFunc(&streamer_RooAbsArg);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(6);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_proxyList";
      rule->fSource      = "TList _proxyList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_0);
      rule->fCode        = " TIterator* iter = onfile._proxyList.MakeIterator() ; TObject* tmpObj ; while ((tmpObj = iter->Next())) { _proxyList.Add(tmpObj) ; } delete iter ; ";
      rule->fVersion     = "[1-4]";
      rule = &readrules[1];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_proxyList";
      rule->fSource      = "TRefArray _proxyList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_1);
      rule->fCode        = " _proxyList.GetSize() ; if (onfile._proxyList.GetSize()>0) { RooAbsArg::_ioEvoList[newObj] = std::make_unique<TRefArray>(onfile._proxyList); } ";
      rule->fVersion     = "[5]";
      rule = &readrules[2];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_serverList";
      rule->fSource      = "RooRefCountList _serverList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_2);
      rule->fCode        = " _serverList = RooFit::STLRefCountListHelpers::convert(onfile._serverList); ";
      rule->fVersion     = "[1-6]";
      rule = &readrules[3];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_clientList";
      rule->fSource      = "RooRefCountList _clientList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_3);
      rule->fCode        = " _clientList = RooFit::STLRefCountListHelpers::convert(onfile._clientList); ";
      rule->fVersion     = "[1-6]";
      rule = &readrules[4];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_clientListValue";
      rule->fSource      = "RooRefCountList _clientListValue";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_4);
      rule->fCode        = " _clientListValue = RooFit::STLRefCountListHelpers::convert(onfile._clientListValue); ";
      rule->fVersion     = "[1-6]";
      rule = &readrules[5];
      rule->fSourceClass = "RooAbsArg";
      rule->fTarget      = "_clientListShape";
      rule->fSource      = "RooRefCountList _clientListShape";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsArg_5);
      rule->fCode        = " _clientListShape = RooFit::STLRefCountListHelpers::convert(onfile._clientListShape); ";
      rule->fVersion     = "[1-6]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsArg*)
   {
      return GenerateInitInstanceLocal((::RooAbsArg*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsArg*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCatType(void *p = nullptr);
   static void *newArray_RooCatType(Long_t size, void *p);
   static void delete_RooCatType(void *p);
   static void deleteArray_RooCatType(void *p);
   static void destruct_RooCatType(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCatType*)
   {
      ::RooCatType *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCatType >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCatType", ::RooCatType::Class_Version(), "RooFitLegacy/RooCatTypeLegacy.h", 23,
                  typeid(::RooCatType), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCatType::Dictionary, isa_proxy, 4,
                  sizeof(::RooCatType) );
      instance.SetNew(&new_RooCatType);
      instance.SetNewArray(&newArray_RooCatType);
      instance.SetDelete(&delete_RooCatType);
      instance.SetDeleteArray(&deleteArray_RooCatType);
      instance.SetDestructor(&destruct_RooCatType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCatType*)
   {
      return GenerateInitInstanceLocal((::RooCatType*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCatType*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCategory(void *p);
   static void deleteArray_RooAbsCategory(void *p);
   static void destruct_RooAbsCategory(void *p);

   // Schema evolution read functions
   static void read_RooAbsCategory_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__types = oldObj->GetId("_types");
#endif
      struct RooAbsCategory_Onfile {
         TObjArray &_types;
         RooAbsCategory_Onfile(TObjArray &onfile__types ): _types(onfile__types) {}
      };
      static Long_t offset_Onfile_RooAbsCategory__types = oldObj->GetClass()->GetDataMemberOffset("_types");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsCategory_Onfile onfile(
         *(TObjArray*)(onfile_add+offset_Onfile_RooAbsCategory__types) );

      static TClassRef cls("RooAbsCategory");
      static Long_t offset__stateNames = cls->GetDataMemberOffset("_stateNames");
      map<string,RooAbsCategory::value_type>& _stateNames = *(map<string,RooAbsCategory::value_type>*)(target+offset__stateNames);
      static Long_t offset__insertionOrder = cls->GetDataMemberOffset("_insertionOrder");
      vector<string>& _insertionOrder = *(vector<string>*)(target+offset__insertionOrder);
      RooAbsCategory* newObj = (RooAbsCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     for (const auto* obj : onfile._types) { \
           auto catType = dynamic_cast<const RooCatType*>(obj); assert(catType); \
           _stateNames[catType->GetName()] = catType->getVal(); \
           _insertionOrder.push_back(catType->GetName()); \
         }
   }
   static void read_RooAbsCategory_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__types = oldObj->GetId("_types");
#endif
      struct RooAbsCategory_Onfile {
         std::vector<RooCatType*> &_types;
         RooAbsCategory_Onfile(std::vector<RooCatType*> &onfile__types ): _types(onfile__types) {}
      };
      static Long_t offset_Onfile_RooAbsCategory__types = oldObj->GetClass()->GetDataMemberOffset("_types");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsCategory_Onfile onfile(
         *(std::vector<RooCatType*>*)(onfile_add+offset_Onfile_RooAbsCategory__types) );

      static TClassRef cls("RooAbsCategory");
      static Long_t offset__stateNames = cls->GetDataMemberOffset("_stateNames");
      map<string,RooAbsCategory::value_type>& _stateNames = *(map<string,RooAbsCategory::value_type>*)(target+offset__stateNames);
      static Long_t offset__insertionOrder = cls->GetDataMemberOffset("_insertionOrder");
      vector<string>& _insertionOrder = *(vector<string>*)(target+offset__insertionOrder);
      RooAbsCategory* newObj = (RooAbsCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     for (const auto catType : onfile._types) { _stateNames[catType->GetName()] = catType->getVal();\
                                                    _insertionOrder.push_back(catType->GetName());\
                                                  } 
   }
   static void read_RooAbsCategory_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__value = oldObj->GetId("_value");
#endif
      struct RooAbsCategory_Onfile {
         RooCatType &_value;
         RooAbsCategory_Onfile(RooCatType &onfile__value ): _value(onfile__value) {}
      };
      static Long_t offset_Onfile_RooAbsCategory__value = oldObj->GetClass()->GetDataMemberOffset("_value");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsCategory_Onfile onfile(
         *(RooCatType*)(onfile_add+offset_Onfile_RooAbsCategory__value) );

      static TClassRef cls("RooAbsCategory");
      static Long_t offset__currentIndex = cls->GetDataMemberOffset("_currentIndex");
      RooAbsCategory::value_type& _currentIndex = *(RooAbsCategory::value_type*)(target+offset__currentIndex);
      RooAbsCategory* newObj = (RooAbsCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _currentIndex = onfile._value.getVal(); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCategory*)
   {
      ::RooAbsCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCategory", ::RooAbsCategory::Class_Version(), "RooAbsCategory.h", 37,
                  typeid(::RooAbsCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCategory) );
      instance.SetDelete(&delete_RooAbsCategory);
      instance.SetDeleteArray(&deleteArray_RooAbsCategory);
      instance.SetDestructor(&destruct_RooAbsCategory);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(3);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsCategory";
      rule->fTarget      = "_stateNames,_insertionOrder";
      rule->fSource      = "TObjArray _types";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCategory_0);
      rule->fCode        = "for (const auto* obj : onfile._types) { \\n           auto catType = dynamic_cast<const RooCatType*>(obj); assert(catType); \\n           _stateNames[catType->GetName()] = catType->getVal(); \\n           _insertionOrder.push_back(catType->GetName()); \\n         }";
      rule->fVersion     = "[1]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      rule = &readrules[1];
      rule->fSourceClass = "RooAbsCategory";
      rule->fTarget      = "_stateNames,_insertionOrder";
      rule->fSource      = "std::vector<RooCatType*> _types";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCategory_1);
      rule->fCode        = "for (const auto catType : onfile._types) { _stateNames[catType->GetName()] = catType->getVal();\\n                                                    _insertionOrder.push_back(catType->GetName());\\n                                                  } ";
      rule->fVersion     = "[2]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      rule = &readrules[2];
      rule->fSourceClass = "RooAbsCategory";
      rule->fTarget      = "_currentIndex";
      rule->fSource      = "RooCatType _value";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCategory_2);
      rule->fCode        = " _currentIndex = onfile._value.getVal(); ";
      rule->fVersion     = "[1-2]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCategory*)
   {
      return GenerateInitInstanceLocal((::RooAbsCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTable(void *p);
   static void deleteArray_RooTable(void *p);
   static void destruct_RooTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTable*)
   {
      ::RooTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTable", ::RooTable::Class_Version(), "RooTable.h", 23,
                  typeid(::RooTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTable::Dictionary, isa_proxy, 4,
                  sizeof(::RooTable) );
      instance.SetDelete(&delete_RooTable);
      instance.SetDeleteArray(&deleteArray_RooTable);
      instance.SetDestructor(&destruct_RooTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTable*)
   {
      return GenerateInitInstanceLocal((::RooTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_Roo1DTable(void *p = nullptr);
   static void *newArray_Roo1DTable(Long_t size, void *p);
   static void delete_Roo1DTable(void *p);
   static void deleteArray_Roo1DTable(void *p);
   static void destruct_Roo1DTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Roo1DTable*)
   {
      ::Roo1DTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::Roo1DTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("Roo1DTable", ::Roo1DTable::Class_Version(), "Roo1DTable.h", 23,
                  typeid(::Roo1DTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::Roo1DTable::Dictionary, isa_proxy, 4,
                  sizeof(::Roo1DTable) );
      instance.SetNew(&new_Roo1DTable);
      instance.SetNewArray(&newArray_Roo1DTable);
      instance.SetDelete(&delete_Roo1DTable);
      instance.SetDeleteArray(&deleteArray_Roo1DTable);
      instance.SetDestructor(&destruct_Roo1DTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Roo1DTable*)
   {
      return GenerateInitInstanceLocal((::Roo1DTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::Roo1DTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCmdArg(void *p = nullptr);
   static void *newArray_RooCmdArg(Long_t size, void *p);
   static void delete_RooCmdArg(void *p);
   static void deleteArray_RooCmdArg(void *p);
   static void destruct_RooCmdArg(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCmdArg*)
   {
      ::RooCmdArg *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCmdArg >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCmdArg", ::RooCmdArg::Class_Version(), "RooCmdArg.h", 27,
                  typeid(::RooCmdArg), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCmdArg::Dictionary, isa_proxy, 4,
                  sizeof(::RooCmdArg) );
      instance.SetNew(&new_RooCmdArg);
      instance.SetNewArray(&newArray_RooCmdArg);
      instance.SetDelete(&delete_RooCmdArg);
      instance.SetDeleteArray(&deleteArray_RooCmdArg);
      instance.SetDestructor(&destruct_RooCmdArg);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCmdArg*)
   {
      return GenerateInitInstanceLocal((::RooCmdArg*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCmdArg*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooPlotable(void *p);
   static void deleteArray_RooPlotable(void *p);
   static void destruct_RooPlotable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPlotable*)
   {
      ::RooPlotable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPlotable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPlotable", ::RooPlotable::Class_Version(), "RooPlotable.h", 26,
                  typeid(::RooPlotable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPlotable::Dictionary, isa_proxy, 4,
                  sizeof(::RooPlotable) );
      instance.SetDelete(&delete_RooPlotable);
      instance.SetDeleteArray(&deleteArray_RooPlotable);
      instance.SetDestructor(&destruct_RooPlotable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPlotable*)
   {
      return GenerateInitInstanceLocal((::RooPlotable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPlotable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCurve(void *p = nullptr);
   static void *newArray_RooCurve(Long_t size, void *p);
   static void delete_RooCurve(void *p);
   static void deleteArray_RooCurve(void *p);
   static void destruct_RooCurve(void *p);
   static Long64_t merge_RooCurve(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCurve*)
   {
      ::RooCurve *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCurve >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCurve", ::RooCurve::Class_Version(), "RooCurve.h", 32,
                  typeid(::RooCurve), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCurve::Dictionary, isa_proxy, 4,
                  sizeof(::RooCurve) );
      instance.SetNew(&new_RooCurve);
      instance.SetNewArray(&newArray_RooCurve);
      instance.SetDelete(&delete_RooCurve);
      instance.SetDeleteArray(&deleteArray_RooCurve);
      instance.SetDestructor(&destruct_RooCurve);
      instance.SetMerge(&merge_RooCurve);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCurve*)
   {
      return GenerateInitInstanceLocal((::RooCurve*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCurve*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCollection(void *p);
   static void deleteArray_RooAbsCollection(void *p);
   static void destruct_RooAbsCollection(void *p);

   // Schema evolution read functions
   static void read_RooAbsCollection_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("RooAbsCollection");
      static Long_t offset__allRRV = cls->GetDataMemberOffset("_allRRV");
      Bool_t& _allRRV = *(Bool_t*)(target+offset__allRRV);
      RooAbsCollection* newObj = (RooAbsCollection*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _allRRV=kFALSE ; 
   }
   static void read_RooAbsCollection_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__list = oldObj->GetId("_list");
#endif
      struct RooAbsCollection_Onfile {
         RooLinkedList &_list;
         RooAbsCollection_Onfile(RooLinkedList &onfile__list ): _list(onfile__list) {}
      };
      static Long_t offset_Onfile_RooAbsCollection__list = oldObj->GetClass()->GetDataMemberOffset("_list");
      char *onfile_add = (char*)oldObj->GetObject();
      RooAbsCollection_Onfile onfile(
         *(RooLinkedList*)(onfile_add+offset_Onfile_RooAbsCollection__list) );

      static TClassRef cls("RooAbsCollection");
      static Long_t offset__list = cls->GetDataMemberOffset("_list");
      RooAbsCollection::Storage_t& _list = *(RooAbsCollection::Storage_t*)(target+offset__list);
      RooAbsCollection* newObj = (RooAbsCollection*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      \
    for (RooAbsArg * theArg : static_range_cast<RooAbsArg*>(onfile._list)) {_list.push_back(theArg);} 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCollection*)
   {
      ::RooAbsCollection *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCollection >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCollection", ::RooAbsCollection::Class_Version(), "RooAbsCollection.h", 64,
                  typeid(::RooAbsCollection), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCollection::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCollection) );
      instance.SetDelete(&delete_RooAbsCollection);
      instance.SetDeleteArray(&deleteArray_RooAbsCollection);
      instance.SetDestructor(&destruct_RooAbsCollection);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsCollection";
      rule->fTarget      = "_allRRV";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCollection_0);
      rule->fCode        = " _allRRV=kFALSE ; ";
      rule->fVersion     = "[1]";
      rule = &readrules[1];
      rule->fSourceClass = "RooAbsCollection";
      rule->fTarget      = "_list";
      rule->fSource      = "RooLinkedList _list";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooAbsCollection_1);
      rule->fCode        = " \\n    for (RooAbsArg * theArg : static_range_cast<RooAbsArg*>(onfile._list)) {_list.push_back(theArg);} ";
      rule->fVersion     = "[2]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCollection*)
   {
      return GenerateInitInstanceLocal((::RooAbsCollection*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCollection*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgSet(void *p = nullptr);
   static void *newArray_RooArgSet(Long_t size, void *p);
   static void delete_RooArgSet(void *p);
   static void deleteArray_RooArgSet(void *p);
   static void destruct_RooArgSet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgSet*)
   {
      ::RooArgSet *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgSet >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgSet", ::RooArgSet::Class_Version(), "RooArgSet.h", 35,
                  typeid(::RooArgSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgSet::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgSet) );
      instance.SetNew(&new_RooArgSet);
      instance.SetNewArray(&newArray_RooArgSet);
      instance.SetDelete(&delete_RooArgSet);
      instance.SetDeleteArray(&deleteArray_RooArgSet);
      instance.SetDestructor(&destruct_RooArgSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgSet*)
   {
      return GenerateInitInstanceLocal((::RooArgSet*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgSet*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgList(void *p = nullptr);
   static void *newArray_RooArgList(Long_t size, void *p);
   static void delete_RooArgList(void *p);
   static void deleteArray_RooArgList(void *p);
   static void destruct_RooArgList(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgList*)
   {
      ::RooArgList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgList", ::RooArgList::Class_Version(), "RooArgList.h", 22,
                  typeid(::RooArgList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgList::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgList) );
      instance.SetNew(&new_RooArgList);
      instance.SetNewArray(&newArray_RooArgList);
      instance.SetDelete(&delete_RooArgList);
      instance.SetDeleteArray(&deleteArray_RooArgList);
      instance.SetDestructor(&destruct_RooArgList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgList*)
   {
      return GenerateInitInstanceLocal((::RooArgList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsReal(void *p);
   static void deleteArray_RooAbsReal(void *p);
   static void destruct_RooAbsReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsReal*)
   {
      ::RooAbsReal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsReal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsReal", ::RooAbsReal::Class_Version(), "RooAbsReal.h", 63,
                  typeid(::RooAbsReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsReal) );
      instance.SetDelete(&delete_RooAbsReal);
      instance.SetDeleteArray(&deleteArray_RooAbsReal);
      instance.SetDestructor(&destruct_RooAbsReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsReal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsReal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNormSetCache(void *p = nullptr);
   static void *newArray_RooNormSetCache(Long_t size, void *p);
   static void delete_RooNormSetCache(void *p);
   static void deleteArray_RooNormSetCache(void *p);
   static void destruct_RooNormSetCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNormSetCache*)
   {
      ::RooNormSetCache *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNormSetCache >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNormSetCache", ::RooNormSetCache::Class_Version(), "RooNormSetCache.h", 30,
                  typeid(::RooNormSetCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNormSetCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooNormSetCache) );
      instance.SetNew(&new_RooNormSetCache);
      instance.SetNewArray(&newArray_RooNormSetCache);
      instance.SetDelete(&delete_RooNormSetCache);
      instance.SetDeleteArray(&deleteArray_RooNormSetCache);
      instance.SetDestructor(&destruct_RooNormSetCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNormSetCache*)
   {
      return GenerateInitInstanceLocal((::RooNormSetCache*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNormSetCache*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCacheElement(void *p);
   static void deleteArray_RooAbsCacheElement(void *p);
   static void destruct_RooAbsCacheElement(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCacheElement*)
   {
      ::RooAbsCacheElement *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCacheElement >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCacheElement", ::RooAbsCacheElement::Class_Version(), "RooAbsCacheElement.h", 26,
                  typeid(::RooAbsCacheElement), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCacheElement::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCacheElement) );
      instance.SetDelete(&delete_RooAbsCacheElement);
      instance.SetDeleteArray(&deleteArray_RooAbsCacheElement);
      instance.SetDestructor(&destruct_RooAbsCacheElement);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCacheElement*)
   {
      return GenerateInitInstanceLocal((::RooAbsCacheElement*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCacheElement*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMsgService(void *p);
   static void deleteArray_RooMsgService(void *p);
   static void destruct_RooMsgService(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMsgService*)
   {
      ::RooMsgService *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMsgService >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMsgService", ::RooMsgService::Class_Version(), "RooMsgService.h", 106,
                  typeid(::RooMsgService), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMsgService::Dictionary, isa_proxy, 4,
                  sizeof(::RooMsgService) );
      instance.SetDelete(&delete_RooMsgService);
      instance.SetDeleteArray(&deleteArray_RooMsgService);
      instance.SetDestructor(&destruct_RooMsgService);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMsgService*)
   {
      return GenerateInitInstanceLocal((::RooMsgService*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMsgService*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMsgServicecLcLStreamConfig_Dictionary();
   static void RooMsgServicecLcLStreamConfig_TClassManip(TClass*);
   static void *new_RooMsgServicecLcLStreamConfig(void *p = nullptr);
   static void *newArray_RooMsgServicecLcLStreamConfig(Long_t size, void *p);
   static void delete_RooMsgServicecLcLStreamConfig(void *p);
   static void deleteArray_RooMsgServicecLcLStreamConfig(void *p);
   static void destruct_RooMsgServicecLcLStreamConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMsgService::StreamConfig*)
   {
      ::RooMsgService::StreamConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMsgService::StreamConfig));
      static ::ROOT::TGenericClassInfo 
         instance("RooMsgService::StreamConfig", "RooMsgService.h", 111,
                  typeid(::RooMsgService::StreamConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMsgServicecLcLStreamConfig_Dictionary, isa_proxy, 4,
                  sizeof(::RooMsgService::StreamConfig) );
      instance.SetNew(&new_RooMsgServicecLcLStreamConfig);
      instance.SetNewArray(&newArray_RooMsgServicecLcLStreamConfig);
      instance.SetDelete(&delete_RooMsgServicecLcLStreamConfig);
      instance.SetDeleteArray(&deleteArray_RooMsgServicecLcLStreamConfig);
      instance.SetDestructor(&destruct_RooMsgServicecLcLStreamConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMsgService::StreamConfig*)
   {
      return GenerateInitInstanceLocal((::RooMsgService::StreamConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMsgService::StreamConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMsgServicecLcLStreamConfig_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMsgService::StreamConfig*)nullptr)->GetClass();
      RooMsgServicecLcLStreamConfig_TClassManip(theClass);
   return theClass;
   }

   static void RooMsgServicecLcLStreamConfig_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooCacheManagerlERooAbsCacheElementgR_Dictionary();
   static void RooCacheManagerlERooAbsCacheElementgR_TClassManip(TClass*);
   static void *new_RooCacheManagerlERooAbsCacheElementgR(void *p = nullptr);
   static void *newArray_RooCacheManagerlERooAbsCacheElementgR(Long_t size, void *p);
   static void delete_RooCacheManagerlERooAbsCacheElementgR(void *p);
   static void deleteArray_RooCacheManagerlERooAbsCacheElementgR(void *p);
   static void destruct_RooCacheManagerlERooAbsCacheElementgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCacheManager<RooAbsCacheElement>*)
   {
      ::RooCacheManager<RooAbsCacheElement> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCacheManager<RooAbsCacheElement> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCacheManager<RooAbsCacheElement>", ::RooCacheManager<RooAbsCacheElement>::Class_Version(), "RooCacheManager.h", 34,
                  typeid(::RooCacheManager<RooAbsCacheElement>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooCacheManagerlERooAbsCacheElementgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooCacheManager<RooAbsCacheElement>) );
      instance.SetNew(&new_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetNewArray(&newArray_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDelete(&delete_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDeleteArray(&deleteArray_RooCacheManagerlERooAbsCacheElementgR);
      instance.SetDestructor(&destruct_RooCacheManagerlERooAbsCacheElementgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCacheManager<RooAbsCacheElement>*)
   {
      return GenerateInitInstanceLocal((::RooCacheManager<RooAbsCacheElement>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooCacheManagerlERooAbsCacheElementgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr)->GetClass();
      RooCacheManagerlERooAbsCacheElementgR_TClassManip(theClass);
   return theClass;
   }

   static void RooCacheManagerlERooAbsCacheElementgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary();
   static void RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(TClass*);
   static void *new_RooCacheManagerlEvectorlEdoublegRsPgR(void *p = nullptr);
   static void *newArray_RooCacheManagerlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);
   static void destruct_RooCacheManagerlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCacheManager<vector<double> >*)
   {
      ::RooCacheManager<vector<double> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCacheManager<vector<double> > >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCacheManager<vector<double> >", ::RooCacheManager<vector<double> >::Class_Version(), "RooCacheManager.h", 34,
                  typeid(::RooCacheManager<vector<double> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooCacheManager<vector<double> >) );
      instance.SetNew(&new_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_RooCacheManagerlEvectorlEdoublegRsPgR);

      ::ROOT::AddClassAlternate("RooCacheManager<vector<double> >","RooCacheManager<std::vector<double> >");

      ::ROOT::AddClassAlternate("RooCacheManager<vector<double> >","RooCacheManager<std::vector<double, std::allocator<double> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCacheManager<vector<double> >*)
   {
      return GenerateInitInstanceLocal((::RooCacheManager<vector<double> >*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooCacheManagerlEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr)->GetClass();
      RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void RooCacheManagerlEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooObjCacheManager(void *p = nullptr);
   static void *newArray_RooObjCacheManager(Long_t size, void *p);
   static void delete_RooObjCacheManager(void *p);
   static void deleteArray_RooObjCacheManager(void *p);
   static void destruct_RooObjCacheManager(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooObjCacheManager*)
   {
      ::RooObjCacheManager *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooObjCacheManager >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooObjCacheManager", ::RooObjCacheManager::Class_Version(), "RooObjCacheManager.h", 30,
                  typeid(::RooObjCacheManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooObjCacheManager::Dictionary, isa_proxy, 4,
                  sizeof(::RooObjCacheManager) );
      instance.SetNew(&new_RooObjCacheManager);
      instance.SetNewArray(&newArray_RooObjCacheManager);
      instance.SetDelete(&delete_RooObjCacheManager);
      instance.SetDeleteArray(&deleteArray_RooObjCacheManager);
      instance.SetDestructor(&destruct_RooObjCacheManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooObjCacheManager*)
   {
      return GenerateInitInstanceLocal((::RooObjCacheManager*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooObjCacheManager*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsPdf(void *p);
   static void deleteArray_RooAbsPdf(void *p);
   static void destruct_RooAbsPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsPdf*)
   {
      ::RooAbsPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsPdf", ::RooAbsPdf::Class_Version(), "RooAbsPdf.h", 43,
                  typeid(::RooAbsPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsPdf) );
      instance.SetDelete(&delete_RooAbsPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsPdf);
      instance.SetDestructor(&destruct_RooAbsPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAbsPdfcLcLGenSpec(void *p = nullptr);
   static void *newArray_RooAbsPdfcLcLGenSpec(Long_t size, void *p);
   static void delete_RooAbsPdfcLcLGenSpec(void *p);
   static void deleteArray_RooAbsPdfcLcLGenSpec(void *p);
   static void destruct_RooAbsPdfcLcLGenSpec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsPdf::GenSpec*)
   {
      ::RooAbsPdf::GenSpec *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsPdf::GenSpec >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsPdf::GenSpec", ::RooAbsPdf::GenSpec::Class_Version(), "RooAbsPdf.h", 73,
                  typeid(::RooAbsPdf::GenSpec), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsPdf::GenSpec::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsPdf::GenSpec) );
      instance.SetNew(&new_RooAbsPdfcLcLGenSpec);
      instance.SetNewArray(&newArray_RooAbsPdfcLcLGenSpec);
      instance.SetDelete(&delete_RooAbsPdfcLcLGenSpec);
      instance.SetDeleteArray(&deleteArray_RooAbsPdfcLcLGenSpec);
      instance.SetDestructor(&destruct_RooAbsPdfcLcLGenSpec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsPdf::GenSpec*)
   {
      return GenerateInitInstanceLocal((::RooAbsPdf::GenSpec*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsProxy(void *p);
   static void deleteArray_RooAbsProxy(void *p);
   static void destruct_RooAbsProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsProxy*)
   {
      ::RooAbsProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsProxy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsProxy", ::RooAbsProxy::Class_Version(), "RooAbsProxy.h", 30,
                  typeid(::RooAbsProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsProxy) );
      instance.SetDelete(&delete_RooAbsProxy);
      instance.SetDeleteArray(&deleteArray_RooAbsProxy);
      instance.SetDestructor(&destruct_RooAbsProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsProxy*)
   {
      return GenerateInitInstanceLocal((::RooAbsProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooArgProxy(void *p = nullptr);
   static void *newArray_RooArgProxy(Long_t size, void *p);
   static void delete_RooArgProxy(void *p);
   static void deleteArray_RooArgProxy(void *p);
   static void destruct_RooArgProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooArgProxy*)
   {
      ::RooArgProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooArgProxy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooArgProxy", ::RooArgProxy::Class_Version(), "RooArgProxy.h", 24,
                  typeid(::RooArgProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooArgProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooArgProxy) );
      instance.SetNew(&new_RooArgProxy);
      instance.SetNewArray(&newArray_RooArgProxy);
      instance.SetDelete(&delete_RooArgProxy);
      instance.SetDeleteArray(&deleteArray_RooArgProxy);
      instance.SetDestructor(&destruct_RooArgProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooArgProxy*)
   {
      return GenerateInitInstanceLocal((::RooArgProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooArgProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumber(void *p = nullptr);
   static void *newArray_RooNumber(Long_t size, void *p);
   static void delete_RooNumber(void *p);
   static void deleteArray_RooNumber(void *p);
   static void destruct_RooNumber(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumber*)
   {
      ::RooNumber *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumber >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumber", ::RooNumber::Class_Version(), "RooNumber.h", 21,
                  typeid(::RooNumber), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumber::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumber) );
      instance.SetNew(&new_RooNumber);
      instance.SetNewArray(&newArray_RooNumber);
      instance.SetDelete(&delete_RooNumber);
      instance.SetDeleteArray(&deleteArray_RooNumber);
      instance.SetDestructor(&destruct_RooNumber);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumber*)
   {
      return GenerateInitInstanceLocal((::RooNumber*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumber*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsLValue(void *p);
   static void deleteArray_RooAbsLValue(void *p);
   static void destruct_RooAbsLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsLValue*)
   {
      ::RooAbsLValue *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsLValue >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsLValue", ::RooAbsLValue::Class_Version(), "RooAbsLValue.h", 26,
                  typeid(::RooAbsLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsLValue) );
      instance.SetDelete(&delete_RooAbsLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsLValue);
      instance.SetDestructor(&destruct_RooAbsLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsLValue*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsLValue*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsBinning(void *p);
   static void deleteArray_RooAbsBinning(void *p);
   static void destruct_RooAbsBinning(void *p);
   static void streamer_RooAbsBinning(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsBinning*)
   {
      ::RooAbsBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsBinning", ::RooAbsBinning::Class_Version(), "RooAbsBinning.h", 26,
                  typeid(::RooAbsBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsBinning::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsBinning) );
      instance.SetDelete(&delete_RooAbsBinning);
      instance.SetDeleteArray(&deleteArray_RooAbsBinning);
      instance.SetDestructor(&destruct_RooAbsBinning);
      instance.SetStreamerFunc(&streamer_RooAbsBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsBinning*)
   {
      return GenerateInitInstanceLocal((::RooAbsBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsRealLValue(void *p);
   static void deleteArray_RooAbsRealLValue(void *p);
   static void destruct_RooAbsRealLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsRealLValue*)
   {
      ::RooAbsRealLValue *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsRealLValue >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsRealLValue", ::RooAbsRealLValue::Class_Version(), "RooAbsRealLValue.h", 31,
                  typeid(::RooAbsRealLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsRealLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsRealLValue) );
      instance.SetDelete(&delete_RooAbsRealLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsRealLValue);
      instance.SetDestructor(&destruct_RooAbsRealLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsRealLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsRealLValue*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsRealLValue*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooAbsRealgR_Dictionary();
   static void RooTemplateProxylERooAbsRealgR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooAbsRealgR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooAbsRealgR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooAbsRealgR(void *p);
   static void deleteArray_RooTemplateProxylERooAbsRealgR(void *p);
   static void destruct_RooTemplateProxylERooAbsRealgR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooAbsReal>*)
   {
      ::RooTemplateProxy<RooAbsReal> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooAbsReal> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooAbsReal>", ::RooTemplateProxy<RooAbsReal>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooAbsReal>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooAbsRealgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooAbsReal>) );
      instance.SetNew(&new_RooTemplateProxylERooAbsRealgR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooAbsRealgR);
      instance.SetDelete(&delete_RooTemplateProxylERooAbsRealgR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooAbsRealgR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooAbsRealgR);

      ::ROOT::AddClassAlternate("RooTemplateProxy<RooAbsReal>","RooRealProxy");

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooRealProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooAbsReal>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooAbsReal>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooAbsRealgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr)->GetClass();
      RooTemplateProxylERooAbsRealgR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooAbsRealgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooAbsCategorygR_Dictionary();
   static void RooTemplateProxylERooAbsCategorygR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooAbsCategorygR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooAbsCategorygR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooAbsCategorygR(void *p);
   static void deleteArray_RooTemplateProxylERooAbsCategorygR(void *p);
   static void destruct_RooTemplateProxylERooAbsCategorygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooAbsCategory>*)
   {
      ::RooTemplateProxy<RooAbsCategory> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooAbsCategory> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooAbsCategory>", ::RooTemplateProxy<RooAbsCategory>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooAbsCategory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooAbsCategorygR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooAbsCategory>) );
      instance.SetNew(&new_RooTemplateProxylERooAbsCategorygR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooAbsCategorygR);
      instance.SetDelete(&delete_RooTemplateProxylERooAbsCategorygR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooAbsCategorygR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooAbsCategorygR);

      ::ROOT::AddClassAlternate("RooTemplateProxy<RooAbsCategory>","RooCategoryProxy");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooAbsCategory>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooAbsCategory>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooAbsCategorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr)->GetClass();
      RooTemplateProxylERooAbsCategorygR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooAbsCategorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooAbsRealLValuegR_Dictionary();
   static void RooTemplateProxylERooAbsRealLValuegR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooAbsRealLValuegR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooAbsRealLValuegR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooAbsRealLValuegR(void *p);
   static void deleteArray_RooTemplateProxylERooAbsRealLValuegR(void *p);
   static void destruct_RooTemplateProxylERooAbsRealLValuegR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooAbsRealLValue>*)
   {
      ::RooTemplateProxy<RooAbsRealLValue> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooAbsRealLValue> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooAbsRealLValue>", ::RooTemplateProxy<RooAbsRealLValue>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooAbsRealLValue>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooAbsRealLValuegR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooAbsRealLValue>) );
      instance.SetNew(&new_RooTemplateProxylERooAbsRealLValuegR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooAbsRealLValuegR);
      instance.SetDelete(&delete_RooTemplateProxylERooAbsRealLValuegR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooAbsRealLValuegR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooAbsRealLValuegR);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooRealProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooAbsRealLValue>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooAbsRealLValue>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooAbsRealLValuegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr)->GetClass();
      RooTemplateProxylERooAbsRealLValuegR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooAbsRealLValuegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooAbsPdfgR_Dictionary();
   static void RooTemplateProxylERooAbsPdfgR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooAbsPdfgR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooAbsPdfgR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooAbsPdfgR(void *p);
   static void deleteArray_RooTemplateProxylERooAbsPdfgR(void *p);
   static void destruct_RooTemplateProxylERooAbsPdfgR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooAbsPdf>*)
   {
      ::RooTemplateProxy<RooAbsPdf> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooAbsPdf> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooAbsPdf>", ::RooTemplateProxy<RooAbsPdf>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooAbsPdf>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooAbsPdfgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooAbsPdf>) );
      instance.SetNew(&new_RooTemplateProxylERooAbsPdfgR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooAbsPdfgR);
      instance.SetDelete(&delete_RooTemplateProxylERooAbsPdfgR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooAbsPdfgR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooAbsPdfgR);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooRealProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooAbsPdf>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooAbsPdf>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooAbsPdfgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr)->GetClass();
      RooTemplateProxylERooAbsPdfgR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooAbsPdfgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooRealVargR_Dictionary();
   static void RooTemplateProxylERooRealVargR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooRealVargR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooRealVargR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooRealVargR(void *p);
   static void deleteArray_RooTemplateProxylERooRealVargR(void *p);
   static void destruct_RooTemplateProxylERooRealVargR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooRealVar>*)
   {
      ::RooTemplateProxy<RooRealVar> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooRealVar> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooRealVar>", ::RooTemplateProxy<RooRealVar>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooRealVar>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooRealVargR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooRealVar>) );
      instance.SetNew(&new_RooTemplateProxylERooRealVargR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooRealVargR);
      instance.SetDelete(&delete_RooTemplateProxylERooRealVargR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooRealVargR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooRealVargR);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooRealProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooRealVar>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooRealVar>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooRealVargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr)->GetClass();
      RooTemplateProxylERooRealVargR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooRealVargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooMultiCategorygR_Dictionary();
   static void RooTemplateProxylERooMultiCategorygR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooMultiCategorygR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooMultiCategorygR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooMultiCategorygR(void *p);
   static void deleteArray_RooTemplateProxylERooMultiCategorygR(void *p);
   static void destruct_RooTemplateProxylERooMultiCategorygR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooMultiCategory>*)
   {
      ::RooTemplateProxy<RooMultiCategory> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooMultiCategory> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooMultiCategory>", ::RooTemplateProxy<RooMultiCategory>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooMultiCategory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooMultiCategorygR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooMultiCategory>) );
      instance.SetNew(&new_RooTemplateProxylERooMultiCategorygR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooMultiCategorygR);
      instance.SetDelete(&delete_RooTemplateProxylERooMultiCategorygR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooMultiCategorygR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooMultiCategorygR);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooCategoryProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooMultiCategory>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooMultiCategory>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooMultiCategorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr)->GetClass();
      RooTemplateProxylERooMultiCategorygR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooMultiCategorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylEconstsPRooHistFuncgR_Dictionary();
   static void RooTemplateProxylEconstsPRooHistFuncgR_TClassManip(TClass*);
   static void *new_RooTemplateProxylEconstsPRooHistFuncgR(void *p = nullptr);
   static void *newArray_RooTemplateProxylEconstsPRooHistFuncgR(Long_t size, void *p);
   static void delete_RooTemplateProxylEconstsPRooHistFuncgR(void *p);
   static void deleteArray_RooTemplateProxylEconstsPRooHistFuncgR(void *p);
   static void destruct_RooTemplateProxylEconstsPRooHistFuncgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<const RooHistFunc>*)
   {
      ::RooTemplateProxy<const RooHistFunc> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<const RooHistFunc> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<const RooHistFunc>", ::RooTemplateProxy<const RooHistFunc>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<const RooHistFunc>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylEconstsPRooHistFuncgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<const RooHistFunc>) );
      instance.SetNew(&new_RooTemplateProxylEconstsPRooHistFuncgR);
      instance.SetNewArray(&newArray_RooTemplateProxylEconstsPRooHistFuncgR);
      instance.SetDelete(&delete_RooTemplateProxylEconstsPRooHistFuncgR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylEconstsPRooHistFuncgR);
      instance.SetDestructor(&destruct_RooTemplateProxylEconstsPRooHistFuncgR);

      ::ROOT::AddClassAlternate("RooTemplateProxy<const RooHistFunc>","RooTemplateProxy<RooHistFunc const>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<const RooHistFunc>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<const RooHistFunc>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylEconstsPRooHistFuncgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr)->GetClass();
      RooTemplateProxylEconstsPRooHistFuncgR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylEconstsPRooHistFuncgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooAbsCategoryLValuegR_Dictionary();
   static void RooTemplateProxylERooAbsCategoryLValuegR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooAbsCategoryLValuegR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooAbsCategoryLValuegR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooAbsCategoryLValuegR(void *p);
   static void deleteArray_RooTemplateProxylERooAbsCategoryLValuegR(void *p);
   static void destruct_RooTemplateProxylERooAbsCategoryLValuegR(void *p);

   // Schema evolution read functions

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooAbsCategoryLValue>*)
   {
      ::RooTemplateProxy<RooAbsCategoryLValue> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooAbsCategoryLValue> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooAbsCategoryLValue>", ::RooTemplateProxy<RooAbsCategoryLValue>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooAbsCategoryLValue>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooAbsCategoryLValuegR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooAbsCategoryLValue>) );
      instance.SetNew(&new_RooTemplateProxylERooAbsCategoryLValuegR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooAbsCategoryLValuegR);
      instance.SetDelete(&delete_RooTemplateProxylERooAbsCategoryLValuegR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooAbsCategoryLValuegR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooAbsCategoryLValuegR);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooCategoryProxy";
      rule->fTarget      = "";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooAbsCategoryLValue>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooAbsCategoryLValuegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr)->GetClass();
      RooTemplateProxylERooAbsCategoryLValuegR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooAbsCategoryLValuegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooTemplateProxylERooHistFuncgR_Dictionary();
   static void RooTemplateProxylERooHistFuncgR_TClassManip(TClass*);
   static void *new_RooTemplateProxylERooHistFuncgR(void *p = nullptr);
   static void *newArray_RooTemplateProxylERooHistFuncgR(Long_t size, void *p);
   static void delete_RooTemplateProxylERooHistFuncgR(void *p);
   static void deleteArray_RooTemplateProxylERooHistFuncgR(void *p);
   static void destruct_RooTemplateProxylERooHistFuncgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTemplateProxy<RooHistFunc>*)
   {
      ::RooTemplateProxy<RooHistFunc> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTemplateProxy<RooHistFunc> >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTemplateProxy<RooHistFunc>", ::RooTemplateProxy<RooHistFunc>::Class_Version(), "RooTemplateProxy.h", 149,
                  typeid(::RooTemplateProxy<RooHistFunc>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooTemplateProxylERooHistFuncgR_Dictionary, isa_proxy, 4,
                  sizeof(::RooTemplateProxy<RooHistFunc>) );
      instance.SetNew(&new_RooTemplateProxylERooHistFuncgR);
      instance.SetNewArray(&newArray_RooTemplateProxylERooHistFuncgR);
      instance.SetDelete(&delete_RooTemplateProxylERooHistFuncgR);
      instance.SetDeleteArray(&deleteArray_RooTemplateProxylERooHistFuncgR);
      instance.SetDestructor(&destruct_RooTemplateProxylERooHistFuncgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTemplateProxy<RooHistFunc>*)
   {
      return GenerateInitInstanceLocal((::RooTemplateProxy<RooHistFunc>*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooTemplateProxylERooHistFuncgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr)->GetClass();
      RooTemplateProxylERooHistFuncgR_TClassManip(theClass);
   return theClass;
   }

   static void RooTemplateProxylERooHistFuncgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooListProxy(void *p = nullptr);
   static void *newArray_RooListProxy(Long_t size, void *p);
   static void delete_RooListProxy(void *p);
   static void deleteArray_RooListProxy(void *p);
   static void destruct_RooListProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooListProxy*)
   {
      ::RooListProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooListProxy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooListProxy", ::RooListProxy::Class_Version(), "RooListProxy.h", 24,
                  typeid(::RooListProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooListProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooListProxy) );
      instance.SetNew(&new_RooListProxy);
      instance.SetNewArray(&newArray_RooListProxy);
      instance.SetDelete(&delete_RooListProxy);
      instance.SetDeleteArray(&deleteArray_RooListProxy);
      instance.SetDestructor(&destruct_RooListProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooListProxy*)
   {
      return GenerateInitInstanceLocal((::RooListProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooListProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsData(void *p);
   static void deleteArray_RooAbsData(void *p);
   static void destruct_RooAbsData(void *p);
   static void streamer_RooAbsData(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsData*)
   {
      ::RooAbsData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsData >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsData", ::RooAbsData::Class_Version(), "RooAbsData.h", 81,
                  typeid(::RooAbsData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsData::Dictionary, isa_proxy, 17,
                  sizeof(::RooAbsData) );
      instance.SetDelete(&delete_RooAbsData);
      instance.SetDeleteArray(&deleteArray_RooAbsData);
      instance.SetDestructor(&destruct_RooAbsData);
      instance.SetStreamerFunc(&streamer_RooAbsData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsData*)
   {
      return GenerateInitInstanceLocal((::RooAbsData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDirItem(void *p = nullptr);
   static void *newArray_RooDirItem(Long_t size, void *p);
   static void delete_RooDirItem(void *p);
   static void deleteArray_RooDirItem(void *p);
   static void destruct_RooDirItem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDirItem*)
   {
      ::RooDirItem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDirItem >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDirItem", ::RooDirItem::Class_Version(), "RooDirItem.h", 22,
                  typeid(::RooDirItem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDirItem::Dictionary, isa_proxy, 4,
                  sizeof(::RooDirItem) );
      instance.SetNew(&new_RooDirItem);
      instance.SetNewArray(&newArray_RooDirItem);
      instance.SetDelete(&delete_RooDirItem);
      instance.SetDeleteArray(&deleteArray_RooDirItem);
      instance.SetDestructor(&destruct_RooDirItem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDirItem*)
   {
      return GenerateInitInstanceLocal((::RooDirItem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDirItem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataSet(void *p = nullptr);
   static void *newArray_RooDataSet(Long_t size, void *p);
   static void delete_RooDataSet(void *p);
   static void deleteArray_RooDataSet(void *p);
   static void destruct_RooDataSet(void *p);
   static void streamer_RooDataSet(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataSet*)
   {
      ::RooDataSet *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataSet >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataSet", ::RooDataSet::Class_Version(), "RooDataSet.h", 36,
                  typeid(::RooDataSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataSet::Dictionary, isa_proxy, 17,
                  sizeof(::RooDataSet) );
      instance.SetNew(&new_RooDataSet);
      instance.SetNewArray(&newArray_RooDataSet);
      instance.SetDelete(&delete_RooDataSet);
      instance.SetDeleteArray(&deleteArray_RooDataSet);
      instance.SetDestructor(&destruct_RooDataSet);
      instance.SetStreamerFunc(&streamer_RooDataSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataSet*)
   {
      return GenerateInitInstanceLocal((::RooDataSet*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataSet*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAICRegistry(void *p = nullptr);
   static void *newArray_RooAICRegistry(Long_t size, void *p);
   static void delete_RooAICRegistry(void *p);
   static void deleteArray_RooAICRegistry(void *p);
   static void destruct_RooAICRegistry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAICRegistry*)
   {
      ::RooAICRegistry *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAICRegistry >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAICRegistry", ::RooAICRegistry::Class_Version(), "RooAICRegistry.h", 26,
                  typeid(::RooAICRegistry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAICRegistry::Dictionary, isa_proxy, 4,
                  sizeof(::RooAICRegistry) );
      instance.SetNew(&new_RooAICRegistry);
      instance.SetNewArray(&newArray_RooAICRegistry);
      instance.SetDelete(&delete_RooAICRegistry);
      instance.SetDeleteArray(&deleteArray_RooAICRegistry);
      instance.SetDestructor(&destruct_RooAICRegistry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAICRegistry*)
   {
      return GenerateInitInstanceLocal((::RooAICRegistry*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAICRegistry*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsAnaConvPdf(void *p);
   static void deleteArray_RooAbsAnaConvPdf(void *p);
   static void destruct_RooAbsAnaConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsAnaConvPdf*)
   {
      ::RooAbsAnaConvPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsAnaConvPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsAnaConvPdf", ::RooAbsAnaConvPdf::Class_Version(), "RooAbsAnaConvPdf.h", 34,
                  typeid(::RooAbsAnaConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsAnaConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsAnaConvPdf) );
      instance.SetDelete(&delete_RooAbsAnaConvPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsAnaConvPdf);
      instance.SetDestructor(&destruct_RooAbsAnaConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsAnaConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsAnaConvPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSetProxy(void *p = nullptr);
   static void *newArray_RooSetProxy(Long_t size, void *p);
   static void delete_RooSetProxy(void *p);
   static void deleteArray_RooSetProxy(void *p);
   static void destruct_RooSetProxy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSetProxy*)
   {
      ::RooSetProxy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSetProxy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSetProxy", ::RooSetProxy::Class_Version(), "RooSetProxy.h", 23,
                  typeid(::RooSetProxy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSetProxy::Dictionary, isa_proxy, 4,
                  sizeof(::RooSetProxy) );
      instance.SetNew(&new_RooSetProxy);
      instance.SetNewArray(&newArray_RooSetProxy);
      instance.SetDelete(&delete_RooSetProxy);
      instance.SetDeleteArray(&deleteArray_RooSetProxy);
      instance.SetDestructor(&destruct_RooSetProxy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSetProxy*)
   {
      return GenerateInitInstanceLocal((::RooSetProxy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSetProxy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHistPdf(void *p = nullptr);
   static void *newArray_RooHistPdf(Long_t size, void *p);
   static void delete_RooHistPdf(void *p);
   static void deleteArray_RooHistPdf(void *p);
   static void destruct_RooHistPdf(void *p);
   static void streamer_RooHistPdf(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistPdf*)
   {
      ::RooHistPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistPdf", ::RooHistPdf::Class_Version(), "RooHistPdf.h", 29,
                  typeid(::RooHistPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistPdf::Dictionary, isa_proxy, 17,
                  sizeof(::RooHistPdf) );
      instance.SetNew(&new_RooHistPdf);
      instance.SetNewArray(&newArray_RooHistPdf);
      instance.SetDelete(&delete_RooHistPdf);
      instance.SetDeleteArray(&deleteArray_RooHistPdf);
      instance.SetDestructor(&destruct_RooHistPdf);
      instance.SetStreamerFunc(&streamer_RooHistPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistPdf*)
   {
      return GenerateInitInstanceLocal((::RooHistPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooChangeTracker(void *p = nullptr);
   static void *newArray_RooChangeTracker(Long_t size, void *p);
   static void delete_RooChangeTracker(void *p);
   static void deleteArray_RooChangeTracker(void *p);
   static void destruct_RooChangeTracker(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooChangeTracker*)
   {
      ::RooChangeTracker *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooChangeTracker >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooChangeTracker", ::RooChangeTracker::Class_Version(), "RooChangeTracker.h", 26,
                  typeid(::RooChangeTracker), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooChangeTracker::Dictionary, isa_proxy, 4,
                  sizeof(::RooChangeTracker) );
      instance.SetNew(&new_RooChangeTracker);
      instance.SetNewArray(&newArray_RooChangeTracker);
      instance.SetDelete(&delete_RooChangeTracker);
      instance.SetDeleteArray(&deleteArray_RooChangeTracker);
      instance.SetDestructor(&destruct_RooChangeTracker);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooChangeTracker*)
   {
      return GenerateInitInstanceLocal((::RooChangeTracker*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooChangeTracker*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCachedPdf(void *p);
   static void deleteArray_RooAbsCachedPdf(void *p);
   static void destruct_RooAbsCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedPdf*)
   {
      ::RooAbsCachedPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCachedPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedPdf", ::RooAbsCachedPdf::Class_Version(), "RooAbsCachedPdf.h", 25,
                  typeid(::RooAbsCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedPdf) );
      instance.SetDelete(&delete_RooAbsCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedPdf);
      instance.SetDestructor(&destruct_RooAbsCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooAbsCachedPdfcLcLPdfCacheElem_Dictionary();
   static void RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(TClass*);
   static void delete_RooAbsCachedPdfcLcLPdfCacheElem(void *p);
   static void deleteArray_RooAbsCachedPdfcLcLPdfCacheElem(void *p);
   static void destruct_RooAbsCachedPdfcLcLPdfCacheElem(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedPdf::PdfCacheElem*)
   {
      ::RooAbsCachedPdf::PdfCacheElem *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooAbsCachedPdf::PdfCacheElem));
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedPdf::PdfCacheElem", "RooAbsCachedPdf.h", 61,
                  typeid(::RooAbsCachedPdf::PdfCacheElem), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooAbsCachedPdfcLcLPdfCacheElem_Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedPdf::PdfCacheElem) );
      instance.SetDelete(&delete_RooAbsCachedPdfcLcLPdfCacheElem);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedPdfcLcLPdfCacheElem);
      instance.SetDestructor(&destruct_RooAbsCachedPdfcLcLPdfCacheElem);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedPdf::PdfCacheElem*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedPdf::PdfCacheElem*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedPdf::PdfCacheElem*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooAbsCachedPdfcLcLPdfCacheElem_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf::PdfCacheElem*)nullptr)->GetClass();
      RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(theClass);
   return theClass;
   }

   static void RooAbsCachedPdfcLcLPdfCacheElem_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTrace(void *p = nullptr);
   static void *newArray_RooTrace(Long_t size, void *p);
   static void delete_RooTrace(void *p);
   static void deleteArray_RooTrace(void *p);
   static void destruct_RooTrace(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTrace*)
   {
      ::RooTrace *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTrace >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTrace", ::RooTrace::Class_Version(), "RooTrace.h", 26,
                  typeid(::RooTrace), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTrace::Dictionary, isa_proxy, 4,
                  sizeof(::RooTrace) );
      instance.SetNew(&new_RooTrace);
      instance.SetNewArray(&newArray_RooTrace);
      instance.SetDelete(&delete_RooTrace);
      instance.SetDeleteArray(&deleteArray_RooTrace);
      instance.SetDestructor(&destruct_RooTrace);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTrace*)
   {
      return GenerateInitInstanceLocal((::RooTrace*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTrace*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHistFunc(void *p = nullptr);
   static void *newArray_RooHistFunc(Long_t size, void *p);
   static void delete_RooHistFunc(void *p);
   static void deleteArray_RooHistFunc(void *p);
   static void destruct_RooHistFunc(void *p);
   static void streamer_RooHistFunc(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistFunc*)
   {
      ::RooHistFunc *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistFunc >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistFunc", ::RooHistFunc::Class_Version(), "RooHistFunc.h", 30,
                  typeid(::RooHistFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistFunc::Dictionary, isa_proxy, 17,
                  sizeof(::RooHistFunc) );
      instance.SetNew(&new_RooHistFunc);
      instance.SetNewArray(&newArray_RooHistFunc);
      instance.SetDelete(&delete_RooHistFunc);
      instance.SetDeleteArray(&deleteArray_RooHistFunc);
      instance.SetDestructor(&destruct_RooHistFunc);
      instance.SetStreamerFunc(&streamer_RooHistFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistFunc*)
   {
      return GenerateInitInstanceLocal((::RooHistFunc*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistFunc*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCachedReal(void *p);
   static void deleteArray_RooAbsCachedReal(void *p);
   static void destruct_RooAbsCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCachedReal*)
   {
      ::RooAbsCachedReal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCachedReal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCachedReal", ::RooAbsCachedReal::Class_Version(), "RooAbsCachedReal.h", 24,
                  typeid(::RooAbsCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCachedReal) );
      instance.SetDelete(&delete_RooAbsCachedReal);
      instance.SetDeleteArray(&deleteArray_RooAbsCachedReal);
      instance.SetDestructor(&destruct_RooAbsCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsCachedReal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCachedReal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsCategoryLValue(void *p);
   static void deleteArray_RooAbsCategoryLValue(void *p);
   static void destruct_RooAbsCategoryLValue(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsCategoryLValue*)
   {
      ::RooAbsCategoryLValue *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsCategoryLValue >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsCategoryLValue", ::RooAbsCategoryLValue::Class_Version(), "RooAbsCategoryLValue.h", 25,
                  typeid(::RooAbsCategoryLValue), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsCategoryLValue::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsCategoryLValue) );
      instance.SetDelete(&delete_RooAbsCategoryLValue);
      instance.SetDeleteArray(&deleteArray_RooAbsCategoryLValue);
      instance.SetDestructor(&destruct_RooAbsCategoryLValue);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsCategoryLValue*)
   {
      return GenerateInitInstanceLocal((::RooAbsCategoryLValue*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsDataStore(void *p);
   static void deleteArray_RooAbsDataStore(void *p);
   static void destruct_RooAbsDataStore(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsDataStore*)
   {
      ::RooAbsDataStore *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsDataStore >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsDataStore", ::RooAbsDataStore::Class_Version(), "RooAbsDataStore.h", 37,
                  typeid(::RooAbsDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsDataStore::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsDataStore) );
      instance.SetDelete(&delete_RooAbsDataStore);
      instance.SetDeleteArray(&deleteArray_RooAbsDataStore);
      instance.SetDestructor(&destruct_RooAbsDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsDataStore*)
   {
      return GenerateInitInstanceLocal((::RooAbsDataStore*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsDataStore*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsFunc(void *p);
   static void deleteArray_RooAbsFunc(void *p);
   static void destruct_RooAbsFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsFunc*)
   {
      ::RooAbsFunc *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsFunc >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsFunc", ::RooAbsFunc::Class_Version(), "RooAbsFunc.h", 27,
                  typeid(::RooAbsFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsFunc) );
      instance.SetDelete(&delete_RooAbsFunc);
      instance.SetDeleteArray(&deleteArray_RooAbsFunc);
      instance.SetDestructor(&destruct_RooAbsFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsFunc*)
   {
      return GenerateInitInstanceLocal((::RooAbsFunc*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsFunc*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsGenContext(void *p);
   static void deleteArray_RooAbsGenContext(void *p);
   static void destruct_RooAbsGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsGenContext*)
   {
      ::RooAbsGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsGenContext", ::RooAbsGenContext::Class_Version(), "RooAbsGenContext.h", 26,
                  typeid(::RooAbsGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsGenContext) );
      instance.SetDelete(&delete_RooAbsGenContext);
      instance.SetDeleteArray(&deleteArray_RooAbsGenContext);
      instance.SetDestructor(&destruct_RooAbsGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsGenContext*)
   {
      return GenerateInitInstanceLocal((::RooAbsGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsHiddenReal(void *p);
   static void deleteArray_RooAbsHiddenReal(void *p);
   static void destruct_RooAbsHiddenReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsHiddenReal*)
   {
      ::RooAbsHiddenReal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsHiddenReal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsHiddenReal", ::RooAbsHiddenReal::Class_Version(), "RooAbsHiddenReal.h", 25,
                  typeid(::RooAbsHiddenReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsHiddenReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsHiddenReal) );
      instance.SetDelete(&delete_RooAbsHiddenReal);
      instance.SetDeleteArray(&deleteArray_RooAbsHiddenReal);
      instance.SetDestructor(&destruct_RooAbsHiddenReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsHiddenReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsHiddenReal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCategory(void *p = nullptr);
   static void *newArray_RooCategory(Long_t size, void *p);
   static void delete_RooCategory(void *p);
   static void deleteArray_RooCategory(void *p);
   static void destruct_RooCategory(void *p);
   static void streamer_RooCategory(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCategory*)
   {
      ::RooCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCategory", ::RooCategory::Class_Version(), "RooCategory.h", 27,
                  typeid(::RooCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCategory::Dictionary, isa_proxy, 17,
                  sizeof(::RooCategory) );
      instance.SetNew(&new_RooCategory);
      instance.SetNewArray(&newArray_RooCategory);
      instance.SetDelete(&delete_RooCategory);
      instance.SetDeleteArray(&deleteArray_RooCategory);
      instance.SetDestructor(&destruct_RooCategory);
      instance.SetStreamerFunc(&streamer_RooCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCategory*)
   {
      return GenerateInitInstanceLocal((::RooCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumIntConfig(void *p = nullptr);
   static void *newArray_RooNumIntConfig(Long_t size, void *p);
   static void delete_RooNumIntConfig(void *p);
   static void deleteArray_RooNumIntConfig(void *p);
   static void destruct_RooNumIntConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumIntConfig*)
   {
      ::RooNumIntConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumIntConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumIntConfig", ::RooNumIntConfig::Class_Version(), "RooNumIntConfig.h", 25,
                  typeid(::RooNumIntConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumIntConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumIntConfig) );
      instance.SetNew(&new_RooNumIntConfig);
      instance.SetNewArray(&newArray_RooNumIntConfig);
      instance.SetDelete(&delete_RooNumIntConfig);
      instance.SetDeleteArray(&deleteArray_RooNumIntConfig);
      instance.SetDestructor(&destruct_RooNumIntConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumIntConfig*)
   {
      return GenerateInitInstanceLocal((::RooNumIntConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumIntConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsIntegrator(void *p);
   static void deleteArray_RooAbsIntegrator(void *p);
   static void destruct_RooAbsIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsIntegrator*)
   {
      ::RooAbsIntegrator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsIntegrator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsIntegrator", ::RooAbsIntegrator::Class_Version(), "RooAbsIntegrator.h", 22,
                  typeid(::RooAbsIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsIntegrator) );
      instance.SetDelete(&delete_RooAbsIntegrator);
      instance.SetDeleteArray(&deleteArray_RooAbsIntegrator);
      instance.SetDestructor(&destruct_RooAbsIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooAbsIntegrator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsIntegrator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMCStudy(void *p);
   static void deleteArray_RooMCStudy(void *p);
   static void destruct_RooMCStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMCStudy*)
   {
      ::RooMCStudy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMCStudy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMCStudy", ::RooMCStudy::Class_Version(), "RooMCStudy.h", 32,
                  typeid(::RooMCStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMCStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooMCStudy) );
      instance.SetDelete(&delete_RooMCStudy);
      instance.SetDeleteArray(&deleteArray_RooMCStudy);
      instance.SetDestructor(&destruct_RooMCStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMCStudy*)
   {
      return GenerateInitInstanceLocal((::RooMCStudy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMCStudy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsMCStudyModule(void *p);
   static void deleteArray_RooAbsMCStudyModule(void *p);
   static void destruct_RooAbsMCStudyModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsMCStudyModule*)
   {
      ::RooAbsMCStudyModule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsMCStudyModule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsMCStudyModule", ::RooAbsMCStudyModule::Class_Version(), "RooAbsMCStudyModule.h", 30,
                  typeid(::RooAbsMCStudyModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsMCStudyModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsMCStudyModule) );
      instance.SetDelete(&delete_RooAbsMCStudyModule);
      instance.SetDeleteArray(&deleteArray_RooAbsMCStudyModule);
      instance.SetDestructor(&destruct_RooAbsMCStudyModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsMCStudyModule*)
   {
      return GenerateInitInstanceLocal((::RooAbsMCStudyModule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealVar(void *p = nullptr);
   static void *newArray_RooRealVar(Long_t size, void *p);
   static void delete_RooRealVar(void *p);
   static void deleteArray_RooRealVar(void *p);
   static void destruct_RooRealVar(void *p);
   static void streamer_RooRealVar(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealVar*)
   {
      ::RooRealVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealVar", ::RooRealVar::Class_Version(), "RooRealVar.h", 39,
                  typeid(::RooRealVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealVar::Dictionary, isa_proxy, 17,
                  sizeof(::RooRealVar) );
      instance.SetNew(&new_RooRealVar);
      instance.SetNewArray(&newArray_RooRealVar);
      instance.SetDelete(&delete_RooRealVar);
      instance.SetDeleteArray(&deleteArray_RooRealVar);
      instance.SetDestructor(&destruct_RooRealVar);
      instance.SetStreamerFunc(&streamer_RooRealVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealVar*)
   {
      return GenerateInitInstanceLocal((::RooRealVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsMoment(void *p);
   static void deleteArray_RooAbsMoment(void *p);
   static void destruct_RooAbsMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsMoment*)
   {
      ::RooAbsMoment *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsMoment >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsMoment", ::RooAbsMoment::Class_Version(), "RooAbsMoment.h", 27,
                  typeid(::RooAbsMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsMoment) );
      instance.SetDelete(&delete_RooAbsMoment);
      instance.SetDeleteArray(&deleteArray_RooAbsMoment);
      instance.SetDestructor(&destruct_RooAbsMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsMoment*)
   {
      return GenerateInitInstanceLocal((::RooAbsMoment*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsMoment*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsNumGenerator(void *p);
   static void deleteArray_RooAbsNumGenerator(void *p);
   static void destruct_RooAbsNumGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsNumGenerator*)
   {
      ::RooAbsNumGenerator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsNumGenerator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsNumGenerator", ::RooAbsNumGenerator::Class_Version(), "RooAbsNumGenerator.h", 30,
                  typeid(::RooAbsNumGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsNumGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsNumGenerator) );
      instance.SetDelete(&delete_RooAbsNumGenerator);
      instance.SetDeleteArray(&deleteArray_RooAbsNumGenerator);
      instance.SetDestructor(&destruct_RooAbsNumGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsNumGenerator*)
   {
      return GenerateInitInstanceLocal((::RooAbsNumGenerator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsTestStatistic(void *p);
   static void deleteArray_RooAbsTestStatistic(void *p);
   static void destruct_RooAbsTestStatistic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsTestStatistic*)
   {
      ::RooAbsTestStatistic *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsTestStatistic >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsTestStatistic", ::RooAbsTestStatistic::Class_Version(), "RooAbsTestStatistic.h", 39,
                  typeid(::RooAbsTestStatistic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsTestStatistic::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsTestStatistic) );
      instance.SetDelete(&delete_RooAbsTestStatistic);
      instance.SetDeleteArray(&deleteArray_RooAbsTestStatistic);
      instance.SetDestructor(&destruct_RooAbsTestStatistic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsTestStatistic*)
   {
      return GenerateInitInstanceLocal((::RooAbsTestStatistic*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsOptTestStatistic(void *p);
   static void deleteArray_RooAbsOptTestStatistic(void *p);
   static void destruct_RooAbsOptTestStatistic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsOptTestStatistic*)
   {
      ::RooAbsOptTestStatistic *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsOptTestStatistic >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsOptTestStatistic", ::RooAbsOptTestStatistic::Class_Version(), "RooAbsOptTestStatistic.h", 28,
                  typeid(::RooAbsOptTestStatistic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsOptTestStatistic::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsOptTestStatistic) );
      instance.SetDelete(&delete_RooAbsOptTestStatistic);
      instance.SetDeleteArray(&deleteArray_RooAbsOptTestStatistic);
      instance.SetDestructor(&destruct_RooAbsOptTestStatistic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsOptTestStatistic*)
   {
      return GenerateInitInstanceLocal((::RooAbsOptTestStatistic*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsRootFinder(void *p);
   static void deleteArray_RooAbsRootFinder(void *p);
   static void destruct_RooAbsRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsRootFinder*)
   {
      ::RooAbsRootFinder *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsRootFinder >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsRootFinder", ::RooAbsRootFinder::Class_Version(), "RooAbsRootFinder.h", 23,
                  typeid(::RooAbsRootFinder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsRootFinder::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsRootFinder) );
      instance.SetDelete(&delete_RooAbsRootFinder);
      instance.SetDeleteArray(&deleteArray_RooAbsRootFinder);
      instance.SetDestructor(&destruct_RooAbsRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsRootFinder*)
   {
      return GenerateInitInstanceLocal((::RooAbsRootFinder*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsRootFinder*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsSelfCachedPdf(void *p);
   static void deleteArray_RooAbsSelfCachedPdf(void *p);
   static void destruct_RooAbsSelfCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsSelfCachedPdf*)
   {
      ::RooAbsSelfCachedPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsSelfCachedPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsSelfCachedPdf", ::RooAbsSelfCachedPdf::Class_Version(), "RooAbsSelfCachedPdf.h", 21,
                  typeid(::RooAbsSelfCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsSelfCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsSelfCachedPdf) );
      instance.SetDelete(&delete_RooAbsSelfCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooAbsSelfCachedPdf);
      instance.SetDestructor(&destruct_RooAbsSelfCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsSelfCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooAbsSelfCachedPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsSelfCachedReal(void *p);
   static void deleteArray_RooAbsSelfCachedReal(void *p);
   static void destruct_RooAbsSelfCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsSelfCachedReal*)
   {
      ::RooAbsSelfCachedReal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsSelfCachedReal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsSelfCachedReal", ::RooAbsSelfCachedReal::Class_Version(), "RooAbsSelfCachedReal.h", 21,
                  typeid(::RooAbsSelfCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsSelfCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsSelfCachedReal) );
      instance.SetDelete(&delete_RooAbsSelfCachedReal);
      instance.SetDeleteArray(&deleteArray_RooAbsSelfCachedReal);
      instance.SetDestructor(&destruct_RooAbsSelfCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsSelfCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooAbsSelfCachedReal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooStringVar(void *p = nullptr);
   static void *newArray_RooStringVar(Long_t size, void *p);
   static void delete_RooStringVar(void *p);
   static void deleteArray_RooStringVar(void *p);
   static void destruct_RooStringVar(void *p);

   // Schema evolution read functions
   static void read_RooStringVar_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__len = oldObj->GetId("_len");
      static Int_t id__value = oldObj->GetId("_value");
#endif
      struct RooStringVar_Onfile {
         Int_t &_len;
         char* &_value;
         RooStringVar_Onfile(Int_t &onfile__len, char* &onfile__value ): _len(onfile__len), _value(onfile__value) {}
      };
      static Long_t offset_Onfile_RooStringVar__len = oldObj->GetClass()->GetDataMemberOffset("_len");
      static Long_t offset_Onfile_RooStringVar__value = oldObj->GetClass()->GetDataMemberOffset("_value");
      char *onfile_add = (char*)oldObj->GetObject();
      RooStringVar_Onfile onfile(
         *(Int_t*)(onfile_add+offset_Onfile_RooStringVar__len),
         *(char**)(onfile_add+offset_Onfile_RooStringVar__value) );

      static TClassRef cls("RooStringVar");
      static Long_t offset__string = cls->GetDataMemberOffset("_string");
      string& _string = *(string*)(target+offset__string);
      RooStringVar* newObj = (RooStringVar*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     _string.assign(onfile._value, onfile._len);
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStringVar*)
   {
      ::RooStringVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStringVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooStringVar", ::RooStringVar::Class_Version(), "RooStringVar.h", 23,
                  typeid(::RooStringVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStringVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooStringVar) );
      instance.SetNew(&new_RooStringVar);
      instance.SetNewArray(&newArray_RooStringVar);
      instance.SetDelete(&delete_RooStringVar);
      instance.SetDeleteArray(&deleteArray_RooStringVar);
      instance.SetDestructor(&destruct_RooStringVar);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooAbsString";
      rule->fTarget      = "_string";
      rule->fSource      = "Int_t _len; char *_value";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooStringVar_0);
      rule->fCode        = "_string.assign(onfile._value, onfile._len);";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStringVar*)
   {
      return GenerateInitInstanceLocal((::RooStringVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStringVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAbsStudy(void *p);
   static void deleteArray_RooAbsStudy(void *p);
   static void destruct_RooAbsStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAbsStudy*)
   {
      ::RooAbsStudy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAbsStudy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAbsStudy", ::RooAbsStudy::Class_Version(), "RooAbsStudy.h", 33,
                  typeid(::RooAbsStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAbsStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooAbsStudy) );
      instance.SetDelete(&delete_RooAbsStudy);
      instance.SetDeleteArray(&deleteArray_RooAbsStudy);
      instance.SetDestructor(&destruct_RooAbsStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAbsStudy*)
   {
      return GenerateInitInstanceLocal((::RooAbsStudy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAbsStudy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAcceptReject(void *p = nullptr);
   static void *newArray_RooAcceptReject(Long_t size, void *p);
   static void delete_RooAcceptReject(void *p);
   static void deleteArray_RooAcceptReject(void *p);
   static void destruct_RooAcceptReject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAcceptReject*)
   {
      ::RooAcceptReject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAcceptReject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAcceptReject", ::RooAcceptReject::Class_Version(), "RooAcceptReject.h", 29,
                  typeid(::RooAcceptReject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAcceptReject::Dictionary, isa_proxy, 4,
                  sizeof(::RooAcceptReject) );
      instance.SetNew(&new_RooAcceptReject);
      instance.SetNewArray(&newArray_RooAcceptReject);
      instance.SetDelete(&delete_RooAcceptReject);
      instance.SetDeleteArray(&deleteArray_RooAcceptReject);
      instance.SetDestructor(&destruct_RooAcceptReject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAcceptReject*)
   {
      return GenerateInitInstanceLocal((::RooAcceptReject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAcceptReject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAdaptiveIntegratorND(void *p = nullptr);
   static void *newArray_RooAdaptiveIntegratorND(Long_t size, void *p);
   static void delete_RooAdaptiveIntegratorND(void *p);
   static void deleteArray_RooAdaptiveIntegratorND(void *p);
   static void destruct_RooAdaptiveIntegratorND(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAdaptiveIntegratorND*)
   {
      ::RooAdaptiveIntegratorND *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAdaptiveIntegratorND >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAdaptiveIntegratorND", ::RooAdaptiveIntegratorND::Class_Version(), "RooAdaptiveIntegratorND.h", 26,
                  typeid(::RooAdaptiveIntegratorND), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAdaptiveIntegratorND::Dictionary, isa_proxy, 4,
                  sizeof(::RooAdaptiveIntegratorND) );
      instance.SetNew(&new_RooAdaptiveIntegratorND);
      instance.SetNewArray(&newArray_RooAdaptiveIntegratorND);
      instance.SetDelete(&delete_RooAdaptiveIntegratorND);
      instance.SetDeleteArray(&deleteArray_RooAdaptiveIntegratorND);
      instance.SetDestructor(&destruct_RooAdaptiveIntegratorND);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAdaptiveIntegratorND*)
   {
      return GenerateInitInstanceLocal((::RooAdaptiveIntegratorND*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddPdf(void *p = nullptr);
   static void *newArray_RooAddPdf(Long_t size, void *p);
   static void delete_RooAddPdf(void *p);
   static void deleteArray_RooAddPdf(void *p);
   static void destruct_RooAddPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddPdf*)
   {
      ::RooAddPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddPdf", ::RooAddPdf::Class_Version(), "RooAddPdf.h", 32,
                  typeid(::RooAddPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddPdf) );
      instance.SetNew(&new_RooAddPdf);
      instance.SetNewArray(&newArray_RooAddPdf);
      instance.SetDelete(&delete_RooAddPdf);
      instance.SetDeleteArray(&deleteArray_RooAddPdf);
      instance.SetDestructor(&destruct_RooAddPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddPdf*)
   {
      return GenerateInitInstanceLocal((::RooAddPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFormula(void *p = nullptr);
   static void *newArray_RooFormula(Long_t size, void *p);
   static void delete_RooFormula(void *p);
   static void deleteArray_RooFormula(void *p);
   static void destruct_RooFormula(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFormula*)
   {
      ::RooFormula *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFormula >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFormula", ::RooFormula::Class_Version(), "RooFormula.h", 32,
                  typeid(::RooFormula), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFormula::Dictionary, isa_proxy, 4,
                  sizeof(::RooFormula) );
      instance.SetNew(&new_RooFormula);
      instance.SetNewArray(&newArray_RooFormula);
      instance.SetDelete(&delete_RooFormula);
      instance.SetDeleteArray(&deleteArray_RooFormula);
      instance.SetDestructor(&destruct_RooFormula);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFormula*)
   {
      return GenerateInitInstanceLocal((::RooFormula*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFormula*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFormulaVar(void *p = nullptr);
   static void *newArray_RooFormulaVar(Long_t size, void *p);
   static void delete_RooFormulaVar(void *p);
   static void deleteArray_RooFormulaVar(void *p);
   static void destruct_RooFormulaVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFormulaVar*)
   {
      ::RooFormulaVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFormulaVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFormulaVar", ::RooFormulaVar::Class_Version(), "RooFormulaVar.h", 30,
                  typeid(::RooFormulaVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFormulaVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooFormulaVar) );
      instance.SetNew(&new_RooFormulaVar);
      instance.SetNewArray(&newArray_RooFormulaVar);
      instance.SetDelete(&delete_RooFormulaVar);
      instance.SetDeleteArray(&deleteArray_RooFormulaVar);
      instance.SetDestructor(&destruct_RooFormulaVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFormulaVar*)
   {
      return GenerateInitInstanceLocal((::RooFormulaVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFormulaVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooResolutionModel(void *p);
   static void deleteArray_RooResolutionModel(void *p);
   static void destruct_RooResolutionModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooResolutionModel*)
   {
      ::RooResolutionModel *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooResolutionModel >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooResolutionModel", ::RooResolutionModel::Class_Version(), "RooResolutionModel.h", 26,
                  typeid(::RooResolutionModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooResolutionModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooResolutionModel) );
      instance.SetDelete(&delete_RooResolutionModel);
      instance.SetDeleteArray(&deleteArray_RooResolutionModel);
      instance.SetDestructor(&destruct_RooResolutionModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooResolutionModel*)
   {
      return GenerateInitInstanceLocal((::RooResolutionModel*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooResolutionModel*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddModel(void *p = nullptr);
   static void *newArray_RooAddModel(Long_t size, void *p);
   static void delete_RooAddModel(void *p);
   static void deleteArray_RooAddModel(void *p);
   static void destruct_RooAddModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddModel*)
   {
      ::RooAddModel *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddModel >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddModel", ::RooAddModel::Class_Version(), "RooAddModel.h", 26,
                  typeid(::RooAddModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddModel) );
      instance.SetNew(&new_RooAddModel);
      instance.SetNewArray(&newArray_RooAddModel);
      instance.SetDelete(&delete_RooAddModel);
      instance.SetDeleteArray(&deleteArray_RooAddModel);
      instance.SetDestructor(&destruct_RooAddModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddModel*)
   {
      return GenerateInitInstanceLocal((::RooAddModel*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddModel*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooAddGenContext(void *p);
   static void deleteArray_RooAddGenContext(void *p);
   static void destruct_RooAddGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddGenContext*)
   {
      ::RooAddGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddGenContext", ::RooAddGenContext::Class_Version(), "RooAddGenContext.h", 32,
                  typeid(::RooAddGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddGenContext) );
      instance.SetDelete(&delete_RooAddGenContext);
      instance.SetDeleteArray(&deleteArray_RooAddGenContext);
      instance.SetDestructor(&destruct_RooAddGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddGenContext*)
   {
      return GenerateInitInstanceLocal((::RooAddGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooAddition(void *p = nullptr);
   static void *newArray_RooAddition(Long_t size, void *p);
   static void delete_RooAddition(void *p);
   static void deleteArray_RooAddition(void *p);
   static void destruct_RooAddition(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooAddition*)
   {
      ::RooAddition *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooAddition >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooAddition", ::RooAddition::Class_Version(), "RooAddition.h", 27,
                  typeid(::RooAddition), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooAddition::Dictionary, isa_proxy, 4,
                  sizeof(::RooAddition) );
      instance.SetNew(&new_RooAddition);
      instance.SetNewArray(&newArray_RooAddition);
      instance.SetDelete(&delete_RooAddition);
      instance.SetDeleteArray(&deleteArray_RooAddition);
      instance.SetDestructor(&destruct_RooAddition);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooAddition*)
   {
      return GenerateInitInstanceLocal((::RooAddition*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooAddition*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinIntegrator(void *p = nullptr);
   static void *newArray_RooBinIntegrator(Long_t size, void *p);
   static void delete_RooBinIntegrator(void *p);
   static void deleteArray_RooBinIntegrator(void *p);
   static void destruct_RooBinIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinIntegrator*)
   {
      ::RooBinIntegrator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinIntegrator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinIntegrator", ::RooBinIntegrator::Class_Version(), "RooBinIntegrator.h", 28,
                  typeid(::RooBinIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinIntegrator) );
      instance.SetNew(&new_RooBinIntegrator);
      instance.SetNewArray(&newArray_RooBinIntegrator);
      instance.SetDelete(&delete_RooBinIntegrator);
      instance.SetDeleteArray(&deleteArray_RooBinIntegrator);
      instance.SetDestructor(&destruct_RooBinIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooBinIntegrator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinIntegrator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooBinnedGenContext(void *p);
   static void deleteArray_RooBinnedGenContext(void *p);
   static void destruct_RooBinnedGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinnedGenContext*)
   {
      ::RooBinnedGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinnedGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinnedGenContext", ::RooBinnedGenContext::Class_Version(), "RooBinnedGenContext.h", 30,
                  typeid(::RooBinnedGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinnedGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinnedGenContext) );
      instance.SetDelete(&delete_RooBinnedGenContext);
      instance.SetDeleteArray(&deleteArray_RooBinnedGenContext);
      instance.SetDestructor(&destruct_RooBinnedGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinnedGenContext*)
   {
      return GenerateInitInstanceLocal((::RooBinnedGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinnedGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinningCategory(void *p = nullptr);
   static void *newArray_RooBinningCategory(Long_t size, void *p);
   static void delete_RooBinningCategory(void *p);
   static void deleteArray_RooBinningCategory(void *p);
   static void destruct_RooBinningCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinningCategory*)
   {
      ::RooBinningCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinningCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinningCategory", ::RooBinningCategory::Class_Version(), "RooBinningCategory.h", 23,
                  typeid(::RooBinningCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinningCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinningCategory) );
      instance.SetNew(&new_RooBinningCategory);
      instance.SetNewArray(&newArray_RooBinningCategory);
      instance.SetDelete(&delete_RooBinningCategory);
      instance.SetDeleteArray(&deleteArray_RooBinningCategory);
      instance.SetDestructor(&destruct_RooBinningCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinningCategory*)
   {
      return GenerateInitInstanceLocal((::RooBinningCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinningCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDouble(void *p = nullptr);
   static void *newArray_RooDouble(Long_t size, void *p);
   static void delete_RooDouble(void *p);
   static void deleteArray_RooDouble(void *p);
   static void destruct_RooDouble(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDouble*)
   {
      ::RooDouble *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDouble >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDouble", ::RooDouble::Class_Version(), "RooDouble.h", 22,
                  typeid(::RooDouble), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDouble::Dictionary, isa_proxy, 4,
                  sizeof(::RooDouble) );
      instance.SetNew(&new_RooDouble);
      instance.SetNewArray(&newArray_RooDouble);
      instance.SetDelete(&delete_RooDouble);
      instance.SetDeleteArray(&deleteArray_RooDouble);
      instance.SetDestructor(&destruct_RooDouble);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDouble*)
   {
      return GenerateInitInstanceLocal((::RooDouble*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDouble*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinning(void *p = nullptr);
   static void *newArray_RooBinning(Long_t size, void *p);
   static void delete_RooBinning(void *p);
   static void deleteArray_RooBinning(void *p);
   static void destruct_RooBinning(void *p);
   static void streamer_RooBinning(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinning*)
   {
      ::RooBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinning", ::RooBinning::Class_Version(), "RooBinning.h", 28,
                  typeid(::RooBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinning::Dictionary, isa_proxy, 17,
                  sizeof(::RooBinning) );
      instance.SetNew(&new_RooBinning);
      instance.SetNewArray(&newArray_RooBinning);
      instance.SetDelete(&delete_RooBinning);
      instance.SetDeleteArray(&deleteArray_RooBinning);
      instance.SetDestructor(&destruct_RooBinning);
      instance.SetStreamerFunc(&streamer_RooBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinning*)
   {
      return GenerateInitInstanceLocal((::RooBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooBrentRootFinder(void *p);
   static void deleteArray_RooBrentRootFinder(void *p);
   static void destruct_RooBrentRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBrentRootFinder*)
   {
      ::RooBrentRootFinder *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBrentRootFinder >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBrentRootFinder", ::RooBrentRootFinder::Class_Version(), "RooBrentRootFinder.h", 21,
                  typeid(::RooBrentRootFinder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBrentRootFinder::Dictionary, isa_proxy, 4,
                  sizeof(::RooBrentRootFinder) );
      instance.SetDelete(&delete_RooBrentRootFinder);
      instance.SetDeleteArray(&deleteArray_RooBrentRootFinder);
      instance.SetDestructor(&destruct_RooBrentRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBrentRootFinder*)
   {
      return GenerateInitInstanceLocal((::RooBrentRootFinder*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBrentRootFinder*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCachedPdf(void *p = nullptr);
   static void *newArray_RooCachedPdf(Long_t size, void *p);
   static void delete_RooCachedPdf(void *p);
   static void deleteArray_RooCachedPdf(void *p);
   static void destruct_RooCachedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCachedPdf*)
   {
      ::RooCachedPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCachedPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCachedPdf", ::RooCachedPdf::Class_Version(), "RooCachedPdf.h", 20,
                  typeid(::RooCachedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCachedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooCachedPdf) );
      instance.SetNew(&new_RooCachedPdf);
      instance.SetNewArray(&newArray_RooCachedPdf);
      instance.SetDelete(&delete_RooCachedPdf);
      instance.SetDeleteArray(&deleteArray_RooCachedPdf);
      instance.SetDestructor(&destruct_RooCachedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCachedPdf*)
   {
      return GenerateInitInstanceLocal((::RooCachedPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCachedPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCachedReal(void *p = nullptr);
   static void *newArray_RooCachedReal(Long_t size, void *p);
   static void delete_RooCachedReal(void *p);
   static void deleteArray_RooCachedReal(void *p);
   static void destruct_RooCachedReal(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCachedReal*)
   {
      ::RooCachedReal *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCachedReal >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCachedReal", ::RooCachedReal::Class_Version(), "RooCachedReal.h", 20,
                  typeid(::RooCachedReal), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCachedReal::Dictionary, isa_proxy, 4,
                  sizeof(::RooCachedReal) );
      instance.SetNew(&new_RooCachedReal);
      instance.SetNewArray(&newArray_RooCachedReal);
      instance.SetDelete(&delete_RooCachedReal);
      instance.SetDeleteArray(&deleteArray_RooCachedReal);
      instance.SetDestructor(&destruct_RooCachedReal);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCachedReal*)
   {
      return GenerateInitInstanceLocal((::RooCachedReal*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCachedReal*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataHist(void *p = nullptr);
   static void *newArray_RooDataHist(Long_t size, void *p);
   static void delete_RooDataHist(void *p);
   static void deleteArray_RooDataHist(void *p);
   static void destruct_RooDataHist(void *p);
   static void streamer_RooDataHist(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataHist*)
   {
      ::RooDataHist *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataHist >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataHist", ::RooDataHist::Class_Version(), "RooDataHist.h", 45,
                  typeid(::RooDataHist), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataHist::Dictionary, isa_proxy, 17,
                  sizeof(::RooDataHist) );
      instance.SetNew(&new_RooDataHist);
      instance.SetNewArray(&newArray_RooDataHist);
      instance.SetDelete(&delete_RooDataHist);
      instance.SetDeleteArray(&deleteArray_RooDataHist);
      instance.SetDestructor(&destruct_RooDataHist);
      instance.SetStreamerFunc(&streamer_RooDataHist);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataHist*)
   {
      return GenerateInitInstanceLocal((::RooDataHist*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataHist*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooChi2Var(void *p);
   static void deleteArray_RooChi2Var(void *p);
   static void destruct_RooChi2Var(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooChi2Var*)
   {
      ::RooChi2Var *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooChi2Var >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooChi2Var", ::RooChi2Var::Class_Version(), "RooChi2Var.h", 25,
                  typeid(::RooChi2Var), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooChi2Var::Dictionary, isa_proxy, 4,
                  sizeof(::RooChi2Var) );
      instance.SetDelete(&delete_RooChi2Var);
      instance.SetDeleteArray(&deleteArray_RooChi2Var);
      instance.SetDestructor(&destruct_RooChi2Var);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooChi2Var*)
   {
      return GenerateInitInstanceLocal((::RooChi2Var*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooChi2Var*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooFactoryWSTool(void *p);
   static void deleteArray_RooFactoryWSTool(void *p);
   static void destruct_RooFactoryWSTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFactoryWSTool*)
   {
      ::RooFactoryWSTool *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFactoryWSTool >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFactoryWSTool", ::RooFactoryWSTool::Class_Version(), "RooFactoryWSTool.h", 47,
                  typeid(::RooFactoryWSTool), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFactoryWSTool::Dictionary, isa_proxy, 4,
                  sizeof(::RooFactoryWSTool) );
      instance.SetDelete(&delete_RooFactoryWSTool);
      instance.SetDeleteArray(&deleteArray_RooFactoryWSTool);
      instance.SetDestructor(&destruct_RooFactoryWSTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFactoryWSTool*)
   {
      return GenerateInitInstanceLocal((::RooFactoryWSTool*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFactoryWSTool*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooClassFactory(void *p = nullptr);
   static void *newArray_RooClassFactory(Long_t size, void *p);
   static void delete_RooClassFactory(void *p);
   static void deleteArray_RooClassFactory(void *p);
   static void destruct_RooClassFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooClassFactory*)
   {
      ::RooClassFactory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooClassFactory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooClassFactory", ::RooClassFactory::Class_Version(), "RooClassFactory.h", 31,
                  typeid(::RooClassFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooClassFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooClassFactory) );
      instance.SetNew(&new_RooClassFactory);
      instance.SetNewArray(&newArray_RooClassFactory);
      instance.SetDelete(&delete_RooClassFactory);
      instance.SetDeleteArray(&deleteArray_RooClassFactory);
      instance.SetDestructor(&destruct_RooClassFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooClassFactory*)
   {
      return GenerateInitInstanceLocal((::RooClassFactory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooClassFactory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooCmdConfig(void *p);
   static void deleteArray_RooCmdConfig(void *p);
   static void destruct_RooCmdConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCmdConfig*)
   {
      ::RooCmdConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCmdConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCmdConfig", ::RooCmdConfig::Class_Version(), "RooCmdConfig.h", 27,
                  typeid(::RooCmdConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCmdConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooCmdConfig) );
      instance.SetDelete(&delete_RooCmdConfig);
      instance.SetDeleteArray(&deleteArray_RooCmdConfig);
      instance.SetDestructor(&destruct_RooCmdConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCmdConfig*)
   {
      return GenerateInitInstanceLocal((::RooCmdConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCmdConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCompositeDataStore(void *p = nullptr);
   static void *newArray_RooCompositeDataStore(Long_t size, void *p);
   static void delete_RooCompositeDataStore(void *p);
   static void deleteArray_RooCompositeDataStore(void *p);
   static void destruct_RooCompositeDataStore(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCompositeDataStore*)
   {
      ::RooCompositeDataStore *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCompositeDataStore >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCompositeDataStore", ::RooCompositeDataStore::Class_Version(), "RooCompositeDataStore.h", 34,
                  typeid(::RooCompositeDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCompositeDataStore::Dictionary, isa_proxy, 4,
                  sizeof(::RooCompositeDataStore) );
      instance.SetNew(&new_RooCompositeDataStore);
      instance.SetNewArray(&newArray_RooCompositeDataStore);
      instance.SetDelete(&delete_RooCompositeDataStore);
      instance.SetDeleteArray(&deleteArray_RooCompositeDataStore);
      instance.SetDestructor(&destruct_RooCompositeDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCompositeDataStore*)
   {
      return GenerateInitInstanceLocal((::RooCompositeDataStore*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCompositeDataStore*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConstraintSum(void *p = nullptr);
   static void *newArray_RooConstraintSum(Long_t size, void *p);
   static void delete_RooConstraintSum(void *p);
   static void deleteArray_RooConstraintSum(void *p);
   static void destruct_RooConstraintSum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConstraintSum*)
   {
      ::RooConstraintSum *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConstraintSum >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooConstraintSum", ::RooConstraintSum::Class_Version(), "RooConstraintSum.h", 27,
                  typeid(::RooConstraintSum), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConstraintSum::Dictionary, isa_proxy, 4,
                  sizeof(::RooConstraintSum) );
      instance.SetNew(&new_RooConstraintSum);
      instance.SetNewArray(&newArray_RooConstraintSum);
      instance.SetDelete(&delete_RooConstraintSum);
      instance.SetDeleteArray(&deleteArray_RooConstraintSum);
      instance.SetDestructor(&destruct_RooConstraintSum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConstraintSum*)
   {
      return GenerateInitInstanceLocal((::RooConstraintSum*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConstraintSum*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConstVar(void *p = nullptr);
   static void *newArray_RooConstVar(Long_t size, void *p);
   static void delete_RooConstVar(void *p);
   static void deleteArray_RooConstVar(void *p);
   static void destruct_RooConstVar(void *p);

   // Schema evolution read functions
   static void read_RooConstVar_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__value = oldObj->GetId("_value");
#endif
      struct RooConstVar_Onfile {
         Double_t &_value;
         RooConstVar_Onfile(Double_t &onfile__value ): _value(onfile__value) {}
      };
      static Long_t offset_Onfile_RooConstVar__value = oldObj->GetClass()->GetDataMemberOffset("_value");
      char *onfile_add = (char*)oldObj->GetObject();
      RooConstVar_Onfile onfile(
         *(Double_t*)(onfile_add+offset_Onfile_RooConstVar__value) );

      RooConstVar* newObj = (RooConstVar*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      newObj->changeVal(onfile._value); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConstVar*)
   {
      ::RooConstVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConstVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooConstVar", ::RooConstVar::Class_Version(), "RooConstVar.h", 26,
                  typeid(::RooConstVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConstVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooConstVar) );
      instance.SetNew(&new_RooConstVar);
      instance.SetNewArray(&newArray_RooConstVar);
      instance.SetDelete(&delete_RooConstVar);
      instance.SetDeleteArray(&deleteArray_RooConstVar);
      instance.SetDestructor(&destruct_RooConstVar);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooConstVar";
      rule->fTarget      = "";
      rule->fSource      = "Double_t _value";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooConstVar_0);
      rule->fCode        = " newObj->changeVal(onfile._value); ";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConstVar*)
   {
      return GenerateInitInstanceLocal((::RooConstVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConstVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooConvCoefVar(void *p = nullptr);
   static void *newArray_RooConvCoefVar(Long_t size, void *p);
   static void delete_RooConvCoefVar(void *p);
   static void deleteArray_RooConvCoefVar(void *p);
   static void destruct_RooConvCoefVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvCoefVar*)
   {
      ::RooConvCoefVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvCoefVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvCoefVar", ::RooConvCoefVar::Class_Version(), "RooConvCoefVar.h", 28,
                  typeid(::RooConvCoefVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvCoefVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvCoefVar) );
      instance.SetNew(&new_RooConvCoefVar);
      instance.SetNewArray(&newArray_RooConvCoefVar);
      instance.SetDelete(&delete_RooConvCoefVar);
      instance.SetDeleteArray(&deleteArray_RooConvCoefVar);
      instance.SetDestructor(&destruct_RooConvCoefVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvCoefVar*)
   {
      return GenerateInitInstanceLocal((::RooConvCoefVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvCoefVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooConvGenContext(void *p);
   static void deleteArray_RooConvGenContext(void *p);
   static void destruct_RooConvGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvGenContext*)
   {
      ::RooConvGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvGenContext", ::RooConvGenContext::Class_Version(), "RooConvGenContext.h", 31,
                  typeid(::RooConvGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvGenContext) );
      instance.SetDelete(&delete_RooConvGenContext);
      instance.SetDeleteArray(&deleteArray_RooConvGenContext);
      instance.SetDestructor(&destruct_RooConvGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvGenContext*)
   {
      return GenerateInitInstanceLocal((::RooConvGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooConvIntegrandBinding(void *p);
   static void deleteArray_RooConvIntegrandBinding(void *p);
   static void destruct_RooConvIntegrandBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooConvIntegrandBinding*)
   {
      ::RooConvIntegrandBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooConvIntegrandBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooConvIntegrandBinding", ::RooConvIntegrandBinding::Class_Version(), "RooConvIntegrandBinding.h", 25,
                  typeid(::RooConvIntegrandBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooConvIntegrandBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooConvIntegrandBinding) );
      instance.SetDelete(&delete_RooConvIntegrandBinding);
      instance.SetDeleteArray(&deleteArray_RooConvIntegrandBinding);
      instance.SetDestructor(&destruct_RooConvIntegrandBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooConvIntegrandBinding*)
   {
      return GenerateInitInstanceLocal((::RooConvIntegrandBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooCustomizer(void *p);
   static void deleteArray_RooCustomizer(void *p);
   static void destruct_RooCustomizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCustomizer*)
   {
      ::RooCustomizer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCustomizer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCustomizer", ::RooCustomizer::Class_Version(), "RooCustomizer.h", 35,
                  typeid(::RooCustomizer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCustomizer::Dictionary, isa_proxy, 4,
                  sizeof(::RooCustomizer) );
      instance.SetDelete(&delete_RooCustomizer);
      instance.SetDeleteArray(&deleteArray_RooCustomizer);
      instance.SetDestructor(&destruct_RooCustomizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCustomizer*)
   {
      return GenerateInitInstanceLocal((::RooCustomizer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCustomizer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDataHistSliceIter(void *p);
   static void deleteArray_RooDataHistSliceIter(void *p);
   static void destruct_RooDataHistSliceIter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataHistSliceIter*)
   {
      ::RooDataHistSliceIter *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataHistSliceIter >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataHistSliceIter", ::RooDataHistSliceIter::Class_Version(), "RooDataHistSliceIter.h", 26,
                  typeid(::RooDataHistSliceIter), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataHistSliceIter::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataHistSliceIter) );
      instance.SetDelete(&delete_RooDataHistSliceIter);
      instance.SetDeleteArray(&deleteArray_RooDataHistSliceIter);
      instance.SetDestructor(&destruct_RooDataHistSliceIter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataHistSliceIter*)
   {
      return GenerateInitInstanceLocal((::RooDataHistSliceIter*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealBinding(void *p);
   static void deleteArray_RooRealBinding(void *p);
   static void destruct_RooRealBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealBinding*)
   {
      ::RooRealBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealBinding", ::RooRealBinding::Class_Version(), "RooRealBinding.h", 29,
                  typeid(::RooRealBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealBinding) );
      instance.SetDelete(&delete_RooRealBinding);
      instance.SetDeleteArray(&deleteArray_RooRealBinding);
      instance.SetDestructor(&destruct_RooRealBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealBinding*)
   {
      return GenerateInitInstanceLocal((::RooRealBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDataProjBinding(void *p);
   static void deleteArray_RooDataProjBinding(void *p);
   static void destruct_RooDataProjBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataProjBinding*)
   {
      ::RooDataProjBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataProjBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataProjBinding", ::RooDataProjBinding::Class_Version(), "RooDataProjBinding.h", 25,
                  typeid(::RooDataProjBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataProjBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataProjBinding) );
      instance.SetDelete(&delete_RooDataProjBinding);
      instance.SetDeleteArray(&deleteArray_RooDataProjBinding);
      instance.SetDestructor(&destruct_RooDataProjBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataProjBinding*)
   {
      return GenerateInitInstanceLocal((::RooDataProjBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataProjBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDataWeightedAverage(void *p = nullptr);
   static void *newArray_RooDataWeightedAverage(Long_t size, void *p);
   static void delete_RooDataWeightedAverage(void *p);
   static void deleteArray_RooDataWeightedAverage(void *p);
   static void destruct_RooDataWeightedAverage(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDataWeightedAverage*)
   {
      ::RooDataWeightedAverage *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDataWeightedAverage >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDataWeightedAverage", ::RooDataWeightedAverage::Class_Version(), "RooDataWeightedAverage.h", 22,
                  typeid(::RooDataWeightedAverage), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDataWeightedAverage::Dictionary, isa_proxy, 4,
                  sizeof(::RooDataWeightedAverage) );
      instance.SetNew(&new_RooDataWeightedAverage);
      instance.SetNewArray(&newArray_RooDataWeightedAverage);
      instance.SetDelete(&delete_RooDataWeightedAverage);
      instance.SetDeleteArray(&deleteArray_RooDataWeightedAverage);
      instance.SetDestructor(&destruct_RooDataWeightedAverage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDataWeightedAverage*)
   {
      return GenerateInitInstanceLocal((::RooDataWeightedAverage*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooDerivative(void *p = nullptr);
   static void *newArray_RooDerivative(Long_t size, void *p);
   static void delete_RooDerivative(void *p);
   static void deleteArray_RooDerivative(void *p);
   static void destruct_RooDerivative(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDerivative*)
   {
      ::RooDerivative *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDerivative >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDerivative", ::RooDerivative::Class_Version(), "RooDerivative.h", 30,
                  typeid(::RooDerivative), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDerivative::Dictionary, isa_proxy, 4,
                  sizeof(::RooDerivative) );
      instance.SetNew(&new_RooDerivative);
      instance.SetNewArray(&newArray_RooDerivative);
      instance.SetDelete(&delete_RooDerivative);
      instance.SetDeleteArray(&deleteArray_RooDerivative);
      instance.SetDestructor(&destruct_RooDerivative);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDerivative*)
   {
      return GenerateInitInstanceLocal((::RooDerivative*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDerivative*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooDLLSignificanceMCSModule(void *p);
   static void deleteArray_RooDLLSignificanceMCSModule(void *p);
   static void destruct_RooDLLSignificanceMCSModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooDLLSignificanceMCSModule*)
   {
      ::RooDLLSignificanceMCSModule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooDLLSignificanceMCSModule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooDLLSignificanceMCSModule", ::RooDLLSignificanceMCSModule::Class_Version(), "RooDLLSignificanceMCSModule.h", 23,
                  typeid(::RooDLLSignificanceMCSModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooDLLSignificanceMCSModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooDLLSignificanceMCSModule) );
      instance.SetDelete(&delete_RooDLLSignificanceMCSModule);
      instance.SetDeleteArray(&deleteArray_RooDLLSignificanceMCSModule);
      instance.SetDestructor(&destruct_RooDLLSignificanceMCSModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooDLLSignificanceMCSModule*)
   {
      return GenerateInitInstanceLocal((::RooDLLSignificanceMCSModule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooEffGenContext(void *p);
   static void deleteArray_RooEffGenContext(void *p);
   static void destruct_RooEffGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEffGenContext*)
   {
      ::RooEffGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEffGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooEffGenContext", ::RooEffGenContext::Class_Version(), "RooEffGenContext.h", 23,
                  typeid(::RooEffGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEffGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooEffGenContext) );
      instance.SetDelete(&delete_RooEffGenContext);
      instance.SetDeleteArray(&deleteArray_RooEffGenContext);
      instance.SetDestructor(&destruct_RooEffGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEffGenContext*)
   {
      return GenerateInitInstanceLocal((::RooEffGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEffGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEfficiency(void *p = nullptr);
   static void *newArray_RooEfficiency(Long_t size, void *p);
   static void delete_RooEfficiency(void *p);
   static void deleteArray_RooEfficiency(void *p);
   static void destruct_RooEfficiency(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEfficiency*)
   {
      ::RooEfficiency *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEfficiency >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooEfficiency", ::RooEfficiency::Class_Version(), "RooEfficiency.h", 27,
                  typeid(::RooEfficiency), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEfficiency::Dictionary, isa_proxy, 4,
                  sizeof(::RooEfficiency) );
      instance.SetNew(&new_RooEfficiency);
      instance.SetNewArray(&newArray_RooEfficiency);
      instance.SetDelete(&delete_RooEfficiency);
      instance.SetDeleteArray(&deleteArray_RooEfficiency);
      instance.SetDestructor(&destruct_RooEfficiency);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEfficiency*)
   {
      return GenerateInitInstanceLocal((::RooEfficiency*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEfficiency*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEffProd(void *p = nullptr);
   static void *newArray_RooEffProd(Long_t size, void *p);
   static void delete_RooEffProd(void *p);
   static void deleteArray_RooEffProd(void *p);
   static void destruct_RooEffProd(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEffProd*)
   {
      ::RooEffProd *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEffProd >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooEffProd", ::RooEffProd::Class_Version(), "RooEffProd.h", 20,
                  typeid(::RooEffProd), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEffProd::Dictionary, isa_proxy, 4,
                  sizeof(::RooEffProd) );
      instance.SetNew(&new_RooEffProd);
      instance.SetNewArray(&newArray_RooEffProd);
      instance.SetDelete(&delete_RooEffProd);
      instance.SetDeleteArray(&deleteArray_RooEffProd);
      instance.SetDestructor(&destruct_RooEffProd);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEffProd*)
   {
      return GenerateInitInstanceLocal((::RooEffProd*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEffProd*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooEllipse(void *p = nullptr);
   static void *newArray_RooEllipse(Long_t size, void *p);
   static void delete_RooEllipse(void *p);
   static void deleteArray_RooEllipse(void *p);
   static void destruct_RooEllipse(void *p);
   static Long64_t merge_RooEllipse(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooEllipse*)
   {
      ::RooEllipse *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooEllipse >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooEllipse", ::RooEllipse::Class_Version(), "RooEllipse.h", 22,
                  typeid(::RooEllipse), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooEllipse::Dictionary, isa_proxy, 4,
                  sizeof(::RooEllipse) );
      instance.SetNew(&new_RooEllipse);
      instance.SetNewArray(&newArray_RooEllipse);
      instance.SetDelete(&delete_RooEllipse);
      instance.SetDeleteArray(&deleteArray_RooEllipse);
      instance.SetDestructor(&destruct_RooEllipse);
      instance.SetMerge(&merge_RooEllipse);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooEllipse*)
   {
      return GenerateInitInstanceLocal((::RooEllipse*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooEllipse*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooErrorVar(void *p = nullptr);
   static void *newArray_RooErrorVar(Long_t size, void *p);
   static void delete_RooErrorVar(void *p);
   static void deleteArray_RooErrorVar(void *p);
   static void destruct_RooErrorVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooErrorVar*)
   {
      ::RooErrorVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooErrorVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooErrorVar", ::RooErrorVar::Class_Version(), "RooErrorVar.h", 28,
                  typeid(::RooErrorVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooErrorVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooErrorVar) );
      instance.SetNew(&new_RooErrorVar);
      instance.SetNewArray(&newArray_RooErrorVar);
      instance.SetDelete(&delete_RooErrorVar);
      instance.SetDeleteArray(&deleteArray_RooErrorVar);
      instance.SetDestructor(&destruct_RooErrorVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooErrorVar*)
   {
      return GenerateInitInstanceLocal((::RooErrorVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooErrorVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExpensiveObjectCache(void *p = nullptr);
   static void *newArray_RooExpensiveObjectCache(Long_t size, void *p);
   static void delete_RooExpensiveObjectCache(void *p);
   static void deleteArray_RooExpensiveObjectCache(void *p);
   static void destruct_RooExpensiveObjectCache(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExpensiveObjectCache*)
   {
      ::RooExpensiveObjectCache *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExpensiveObjectCache >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooExpensiveObjectCache", ::RooExpensiveObjectCache::Class_Version(), "RooExpensiveObjectCache.h", 24,
                  typeid(::RooExpensiveObjectCache), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExpensiveObjectCache::Dictionary, isa_proxy, 4,
                  sizeof(::RooExpensiveObjectCache) );
      instance.SetNew(&new_RooExpensiveObjectCache);
      instance.SetNewArray(&newArray_RooExpensiveObjectCache);
      instance.SetDelete(&delete_RooExpensiveObjectCache);
      instance.SetDeleteArray(&deleteArray_RooExpensiveObjectCache);
      instance.SetDestructor(&destruct_RooExpensiveObjectCache);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExpensiveObjectCache*)
   {
      return GenerateInitInstanceLocal((::RooExpensiveObjectCache*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExpensiveObjectCachecLcLExpensiveObject(void *p = nullptr);
   static void *newArray_RooExpensiveObjectCachecLcLExpensiveObject(Long_t size, void *p);
   static void delete_RooExpensiveObjectCachecLcLExpensiveObject(void *p);
   static void deleteArray_RooExpensiveObjectCachecLcLExpensiveObject(void *p);
   static void destruct_RooExpensiveObjectCachecLcLExpensiveObject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExpensiveObjectCache::ExpensiveObject*)
   {
      ::RooExpensiveObjectCache::ExpensiveObject *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExpensiveObjectCache::ExpensiveObject >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooExpensiveObjectCache::ExpensiveObject", ::RooExpensiveObjectCache::ExpensiveObject::Class_Version(), "RooExpensiveObjectCache.h", 48,
                  typeid(::RooExpensiveObjectCache::ExpensiveObject), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExpensiveObjectCache::ExpensiveObject::Dictionary, isa_proxy, 4,
                  sizeof(::RooExpensiveObjectCache::ExpensiveObject) );
      instance.SetNew(&new_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetNewArray(&newArray_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDelete(&delete_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDeleteArray(&deleteArray_RooExpensiveObjectCachecLcLExpensiveObject);
      instance.SetDestructor(&destruct_RooExpensiveObjectCachecLcLExpensiveObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExpensiveObjectCache::ExpensiveObject*)
   {
      return GenerateInitInstanceLocal((::RooExpensiveObjectCache::ExpensiveObject*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendedBinding(void *p = nullptr);
   static void *newArray_RooExtendedBinding(Long_t size, void *p);
   static void delete_RooExtendedBinding(void *p);
   static void deleteArray_RooExtendedBinding(void *p);
   static void destruct_RooExtendedBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendedBinding*)
   {
      ::RooExtendedBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendedBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendedBinding", ::RooExtendedBinding::Class_Version(), "RooExtendedBinding.h", 16,
                  typeid(::RooExtendedBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendedBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendedBinding) );
      instance.SetNew(&new_RooExtendedBinding);
      instance.SetNewArray(&newArray_RooExtendedBinding);
      instance.SetDelete(&delete_RooExtendedBinding);
      instance.SetDeleteArray(&deleteArray_RooExtendedBinding);
      instance.SetDestructor(&destruct_RooExtendedBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendedBinding*)
   {
      return GenerateInitInstanceLocal((::RooExtendedBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendedBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendedTerm(void *p = nullptr);
   static void *newArray_RooExtendedTerm(Long_t size, void *p);
   static void delete_RooExtendedTerm(void *p);
   static void deleteArray_RooExtendedTerm(void *p);
   static void destruct_RooExtendedTerm(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendedTerm*)
   {
      ::RooExtendedTerm *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendedTerm >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendedTerm", ::RooExtendedTerm::Class_Version(), "RooExtendedTerm.h", 22,
                  typeid(::RooExtendedTerm), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendedTerm::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendedTerm) );
      instance.SetNew(&new_RooExtendedTerm);
      instance.SetNewArray(&newArray_RooExtendedTerm);
      instance.SetDelete(&delete_RooExtendedTerm);
      instance.SetDeleteArray(&deleteArray_RooExtendedTerm);
      instance.SetDestructor(&destruct_RooExtendedTerm);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendedTerm*)
   {
      return GenerateInitInstanceLocal((::RooExtendedTerm*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendedTerm*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooExtendPdf(void *p = nullptr);
   static void *newArray_RooExtendPdf(Long_t size, void *p);
   static void delete_RooExtendPdf(void *p);
   static void deleteArray_RooExtendPdf(void *p);
   static void destruct_RooExtendPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooExtendPdf*)
   {
      ::RooExtendPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooExtendPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooExtendPdf", ::RooExtendPdf::Class_Version(), "RooExtendPdf.h", 22,
                  typeid(::RooExtendPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooExtendPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooExtendPdf) );
      instance.SetNew(&new_RooExtendPdf);
      instance.SetNewArray(&newArray_RooExtendPdf);
      instance.SetDelete(&delete_RooExtendPdf);
      instance.SetDeleteArray(&deleteArray_RooExtendPdf);
      instance.SetDestructor(&destruct_RooExtendPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooExtendPdf*)
   {
      return GenerateInitInstanceLocal((::RooExtendPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooExtendPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFFTConvPdf(void *p = nullptr);
   static void *newArray_RooFFTConvPdf(Long_t size, void *p);
   static void delete_RooFFTConvPdf(void *p);
   static void deleteArray_RooFFTConvPdf(void *p);
   static void destruct_RooFFTConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFFTConvPdf*)
   {
      ::RooFFTConvPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFFTConvPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFFTConvPdf", ::RooFFTConvPdf::Class_Version(), "RooFFTConvPdf.h", 25,
                  typeid(::RooFFTConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFFTConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooFFTConvPdf) );
      instance.SetNew(&new_RooFFTConvPdf);
      instance.SetNewArray(&newArray_RooFFTConvPdf);
      instance.SetDelete(&delete_RooFFTConvPdf);
      instance.SetDeleteArray(&deleteArray_RooFFTConvPdf);
      instance.SetDestructor(&destruct_RooFFTConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFFTConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooFFTConvPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFFTConvPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFirstMoment(void *p = nullptr);
   static void *newArray_RooFirstMoment(Long_t size, void *p);
   static void delete_RooFirstMoment(void *p);
   static void deleteArray_RooFirstMoment(void *p);
   static void destruct_RooFirstMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFirstMoment*)
   {
      ::RooFirstMoment *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFirstMoment >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFirstMoment", ::RooFirstMoment::Class_Version(), "RooFirstMoment.h", 27,
                  typeid(::RooFirstMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFirstMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooFirstMoment) );
      instance.SetNew(&new_RooFirstMoment);
      instance.SetNewArray(&newArray_RooFirstMoment);
      instance.SetDelete(&delete_RooFirstMoment);
      instance.SetDeleteArray(&deleteArray_RooFirstMoment);
      instance.SetDestructor(&destruct_RooFirstMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFirstMoment*)
   {
      return GenerateInitInstanceLocal((::RooFirstMoment*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFirstMoment*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFitResult(void *p = nullptr);
   static void *newArray_RooFitResult(Long_t size, void *p);
   static void delete_RooFitResult(void *p);
   static void deleteArray_RooFitResult(void *p);
   static void destruct_RooFitResult(void *p);
   static void streamer_RooFitResult(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFitResult*)
   {
      ::RooFitResult *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFitResult >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFitResult", ::RooFitResult::Class_Version(), "RooFitResult.h", 40,
                  typeid(::RooFitResult), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFitResult::Dictionary, isa_proxy, 17,
                  sizeof(::RooFitResult) );
      instance.SetNew(&new_RooFitResult);
      instance.SetNewArray(&newArray_RooFitResult);
      instance.SetDelete(&delete_RooFitResult);
      instance.SetDeleteArray(&deleteArray_RooFitResult);
      instance.SetDestructor(&destruct_RooFitResult);
      instance.SetStreamerFunc(&streamer_RooFitResult);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFitResult*)
   {
      return GenerateInitInstanceLocal((::RooFitResult*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFitResult*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFoamGenerator(void *p = nullptr);
   static void *newArray_RooFoamGenerator(Long_t size, void *p);
   static void delete_RooFoamGenerator(void *p);
   static void deleteArray_RooFoamGenerator(void *p);
   static void destruct_RooFoamGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFoamGenerator*)
   {
      ::RooFoamGenerator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFoamGenerator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFoamGenerator", ::RooFoamGenerator::Class_Version(), "RooFoamGenerator.h", 31,
                  typeid(::RooFoamGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFoamGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooFoamGenerator) );
      instance.SetNew(&new_RooFoamGenerator);
      instance.SetNewArray(&newArray_RooFoamGenerator);
      instance.SetDelete(&delete_RooFoamGenerator);
      instance.SetDeleteArray(&deleteArray_RooFoamGenerator);
      instance.SetDestructor(&destruct_RooFoamGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFoamGenerator*)
   {
      return GenerateInitInstanceLocal((::RooFoamGenerator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFoamGenerator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooFracRemainder(void *p = nullptr);
   static void *newArray_RooFracRemainder(Long_t size, void *p);
   static void delete_RooFracRemainder(void *p);
   static void deleteArray_RooFracRemainder(void *p);
   static void destruct_RooFracRemainder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFracRemainder*)
   {
      ::RooFracRemainder *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFracRemainder >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFracRemainder", ::RooFracRemainder::Class_Version(), "RooFracRemainder.h", 25,
                  typeid(::RooFracRemainder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFracRemainder::Dictionary, isa_proxy, 4,
                  sizeof(::RooFracRemainder) );
      instance.SetNew(&new_RooFracRemainder);
      instance.SetNewArray(&newArray_RooFracRemainder);
      instance.SetDelete(&delete_RooFracRemainder);
      instance.SetDeleteArray(&deleteArray_RooFracRemainder);
      instance.SetDestructor(&destruct_RooFracRemainder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFracRemainder*)
   {
      return GenerateInitInstanceLocal((::RooFracRemainder*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFracRemainder*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooFunctor(void *p);
   static void deleteArray_RooFunctor(void *p);
   static void destruct_RooFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFunctor*)
   {
      ::RooFunctor *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFunctor >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFunctor", ::RooFunctor::Class_Version(), "RooFunctor.h", 25,
                  typeid(::RooFunctor), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFunctor::Dictionary, isa_proxy, 4,
                  sizeof(::RooFunctor) );
      instance.SetDelete(&delete_RooFunctor);
      instance.SetDeleteArray(&deleteArray_RooFunctor);
      instance.SetDestructor(&destruct_RooFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFunctor*)
   {
      return GenerateInitInstanceLocal((::RooFunctor*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFunctor*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooGenContext(void *p);
   static void deleteArray_RooGenContext(void *p);
   static void destruct_RooGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenContext*)
   {
      ::RooGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenContext", ::RooGenContext::Class_Version(), "RooGenContext.h", 30,
                  typeid(::RooGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenContext) );
      instance.SetDelete(&delete_RooGenContext);
      instance.SetDeleteArray(&deleteArray_RooGenContext);
      instance.SetDestructor(&destruct_RooGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenContext*)
   {
      return GenerateInitInstanceLocal((::RooGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenericPdf(void *p = nullptr);
   static void *newArray_RooGenericPdf(Long_t size, void *p);
   static void delete_RooGenericPdf(void *p);
   static void deleteArray_RooGenericPdf(void *p);
   static void destruct_RooGenericPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenericPdf*)
   {
      ::RooGenericPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenericPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenericPdf", ::RooGenericPdf::Class_Version(), "RooGenericPdf.h", 25,
                  typeid(::RooGenericPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenericPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenericPdf) );
      instance.SetNew(&new_RooGenericPdf);
      instance.SetNewArray(&newArray_RooGenericPdf);
      instance.SetDelete(&delete_RooGenericPdf);
      instance.SetDeleteArray(&deleteArray_RooGenericPdf);
      instance.SetDestructor(&destruct_RooGenericPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenericPdf*)
   {
      return GenerateInitInstanceLocal((::RooGenericPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenericPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenFitStudy(void *p = nullptr);
   static void *newArray_RooGenFitStudy(Long_t size, void *p);
   static void delete_RooGenFitStudy(void *p);
   static void deleteArray_RooGenFitStudy(void *p);
   static void destruct_RooGenFitStudy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenFitStudy*)
   {
      ::RooGenFitStudy *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenFitStudy >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenFitStudy", ::RooGenFitStudy::Class_Version(), "RooGenFitStudy.h", 35,
                  typeid(::RooGenFitStudy), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenFitStudy::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenFitStudy) );
      instance.SetNew(&new_RooGenFitStudy);
      instance.SetNewArray(&newArray_RooGenFitStudy);
      instance.SetDelete(&delete_RooGenFitStudy);
      instance.SetDeleteArray(&deleteArray_RooGenFitStudy);
      instance.SetDestructor(&destruct_RooGenFitStudy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenFitStudy*)
   {
      return GenerateInitInstanceLocal((::RooGenFitStudy*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenFitStudy*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooGenFunction(void *p);
   static void deleteArray_RooGenFunction(void *p);
   static void destruct_RooGenFunction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenFunction*)
   {
      ::RooGenFunction *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenFunction >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenFunction", ::RooGenFunction::Class_Version(), "RooGenFunction.h", 22,
                  typeid(::RooGenFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenFunction::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenFunction) );
      instance.SetDelete(&delete_RooGenFunction);
      instance.SetDeleteArray(&deleteArray_RooGenFunction);
      instance.SetDestructor(&destruct_RooGenFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenFunction*)
   {
      return GenerateInitInstanceLocal((::RooGenFunction*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenFunction*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGenProdProj(void *p = nullptr);
   static void *newArray_RooGenProdProj(Long_t size, void *p);
   static void delete_RooGenProdProj(void *p);
   static void deleteArray_RooGenProdProj(void *p);
   static void destruct_RooGenProdProj(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGenProdProj*)
   {
      ::RooGenProdProj *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGenProdProj >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGenProdProj", ::RooGenProdProj::Class_Version(), "RooGenProdProj.h", 26,
                  typeid(::RooGenProdProj), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGenProdProj::Dictionary, isa_proxy, 4,
                  sizeof(::RooGenProdProj) );
      instance.SetNew(&new_RooGenProdProj);
      instance.SetNewArray(&newArray_RooGenProdProj);
      instance.SetDelete(&delete_RooGenProdProj);
      instance.SetDeleteArray(&deleteArray_RooGenProdProj);
      instance.SetDestructor(&destruct_RooGenProdProj);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGenProdProj*)
   {
      return GenerateInitInstanceLocal((::RooGenProdProj*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGenProdProj*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooGrid(void *p = nullptr);
   static void *newArray_RooGrid(Long_t size, void *p);
   static void delete_RooGrid(void *p);
   static void deleteArray_RooGrid(void *p);
   static void destruct_RooGrid(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooGrid*)
   {
      ::RooGrid *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooGrid >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooGrid", ::RooGrid::Class_Version(), "RooGrid.h", 24,
                  typeid(::RooGrid), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooGrid::Dictionary, isa_proxy, 4,
                  sizeof(::RooGrid) );
      instance.SetNew(&new_RooGrid);
      instance.SetNewArray(&newArray_RooGrid);
      instance.SetDelete(&delete_RooGrid);
      instance.SetDeleteArray(&deleteArray_RooGrid);
      instance.SetDestructor(&destruct_RooGrid);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooGrid*)
   {
      return GenerateInitInstanceLocal((::RooGrid*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooGrid*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooHistError(void *p);
   static void deleteArray_RooHistError(void *p);
   static void destruct_RooHistError(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHistError*)
   {
      ::RooHistError *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHistError >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooHistError", ::RooHistError::Class_Version(), "RooHistError.h", 25,
                  typeid(::RooHistError), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHistError::Dictionary, isa_proxy, 4,
                  sizeof(::RooHistError) );
      instance.SetDelete(&delete_RooHistError);
      instance.SetDeleteArray(&deleteArray_RooHistError);
      instance.SetDestructor(&destruct_RooHistError);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHistError*)
   {
      return GenerateInitInstanceLocal((::RooHistError*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHistError*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHist(void *p = nullptr);
   static void *newArray_RooHist(Long_t size, void *p);
   static void delete_RooHist(void *p);
   static void deleteArray_RooHist(void *p);
   static void destruct_RooHist(void *p);
   static Long64_t merge_RooHist(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHist*)
   {
      ::RooHist *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHist >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooHist", ::RooHist::Class_Version(), "RooHist.h", 27,
                  typeid(::RooHist), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHist::Dictionary, isa_proxy, 4,
                  sizeof(::RooHist) );
      instance.SetNew(&new_RooHist);
      instance.SetNewArray(&newArray_RooHist);
      instance.SetDelete(&delete_RooHist);
      instance.SetDeleteArray(&deleteArray_RooHist);
      instance.SetDestructor(&destruct_RooHist);
      instance.SetMerge(&merge_RooHist);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHist*)
   {
      return GenerateInitInstanceLocal((::RooHist*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHist*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooImproperIntegrator1D(void *p = nullptr);
   static void *newArray_RooImproperIntegrator1D(Long_t size, void *p);
   static void delete_RooImproperIntegrator1D(void *p);
   static void deleteArray_RooImproperIntegrator1D(void *p);
   static void destruct_RooImproperIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooImproperIntegrator1D*)
   {
      ::RooImproperIntegrator1D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooImproperIntegrator1D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooImproperIntegrator1D", ::RooImproperIntegrator1D::Class_Version(), "RooImproperIntegrator1D.h", 25,
                  typeid(::RooImproperIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooImproperIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooImproperIntegrator1D) );
      instance.SetNew(&new_RooImproperIntegrator1D);
      instance.SetNewArray(&newArray_RooImproperIntegrator1D);
      instance.SetDelete(&delete_RooImproperIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooImproperIntegrator1D);
      instance.SetDestructor(&destruct_RooImproperIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooImproperIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooImproperIntegrator1D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooIntegrator1D(void *p = nullptr);
   static void *newArray_RooIntegrator1D(Long_t size, void *p);
   static void delete_RooIntegrator1D(void *p);
   static void deleteArray_RooIntegrator1D(void *p);
   static void destruct_RooIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegrator1D*)
   {
      ::RooIntegrator1D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegrator1D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegrator1D", ::RooIntegrator1D::Class_Version(), "RooIntegrator1D.h", 22,
                  typeid(::RooIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegrator1D) );
      instance.SetNew(&new_RooIntegrator1D);
      instance.SetNewArray(&newArray_RooIntegrator1D);
      instance.SetDelete(&delete_RooIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooIntegrator1D);
      instance.SetDestructor(&destruct_RooIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooIntegrator1D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegrator1D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooIntegrator2D(void *p = nullptr);
   static void *newArray_RooIntegrator2D(Long_t size, void *p);
   static void delete_RooIntegrator2D(void *p);
   static void deleteArray_RooIntegrator2D(void *p);
   static void destruct_RooIntegrator2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegrator2D*)
   {
      ::RooIntegrator2D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegrator2D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegrator2D", ::RooIntegrator2D::Class_Version(), "RooIntegrator2D.h", 22,
                  typeid(::RooIntegrator2D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegrator2D::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegrator2D) );
      instance.SetNew(&new_RooIntegrator2D);
      instance.SetNewArray(&newArray_RooIntegrator2D);
      instance.SetDelete(&delete_RooIntegrator2D);
      instance.SetDeleteArray(&deleteArray_RooIntegrator2D);
      instance.SetDestructor(&destruct_RooIntegrator2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegrator2D*)
   {
      return GenerateInitInstanceLocal((::RooIntegrator2D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegrator2D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooIntegratorBinding(void *p);
   static void deleteArray_RooIntegratorBinding(void *p);
   static void destruct_RooIntegratorBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooIntegratorBinding*)
   {
      ::RooIntegratorBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooIntegratorBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooIntegratorBinding", ::RooIntegratorBinding::Class_Version(), "RooIntegratorBinding.h", 22,
                  typeid(::RooIntegratorBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooIntegratorBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooIntegratorBinding) );
      instance.SetDelete(&delete_RooIntegratorBinding);
      instance.SetDeleteArray(&deleteArray_RooIntegratorBinding);
      instance.SetDestructor(&destruct_RooIntegratorBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooIntegratorBinding*)
   {
      return GenerateInitInstanceLocal((::RooIntegratorBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooIntegratorBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooInt(void *p = nullptr);
   static void *newArray_RooInt(Long_t size, void *p);
   static void delete_RooInt(void *p);
   static void deleteArray_RooInt(void *p);
   static void destruct_RooInt(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooInt*)
   {
      ::RooInt *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooInt >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooInt", ::RooInt::Class_Version(), "RooInt.h", 22,
                  typeid(::RooInt), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooInt::Dictionary, isa_proxy, 4,
                  sizeof(::RooInt) );
      instance.SetNew(&new_RooInt);
      instance.SetNewArray(&newArray_RooInt);
      instance.SetDelete(&delete_RooInt);
      instance.SetDeleteArray(&deleteArray_RooInt);
      instance.SetDestructor(&destruct_RooInt);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooInt*)
   {
      return GenerateInitInstanceLocal((::RooInt*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooInt*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooInvTransform(void *p);
   static void deleteArray_RooInvTransform(void *p);
   static void destruct_RooInvTransform(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooInvTransform*)
   {
      ::RooInvTransform *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooInvTransform >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooInvTransform", ::RooInvTransform::Class_Version(), "RooInvTransform.h", 21,
                  typeid(::RooInvTransform), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooInvTransform::Dictionary, isa_proxy, 4,
                  sizeof(::RooInvTransform) );
      instance.SetDelete(&delete_RooInvTransform);
      instance.SetDeleteArray(&deleteArray_RooInvTransform);
      instance.SetDestructor(&destruct_RooInvTransform);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooInvTransform*)
   {
      return GenerateInitInstanceLocal((::RooInvTransform*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooInvTransform*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinearCombination(void *p = nullptr);
   static void *newArray_RooLinearCombination(Long_t size, void *p);
   static void delete_RooLinearCombination(void *p);
   static void deleteArray_RooLinearCombination(void *p);
   static void destruct_RooLinearCombination(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinearCombination*)
   {
      ::RooLinearCombination *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinearCombination >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinearCombination", ::RooLinearCombination::Class_Version(), "RooLinearCombination.h", 30,
                  typeid(::RooLinearCombination), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinearCombination::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinearCombination) );
      instance.SetNew(&new_RooLinearCombination);
      instance.SetNewArray(&newArray_RooLinearCombination);
      instance.SetDelete(&delete_RooLinearCombination);
      instance.SetDeleteArray(&deleteArray_RooLinearCombination);
      instance.SetDestructor(&destruct_RooLinearCombination);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinearCombination*)
   {
      return GenerateInitInstanceLocal((::RooLinearCombination*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinearCombination*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinTransBinning(void *p = nullptr);
   static void *newArray_RooLinTransBinning(Long_t size, void *p);
   static void delete_RooLinTransBinning(void *p);
   static void deleteArray_RooLinTransBinning(void *p);
   static void destruct_RooLinTransBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinTransBinning*)
   {
      ::RooLinTransBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinTransBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinTransBinning", ::RooLinTransBinning::Class_Version(), "RooLinTransBinning.h", 22,
                  typeid(::RooLinTransBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinTransBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinTransBinning) );
      instance.SetNew(&new_RooLinTransBinning);
      instance.SetNewArray(&newArray_RooLinTransBinning);
      instance.SetDelete(&delete_RooLinTransBinning);
      instance.SetDeleteArray(&deleteArray_RooLinTransBinning);
      instance.SetDestructor(&destruct_RooLinTransBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinTransBinning*)
   {
      return GenerateInitInstanceLocal((::RooLinTransBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinTransBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooLinearVar(void *p = nullptr);
   static void *newArray_RooLinearVar(Long_t size, void *p);
   static void delete_RooLinearVar(void *p);
   static void deleteArray_RooLinearVar(void *p);
   static void destruct_RooLinearVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooLinearVar*)
   {
      ::RooLinearVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooLinearVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooLinearVar", ::RooLinearVar::Class_Version(), "RooLinearVar.h", 30,
                  typeid(::RooLinearVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooLinearVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooLinearVar) );
      instance.SetNew(&new_RooLinearVar);
      instance.SetNewArray(&newArray_RooLinearVar);
      instance.SetDelete(&delete_RooLinearVar);
      instance.SetDeleteArray(&deleteArray_RooLinearVar);
      instance.SetDestructor(&destruct_RooLinearVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooLinearVar*)
   {
      return GenerateInitInstanceLocal((::RooLinearVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooLinearVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooList(void *p = nullptr);
   static void *newArray_RooList(Long_t size, void *p);
   static void delete_RooList(void *p);
   static void deleteArray_RooList(void *p);
   static void destruct_RooList(void *p);
   static Long64_t merge_RooList(void *obj, TCollection *coll,TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooList*)
   {
      ::RooList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooList", ::RooList::Class_Version(), "RooList.h", 21,
                  typeid(::RooList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooList::Dictionary, isa_proxy, 4,
                  sizeof(::RooList) );
      instance.SetNew(&new_RooList);
      instance.SetNewArray(&newArray_RooList);
      instance.SetDelete(&delete_RooList);
      instance.SetDeleteArray(&deleteArray_RooList);
      instance.SetDestructor(&destruct_RooList);
      instance.SetMerge(&merge_RooList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooList*)
   {
      return GenerateInitInstanceLocal((::RooList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMappedCategory(void *p = nullptr);
   static void *newArray_RooMappedCategory(Long_t size, void *p);
   static void delete_RooMappedCategory(void *p);
   static void deleteArray_RooMappedCategory(void *p);
   static void destruct_RooMappedCategory(void *p);

   // Schema evolution read functions
   static void read_RooMappedCategory_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__defCat = oldObj->GetId("_defCat");
#endif
      struct RooMappedCategory_Onfile {
         RooCatType* &_defCat;
         RooMappedCategory_Onfile(RooCatType* &onfile__defCat ): _defCat(onfile__defCat) {}
      };
      static Long_t offset_Onfile_RooMappedCategory__defCat = oldObj->GetClass()->GetDataMemberOffset("_defCat");
      char *onfile_add = (char*)oldObj->GetObject();
      RooMappedCategory_Onfile onfile(
         *(RooCatType**)(onfile_add+offset_Onfile_RooMappedCategory__defCat) );

      static TClassRef cls("RooMappedCategory");
      static Long_t offset__defCat = cls->GetDataMemberOffset("_defCat");
      RooAbsCategory::value_type& _defCat = *(RooAbsCategory::value_type*)(target+offset__defCat);
      RooMappedCategory* newObj = (RooMappedCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _defCat = onfile._defCat->getVal(); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMappedCategory*)
   {
      ::RooMappedCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMappedCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMappedCategory", ::RooMappedCategory::Class_Version(), "RooMappedCategory.h", 27,
                  typeid(::RooMappedCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMappedCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooMappedCategory) );
      instance.SetNew(&new_RooMappedCategory);
      instance.SetNewArray(&newArray_RooMappedCategory);
      instance.SetDelete(&delete_RooMappedCategory);
      instance.SetDeleteArray(&deleteArray_RooMappedCategory);
      instance.SetDestructor(&destruct_RooMappedCategory);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooMappedCategory";
      rule->fTarget      = "_defCat";
      rule->fSource      = "RooCatType* _defCat";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooMappedCategory_0);
      rule->fCode        = " _defCat = onfile._defCat->getVal(); ";
      rule->fVersion     = "[1]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMappedCategory*)
   {
      return GenerateInitInstanceLocal((::RooMappedCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMappedCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMappedCategorycLcLEntry(void *p = nullptr);
   static void *newArray_RooMappedCategorycLcLEntry(Long_t size, void *p);
   static void delete_RooMappedCategorycLcLEntry(void *p);
   static void deleteArray_RooMappedCategorycLcLEntry(void *p);
   static void destruct_RooMappedCategorycLcLEntry(void *p);

   // Schema evolution read functions
   static void read_RooMappedCategorycLcLEntry_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__cat = oldObj->GetId("_cat");
#endif
      struct RooMappedCategorycLcLEntry_Onfile {
         RooCatType &_cat;
         RooMappedCategorycLcLEntry_Onfile(RooCatType &onfile__cat ): _cat(onfile__cat) {}
      };
      static Long_t offset_Onfile_RooMappedCategorycLcLEntry__cat = oldObj->GetClass()->GetDataMemberOffset("_cat");
      char *onfile_add = (char*)oldObj->GetObject();
      RooMappedCategorycLcLEntry_Onfile onfile(
         *(RooCatType*)(onfile_add+offset_Onfile_RooMappedCategorycLcLEntry__cat) );

      static TClassRef cls("RooMappedCategory::Entry");
      static Long_t offset__catIdx = cls->GetDataMemberOffset("_catIdx");
      RooAbsCategory::value_type& _catIdx = *(RooAbsCategory::value_type*)(target+offset__catIdx);
      RooMappedCategory::Entry* newObj = (RooMappedCategory::Entry*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _catIdx = onfile._cat.getVal(); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMappedCategory::Entry*)
   {
      ::RooMappedCategory::Entry *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMappedCategory::Entry >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMappedCategory::Entry", ::RooMappedCategory::Entry::Class_Version(), "RooMappedCategory.h", 50,
                  typeid(::RooMappedCategory::Entry), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMappedCategory::Entry::Dictionary, isa_proxy, 4,
                  sizeof(::RooMappedCategory::Entry) );
      instance.SetNew(&new_RooMappedCategorycLcLEntry);
      instance.SetNewArray(&newArray_RooMappedCategorycLcLEntry);
      instance.SetDelete(&delete_RooMappedCategorycLcLEntry);
      instance.SetDeleteArray(&deleteArray_RooMappedCategorycLcLEntry);
      instance.SetDestructor(&destruct_RooMappedCategorycLcLEntry);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooMappedCategory::Entry";
      rule->fTarget      = "_catIdx";
      rule->fSource      = "RooCatType _cat";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooMappedCategorycLcLEntry_0);
      rule->fCode        = " _catIdx = onfile._cat.getVal(); ";
      rule->fVersion     = "[1]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMappedCategory::Entry*)
   {
      return GenerateInitInstanceLocal((::RooMappedCategory::Entry*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMCIntegrator(void *p = nullptr);
   static void *newArray_RooMCIntegrator(Long_t size, void *p);
   static void delete_RooMCIntegrator(void *p);
   static void deleteArray_RooMCIntegrator(void *p);
   static void destruct_RooMCIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMCIntegrator*)
   {
      ::RooMCIntegrator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMCIntegrator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMCIntegrator", ::RooMCIntegrator::Class_Version(), "RooMCIntegrator.h", 24,
                  typeid(::RooMCIntegrator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMCIntegrator::Dictionary, isa_proxy, 4,
                  sizeof(::RooMCIntegrator) );
      instance.SetNew(&new_RooMCIntegrator);
      instance.SetNewArray(&newArray_RooMCIntegrator);
      instance.SetDelete(&delete_RooMCIntegrator);
      instance.SetDeleteArray(&deleteArray_RooMCIntegrator);
      instance.SetDestructor(&destruct_RooMCIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMCIntegrator*)
   {
      return GenerateInitInstanceLocal((::RooMCIntegrator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMCIntegrator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMinimizerFcn_Dictionary();
   static void RooMinimizerFcn_TClassManip(TClass*);
   static void delete_RooMinimizerFcn(void *p);
   static void deleteArray_RooMinimizerFcn(void *p);
   static void destruct_RooMinimizerFcn(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinimizerFcn*)
   {
      ::RooMinimizerFcn *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMinimizerFcn));
      static ::ROOT::TGenericClassInfo 
         instance("RooMinimizerFcn", "RooMinimizerFcn.h", 36,
                  typeid(::RooMinimizerFcn), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMinimizerFcn_Dictionary, isa_proxy, 4,
                  sizeof(::RooMinimizerFcn) );
      instance.SetDelete(&delete_RooMinimizerFcn);
      instance.SetDeleteArray(&deleteArray_RooMinimizerFcn);
      instance.SetDestructor(&destruct_RooMinimizerFcn);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinimizerFcn*)
   {
      return GenerateInitInstanceLocal((::RooMinimizerFcn*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinimizerFcn*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMinimizerFcn_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMinimizerFcn*)nullptr)->GetClass();
      RooMinimizerFcn_TClassManip(theClass);
   return theClass;
   }

   static void RooMinimizerFcn_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooSentinel_Dictionary();
   static void RooSentinel_TClassManip(TClass*);
   static void delete_RooSentinel(void *p);
   static void deleteArray_RooSentinel(void *p);
   static void destruct_RooSentinel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSentinel*)
   {
      ::RooSentinel *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooSentinel));
      static ::ROOT::TGenericClassInfo 
         instance("RooSentinel", "RooSentinel.h", 21,
                  typeid(::RooSentinel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooSentinel_Dictionary, isa_proxy, 4,
                  sizeof(::RooSentinel) );
      instance.SetDelete(&delete_RooSentinel);
      instance.SetDeleteArray(&deleteArray_RooSentinel);
      instance.SetDestructor(&destruct_RooSentinel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSentinel*)
   {
      return GenerateInitInstanceLocal((::RooSentinel*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSentinel*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooSentinel_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooSentinel*)nullptr)->GetClass();
      RooSentinel_TClassManip(theClass);
   return theClass;
   }

   static void RooSentinel_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMinimizer(void *p);
   static void deleteArray_RooMinimizer(void *p);
   static void destruct_RooMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinimizer*)
   {
      ::RooMinimizer *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMinimizer >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMinimizer", ::RooMinimizer::Class_Version(), "RooMinimizer.h", 51,
                  typeid(::RooMinimizer), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMinimizer::Dictionary, isa_proxy, 4,
                  sizeof(::RooMinimizer) );
      instance.SetDelete(&delete_RooMinimizer);
      instance.SetDeleteArray(&deleteArray_RooMinimizer);
      instance.SetDestructor(&destruct_RooMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinimizer*)
   {
      return GenerateInitInstanceLocal((::RooMinimizer*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinimizer*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMoment(void *p = nullptr);
   static void *newArray_RooMoment(Long_t size, void *p);
   static void delete_RooMoment(void *p);
   static void deleteArray_RooMoment(void *p);
   static void destruct_RooMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMoment*)
   {
      ::RooMoment *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMoment >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMoment", ::RooMoment::Class_Version(), "RooMoment.h", 27,
                  typeid(::RooMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooMoment) );
      instance.SetNew(&new_RooMoment);
      instance.SetNewArray(&newArray_RooMoment);
      instance.SetDelete(&delete_RooMoment);
      instance.SetDeleteArray(&deleteArray_RooMoment);
      instance.SetDestructor(&destruct_RooMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMoment*)
   {
      return GenerateInitInstanceLocal((::RooMoment*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMoment*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMPSentinel(void *p = nullptr);
   static void *newArray_RooMPSentinel(Long_t size, void *p);
   static void delete_RooMPSentinel(void *p);
   static void deleteArray_RooMPSentinel(void *p);
   static void destruct_RooMPSentinel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMPSentinel*)
   {
      ::RooMPSentinel *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMPSentinel >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMPSentinel", ::RooMPSentinel::Class_Version(), "RooMPSentinel.h", 23,
                  typeid(::RooMPSentinel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMPSentinel::Dictionary, isa_proxy, 4,
                  sizeof(::RooMPSentinel) );
      instance.SetNew(&new_RooMPSentinel);
      instance.SetNewArray(&newArray_RooMPSentinel);
      instance.SetDelete(&delete_RooMPSentinel);
      instance.SetDeleteArray(&deleteArray_RooMPSentinel);
      instance.SetDestructor(&destruct_RooMPSentinel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMPSentinel*)
   {
      return GenerateInitInstanceLocal((::RooMPSentinel*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMPSentinel*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMultiCategory(void *p = nullptr);
   static void *newArray_RooMultiCategory(Long_t size, void *p);
   static void delete_RooMultiCategory(void *p);
   static void deleteArray_RooMultiCategory(void *p);
   static void destruct_RooMultiCategory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiCategory*)
   {
      ::RooMultiCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiCategory", ::RooMultiCategory::Class_Version(), "RooMultiCategory.h", 28,
                  typeid(::RooMultiCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiCategory) );
      instance.SetNew(&new_RooMultiCategory);
      instance.SetNewArray(&newArray_RooMultiCategory);
      instance.SetDelete(&delete_RooMultiCategory);
      instance.SetDeleteArray(&deleteArray_RooMultiCategory);
      instance.SetDestructor(&destruct_RooMultiCategory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiCategory*)
   {
      return GenerateInitInstanceLocal((::RooMultiCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMultiGenFunction(void *p);
   static void deleteArray_RooMultiGenFunction(void *p);
   static void destruct_RooMultiGenFunction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiGenFunction*)
   {
      ::RooMultiGenFunction *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiGenFunction >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiGenFunction", ::RooMultiGenFunction::Class_Version(), "RooMultiGenFunction.h", 27,
                  typeid(::RooMultiGenFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiGenFunction::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiGenFunction) );
      instance.SetDelete(&delete_RooMultiGenFunction);
      instance.SetDeleteArray(&deleteArray_RooMultiGenFunction);
      instance.SetDestructor(&destruct_RooMultiGenFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiGenFunction*)
   {
      return GenerateInitInstanceLocal((::RooMultiGenFunction*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiGenFunction*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooMultiVarGaussian(void *p = nullptr);
   static void *newArray_RooMultiVarGaussian(Long_t size, void *p);
   static void delete_RooMultiVarGaussian(void *p);
   static void deleteArray_RooMultiVarGaussian(void *p);
   static void destruct_RooMultiVarGaussian(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian*)
   {
      ::RooMultiVarGaussian *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMultiVarGaussian >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian", ::RooMultiVarGaussian::Class_Version(), "RooMultiVarGaussian.h", 31,
                  typeid(::RooMultiVarGaussian), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMultiVarGaussian::Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian) );
      instance.SetNew(&new_RooMultiVarGaussian);
      instance.SetNewArray(&newArray_RooMultiVarGaussian);
      instance.SetDelete(&delete_RooMultiVarGaussian);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussian);
      instance.SetDestructor(&destruct_RooMultiVarGaussian);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMultiVarGaussiancLcLAnaIntData_Dictionary();
   static void RooMultiVarGaussiancLcLAnaIntData_TClassManip(TClass*);
   static void *new_RooMultiVarGaussiancLcLAnaIntData(void *p = nullptr);
   static void *newArray_RooMultiVarGaussiancLcLAnaIntData(Long_t size, void *p);
   static void delete_RooMultiVarGaussiancLcLAnaIntData(void *p);
   static void deleteArray_RooMultiVarGaussiancLcLAnaIntData(void *p);
   static void destruct_RooMultiVarGaussiancLcLAnaIntData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian::AnaIntData*)
   {
      ::RooMultiVarGaussian::AnaIntData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMultiVarGaussian::AnaIntData));
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian::AnaIntData", "RooMultiVarGaussian.h", 54,
                  typeid(::RooMultiVarGaussian::AnaIntData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMultiVarGaussiancLcLAnaIntData_Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian::AnaIntData) );
      instance.SetNew(&new_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetNewArray(&newArray_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDelete(&delete_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussiancLcLAnaIntData);
      instance.SetDestructor(&destruct_RooMultiVarGaussiancLcLAnaIntData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian::AnaIntData*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian::AnaIntData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian::AnaIntData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMultiVarGaussiancLcLAnaIntData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian::AnaIntData*)nullptr)->GetClass();
      RooMultiVarGaussiancLcLAnaIntData_TClassManip(theClass);
   return theClass;
   }

   static void RooMultiVarGaussiancLcLAnaIntData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *RooMultiVarGaussiancLcLGenData_Dictionary();
   static void RooMultiVarGaussiancLcLGenData_TClassManip(TClass*);
   static void *new_RooMultiVarGaussiancLcLGenData(void *p = nullptr);
   static void *newArray_RooMultiVarGaussiancLcLGenData(Long_t size, void *p);
   static void delete_RooMultiVarGaussiancLcLGenData(void *p);
   static void deleteArray_RooMultiVarGaussiancLcLGenData(void *p);
   static void destruct_RooMultiVarGaussiancLcLGenData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMultiVarGaussian::GenData*)
   {
      ::RooMultiVarGaussian::GenData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::RooMultiVarGaussian::GenData));
      static ::ROOT::TGenericClassInfo 
         instance("RooMultiVarGaussian::GenData", "RooMultiVarGaussian.h", 62,
                  typeid(::RooMultiVarGaussian::GenData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &RooMultiVarGaussiancLcLGenData_Dictionary, isa_proxy, 4,
                  sizeof(::RooMultiVarGaussian::GenData) );
      instance.SetNew(&new_RooMultiVarGaussiancLcLGenData);
      instance.SetNewArray(&newArray_RooMultiVarGaussiancLcLGenData);
      instance.SetDelete(&delete_RooMultiVarGaussiancLcLGenData);
      instance.SetDeleteArray(&deleteArray_RooMultiVarGaussiancLcLGenData);
      instance.SetDestructor(&destruct_RooMultiVarGaussiancLcLGenData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMultiVarGaussian::GenData*)
   {
      return GenerateInitInstanceLocal((::RooMultiVarGaussian::GenData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMultiVarGaussian::GenData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *RooMultiVarGaussiancLcLGenData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian::GenData*)nullptr)->GetClass();
      RooMultiVarGaussiancLcLGenData_TClassManip(theClass);
   return theClass;
   }

   static void RooMultiVarGaussiancLcLGenData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNLLVar(void *p = nullptr);
   static void *newArray_RooNLLVar(Long_t size, void *p);
   static void delete_RooNLLVar(void *p);
   static void deleteArray_RooNLLVar(void *p);
   static void destruct_RooNLLVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNLLVar*)
   {
      ::RooNLLVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNLLVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNLLVar", ::RooNLLVar::Class_Version(), "RooNLLVar.h", 30,
                  typeid(::RooNLLVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNLLVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooNLLVar) );
      instance.SetNew(&new_RooNLLVar);
      instance.SetNewArray(&newArray_RooNLLVar);
      instance.SetDelete(&delete_RooNLLVar);
      instance.SetDeleteArray(&deleteArray_RooNLLVar);
      instance.SetDestructor(&destruct_RooNLLVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNLLVar*)
   {
      return GenerateInitInstanceLocal((::RooNLLVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNLLVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumRunningInt(void *p);
   static void deleteArray_RooNumRunningInt(void *p);
   static void destruct_RooNumRunningInt(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumRunningInt*)
   {
      ::RooNumRunningInt *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumRunningInt >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumRunningInt", ::RooNumRunningInt::Class_Version(), "RooNumRunningInt.h", 20,
                  typeid(::RooNumRunningInt), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumRunningInt::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumRunningInt) );
      instance.SetDelete(&delete_RooNumRunningInt);
      instance.SetDeleteArray(&deleteArray_RooNumRunningInt);
      instance.SetDestructor(&destruct_RooNumRunningInt);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumRunningInt*)
   {
      return GenerateInitInstanceLocal((::RooNumRunningInt*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumRunningInt*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumCdf(void *p);
   static void deleteArray_RooNumCdf(void *p);
   static void destruct_RooNumCdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumCdf*)
   {
      ::RooNumCdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumCdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumCdf", ::RooNumCdf::Class_Version(), "RooNumCdf.h", 17,
                  typeid(::RooNumCdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumCdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumCdf) );
      instance.SetDelete(&delete_RooNumCdf);
      instance.SetDeleteArray(&deleteArray_RooNumCdf);
      instance.SetDestructor(&destruct_RooNumCdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumCdf*)
   {
      return GenerateInitInstanceLocal((::RooNumCdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumCdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumConvolution(void *p = nullptr);
   static void *newArray_RooNumConvolution(Long_t size, void *p);
   static void delete_RooNumConvolution(void *p);
   static void deleteArray_RooNumConvolution(void *p);
   static void destruct_RooNumConvolution(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumConvolution*)
   {
      ::RooNumConvolution *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumConvolution >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumConvolution", ::RooNumConvolution::Class_Version(), "RooNumConvolution.h", 29,
                  typeid(::RooNumConvolution), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumConvolution::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumConvolution) );
      instance.SetNew(&new_RooNumConvolution);
      instance.SetNewArray(&newArray_RooNumConvolution);
      instance.SetDelete(&delete_RooNumConvolution);
      instance.SetDeleteArray(&deleteArray_RooNumConvolution);
      instance.SetDestructor(&destruct_RooNumConvolution);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumConvolution*)
   {
      return GenerateInitInstanceLocal((::RooNumConvolution*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumConvolution*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumConvPdf(void *p = nullptr);
   static void *newArray_RooNumConvPdf(Long_t size, void *p);
   static void delete_RooNumConvPdf(void *p);
   static void deleteArray_RooNumConvPdf(void *p);
   static void destruct_RooNumConvPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumConvPdf*)
   {
      ::RooNumConvPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumConvPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumConvPdf", ::RooNumConvPdf::Class_Version(), "RooNumConvPdf.h", 26,
                  typeid(::RooNumConvPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumConvPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumConvPdf) );
      instance.SetNew(&new_RooNumConvPdf);
      instance.SetNewArray(&newArray_RooNumConvPdf);
      instance.SetDelete(&delete_RooNumConvPdf);
      instance.SetDeleteArray(&deleteArray_RooNumConvPdf);
      instance.SetDestructor(&destruct_RooNumConvPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumConvPdf*)
   {
      return GenerateInitInstanceLocal((::RooNumConvPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumConvPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNumGenConfig(void *p = nullptr);
   static void *newArray_RooNumGenConfig(Long_t size, void *p);
   static void delete_RooNumGenConfig(void *p);
   static void deleteArray_RooNumGenConfig(void *p);
   static void destruct_RooNumGenConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumGenConfig*)
   {
      ::RooNumGenConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumGenConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumGenConfig", ::RooNumGenConfig::Class_Version(), "RooNumGenConfig.h", 25,
                  typeid(::RooNumGenConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumGenConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumGenConfig) );
      instance.SetNew(&new_RooNumGenConfig);
      instance.SetNewArray(&newArray_RooNumGenConfig);
      instance.SetDelete(&delete_RooNumGenConfig);
      instance.SetDeleteArray(&deleteArray_RooNumGenConfig);
      instance.SetDestructor(&destruct_RooNumGenConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumGenConfig*)
   {
      return GenerateInitInstanceLocal((::RooNumGenConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumGenConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumGenFactory(void *p);
   static void deleteArray_RooNumGenFactory(void *p);
   static void destruct_RooNumGenFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumGenFactory*)
   {
      ::RooNumGenFactory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumGenFactory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumGenFactory", ::RooNumGenFactory::Class_Version(), "RooNumGenFactory.h", 30,
                  typeid(::RooNumGenFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumGenFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumGenFactory) );
      instance.SetDelete(&delete_RooNumGenFactory);
      instance.SetDeleteArray(&deleteArray_RooNumGenFactory);
      instance.SetDestructor(&destruct_RooNumGenFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumGenFactory*)
   {
      return GenerateInitInstanceLocal((::RooNumGenFactory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumGenFactory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooNumIntFactory(void *p);
   static void deleteArray_RooNumIntFactory(void *p);
   static void destruct_RooNumIntFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNumIntFactory*)
   {
      ::RooNumIntFactory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNumIntFactory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNumIntFactory", ::RooNumIntFactory::Class_Version(), "RooNumIntFactory.h", 30,
                  typeid(::RooNumIntFactory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNumIntFactory::Dictionary, isa_proxy, 4,
                  sizeof(::RooNumIntFactory) );
      instance.SetDelete(&delete_RooNumIntFactory);
      instance.SetDeleteArray(&deleteArray_RooNumIntFactory);
      instance.SetDestructor(&destruct_RooNumIntFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNumIntFactory*)
   {
      return GenerateInitInstanceLocal((::RooNumIntFactory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNumIntFactory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooParamBinning(void *p = nullptr);
   static void *newArray_RooParamBinning(Long_t size, void *p);
   static void delete_RooParamBinning(void *p);
   static void deleteArray_RooParamBinning(void *p);
   static void destruct_RooParamBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooParamBinning*)
   {
      ::RooParamBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooParamBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooParamBinning", ::RooParamBinning::Class_Version(), "RooParamBinning.h", 25,
                  typeid(::RooParamBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooParamBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooParamBinning) );
      instance.SetNew(&new_RooParamBinning);
      instance.SetNewArray(&newArray_RooParamBinning);
      instance.SetDelete(&delete_RooParamBinning);
      instance.SetDeleteArray(&deleteArray_RooParamBinning);
      instance.SetDestructor(&destruct_RooParamBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooParamBinning*)
   {
      return GenerateInitInstanceLocal((::RooParamBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooParamBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPlot(void *p = nullptr);
   static void *newArray_RooPlot(Long_t size, void *p);
   static void delete_RooPlot(void *p);
   static void deleteArray_RooPlot(void *p);
   static void destruct_RooPlot(void *p);
   static void streamer_RooPlot(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPlot*)
   {
      ::RooPlot *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPlot >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPlot", ::RooPlot::Class_Version(), "RooPlot.h", 44,
                  typeid(::RooPlot), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPlot::Dictionary, isa_proxy, 17,
                  sizeof(::RooPlot) );
      instance.SetNew(&new_RooPlot);
      instance.SetNewArray(&newArray_RooPlot);
      instance.SetDelete(&delete_RooPlot);
      instance.SetDeleteArray(&deleteArray_RooPlot);
      instance.SetDestructor(&destruct_RooPlot);
      instance.SetStreamerFunc(&streamer_RooPlot);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPlot*)
   {
      return GenerateInitInstanceLocal((::RooPlot*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPlot*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPolyFunc(void *p = nullptr);
   static void *newArray_RooPolyFunc(Long_t size, void *p);
   static void delete_RooPolyFunc(void *p);
   static void deleteArray_RooPolyFunc(void *p);
   static void destruct_RooPolyFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPolyFunc*)
   {
      ::RooPolyFunc *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPolyFunc >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPolyFunc", ::RooPolyFunc::Class_Version(), "RooPolyFunc.h", 27,
                  typeid(::RooPolyFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPolyFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooPolyFunc) );
      instance.SetNew(&new_RooPolyFunc);
      instance.SetNewArray(&newArray_RooPolyFunc);
      instance.SetDelete(&delete_RooPolyFunc);
      instance.SetDeleteArray(&deleteArray_RooPolyFunc);
      instance.SetDestructor(&destruct_RooPolyFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPolyFunc*)
   {
      return GenerateInitInstanceLocal((::RooPolyFunc*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPolyFunc*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPolyVar(void *p = nullptr);
   static void *newArray_RooPolyVar(Long_t size, void *p);
   static void delete_RooPolyVar(void *p);
   static void deleteArray_RooPolyVar(void *p);
   static void destruct_RooPolyVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPolyVar*)
   {
      ::RooPolyVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPolyVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPolyVar", ::RooPolyVar::Class_Version(), "RooPolyVar.h", 28,
                  typeid(::RooPolyVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPolyVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooPolyVar) );
      instance.SetNew(&new_RooPolyVar);
      instance.SetNewArray(&newArray_RooPolyVar);
      instance.SetDelete(&delete_RooPolyVar);
      instance.SetDeleteArray(&deleteArray_RooPolyVar);
      instance.SetDestructor(&destruct_RooPolyVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPolyVar*)
   {
      return GenerateInitInstanceLocal((::RooPolyVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPolyVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooProdGenContext(void *p);
   static void deleteArray_RooProdGenContext(void *p);
   static void destruct_RooProdGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProdGenContext*)
   {
      ::RooProdGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProdGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProdGenContext", ::RooProdGenContext::Class_Version(), "RooProdGenContext.h", 31,
                  typeid(::RooProdGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProdGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooProdGenContext) );
      instance.SetDelete(&delete_RooProdGenContext);
      instance.SetDeleteArray(&deleteArray_RooProdGenContext);
      instance.SetDestructor(&destruct_RooProdGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProdGenContext*)
   {
      return GenerateInitInstanceLocal((::RooProdGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProdGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProdPdf(void *p = nullptr);
   static void *newArray_RooProdPdf(Long_t size, void *p);
   static void delete_RooProdPdf(void *p);
   static void deleteArray_RooProdPdf(void *p);
   static void destruct_RooProdPdf(void *p);

   // Schema evolution read functions
   static void read_RooProdPdf_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__pdfNSetList = oldObj->GetId("_pdfNSetList");
#endif
      struct RooProdPdf_Onfile {
         RooLinkedList &_pdfNSetList;
         RooProdPdf_Onfile(RooLinkedList &onfile__pdfNSetList ): _pdfNSetList(onfile__pdfNSetList) {}
      };
      static Long_t offset_Onfile_RooProdPdf__pdfNSetList = oldObj->GetClass()->GetDataMemberOffset("_pdfNSetList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooProdPdf_Onfile onfile(
         *(RooLinkedList*)(onfile_add+offset_Onfile_RooProdPdf__pdfNSetList) );

      static TClassRef cls("RooProdPdf");
      static Long_t offset__pdfNSetList = cls->GetDataMemberOffset("_pdfNSetList");
      vector<unique_ptr<RooArgSet> >& _pdfNSetList = *(vector<unique_ptr<RooArgSet> >*)(target+offset__pdfNSetList);
      RooProdPdf* newObj = (RooProdPdf*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     for (auto * nset : static_range_cast<RooArgSet*>(onfile._pdfNSetList)) { \
           _pdfNSetList.emplace_back(nset);                                       \
         }                                                                        \
         
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProdPdf*)
   {
      ::RooProdPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProdPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProdPdf", ::RooProdPdf::Class_Version(), "RooProdPdf.h", 33,
                  typeid(::RooProdPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProdPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooProdPdf) );
      instance.SetNew(&new_RooProdPdf);
      instance.SetNewArray(&newArray_RooProdPdf);
      instance.SetDelete(&delete_RooProdPdf);
      instance.SetDeleteArray(&deleteArray_RooProdPdf);
      instance.SetDestructor(&destruct_RooProdPdf);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooProdPdf";
      rule->fTarget      = "_pdfNSetList";
      rule->fSource      = "RooLinkedList _pdfNSetList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooProdPdf_0);
      rule->fCode        = "for (auto * nset : static_range_cast<RooArgSet*>(onfile._pdfNSetList)) { \\n           _pdfNSetList.emplace_back(nset);                                       \\n         }                                                                        \\n         ";
      rule->fVersion     = "[-5]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProdPdf*)
   {
      return GenerateInitInstanceLocal((::RooProdPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProdPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProduct(void *p = nullptr);
   static void *newArray_RooProduct(Long_t size, void *p);
   static void delete_RooProduct(void *p);
   static void deleteArray_RooProduct(void *p);
   static void destruct_RooProduct(void *p);

   // Schema evolution read functions
   static void read_RooProduct_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__compRSet = oldObj->GetId("_compRSet");
#endif
      struct RooProduct_Onfile {
         RooSetProxy &_compRSet;
         RooProduct_Onfile(RooSetProxy &onfile__compRSet ): _compRSet(onfile__compRSet) {}
      };
      static Long_t offset_Onfile_RooProduct__compRSet = oldObj->GetClass()->GetDataMemberOffset("_compRSet");
      char *onfile_add = (char*)oldObj->GetObject();
      RooProduct_Onfile onfile(
         *(RooSetProxy*)(onfile_add+offset_Onfile_RooProduct__compRSet) );

      static TClassRef cls("RooProduct");
      static Long_t offset__compRSet = cls->GetDataMemberOffset("_compRSet");
      RooListProxy& _compRSet = *(RooListProxy*)(target+offset__compRSet);
      RooProduct* newObj = (RooProduct*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _compRSet.add(onfile._compRSet) ; 
   }
   static void read_RooProduct_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__compCSet = oldObj->GetId("_compCSet");
#endif
      struct RooProduct_Onfile {
         RooSetProxy &_compCSet;
         RooProduct_Onfile(RooSetProxy &onfile__compCSet ): _compCSet(onfile__compCSet) {}
      };
      static Long_t offset_Onfile_RooProduct__compCSet = oldObj->GetClass()->GetDataMemberOffset("_compCSet");
      char *onfile_add = (char*)oldObj->GetObject();
      RooProduct_Onfile onfile(
         *(RooSetProxy*)(onfile_add+offset_Onfile_RooProduct__compCSet) );

      static TClassRef cls("RooProduct");
      static Long_t offset__compCSet = cls->GetDataMemberOffset("_compCSet");
      RooListProxy& _compCSet = *(RooListProxy*)(target+offset__compCSet);
      RooProduct* newObj = (RooProduct*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      _compCSet.add(onfile._compCSet) ; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProduct*)
   {
      ::RooProduct *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProduct >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProduct", ::RooProduct::Class_Version(), "RooProduct.h", 29,
                  typeid(::RooProduct), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProduct::Dictionary, isa_proxy, 4,
                  sizeof(::RooProduct) );
      instance.SetNew(&new_RooProduct);
      instance.SetNewArray(&newArray_RooProduct);
      instance.SetDelete(&delete_RooProduct);
      instance.SetDeleteArray(&deleteArray_RooProduct);
      instance.SetDestructor(&destruct_RooProduct);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "RooProduct";
      rule->fTarget      = "_compRSet";
      rule->fSource      = "RooSetProxy _compRSet";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooProduct_0);
      rule->fCode        = " _compRSet.add(onfile._compRSet) ; ";
      rule->fVersion     = "[1]";
      rule = &readrules[1];
      rule->fSourceClass = "RooProduct";
      rule->fTarget      = "_compCSet";
      rule->fSource      = "RooSetProxy _compCSet";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooProduct_1);
      rule->fCode        = " _compCSet.add(onfile._compCSet) ; ";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProduct*)
   {
      return GenerateInitInstanceLocal((::RooProduct*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProduct*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProfileLL(void *p = nullptr);
   static void *newArray_RooProfileLL(Long_t size, void *p);
   static void delete_RooProfileLL(void *p);
   static void deleteArray_RooProfileLL(void *p);
   static void destruct_RooProfileLL(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProfileLL*)
   {
      ::RooProfileLL *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProfileLL >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProfileLL", ::RooProfileLL::Class_Version(), "RooProfileLL.h", 22,
                  typeid(::RooProfileLL), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProfileLL::Dictionary, isa_proxy, 4,
                  sizeof(::RooProfileLL) );
      instance.SetNew(&new_RooProfileLL);
      instance.SetNewArray(&newArray_RooProfileLL);
      instance.SetDelete(&delete_RooProfileLL);
      instance.SetDeleteArray(&deleteArray_RooProfileLL);
      instance.SetDestructor(&destruct_RooProfileLL);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProfileLL*)
   {
      return GenerateInitInstanceLocal((::RooProfileLL*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProfileLL*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProjectedPdf(void *p = nullptr);
   static void *newArray_RooProjectedPdf(Long_t size, void *p);
   static void delete_RooProjectedPdf(void *p);
   static void deleteArray_RooProjectedPdf(void *p);
   static void destruct_RooProjectedPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProjectedPdf*)
   {
      ::RooProjectedPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProjectedPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProjectedPdf", ::RooProjectedPdf::Class_Version(), "RooProjectedPdf.h", 21,
                  typeid(::RooProjectedPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProjectedPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooProjectedPdf) );
      instance.SetNew(&new_RooProjectedPdf);
      instance.SetNewArray(&newArray_RooProjectedPdf);
      instance.SetDelete(&delete_RooProjectedPdf);
      instance.SetDeleteArray(&deleteArray_RooProjectedPdf);
      instance.SetDestructor(&destruct_RooProjectedPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProjectedPdf*)
   {
      return GenerateInitInstanceLocal((::RooProjectedPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProjectedPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooProofDriverSelector(void *p = nullptr);
   static void *newArray_RooProofDriverSelector(Long_t size, void *p);
   static void delete_RooProofDriverSelector(void *p);
   static void deleteArray_RooProofDriverSelector(void *p);
   static void destruct_RooProofDriverSelector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooProofDriverSelector*)
   {
      ::RooProofDriverSelector *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooProofDriverSelector >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooProofDriverSelector", ::RooProofDriverSelector::Class_Version(), "RooProofDriverSelector.h", 17,
                  typeid(::RooProofDriverSelector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooProofDriverSelector::Dictionary, isa_proxy, 4,
                  sizeof(::RooProofDriverSelector) );
      instance.SetNew(&new_RooProofDriverSelector);
      instance.SetNewArray(&newArray_RooProofDriverSelector);
      instance.SetDelete(&delete_RooProofDriverSelector);
      instance.SetDeleteArray(&deleteArray_RooProofDriverSelector);
      instance.SetDestructor(&destruct_RooProofDriverSelector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooProofDriverSelector*)
   {
      return GenerateInitInstanceLocal((::RooProofDriverSelector*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooProofDriverSelector*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooPullVar(void *p = nullptr);
   static void *newArray_RooPullVar(Long_t size, void *p);
   static void delete_RooPullVar(void *p);
   static void deleteArray_RooPullVar(void *p);
   static void destruct_RooPullVar(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooPullVar*)
   {
      ::RooPullVar *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooPullVar >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooPullVar", ::RooPullVar::Class_Version(), "RooPullVar.h", 24,
                  typeid(::RooPullVar), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooPullVar::Dictionary, isa_proxy, 4,
                  sizeof(::RooPullVar) );
      instance.SetNew(&new_RooPullVar);
      instance.SetNewArray(&newArray_RooPullVar);
      instance.SetDelete(&delete_RooPullVar);
      instance.SetDeleteArray(&deleteArray_RooPullVar);
      instance.SetDestructor(&destruct_RooPullVar);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooPullVar*)
   {
      return GenerateInitInstanceLocal((::RooPullVar*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooPullVar*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooQuasiRandomGenerator(void *p = nullptr);
   static void *newArray_RooQuasiRandomGenerator(Long_t size, void *p);
   static void delete_RooQuasiRandomGenerator(void *p);
   static void deleteArray_RooQuasiRandomGenerator(void *p);
   static void destruct_RooQuasiRandomGenerator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooQuasiRandomGenerator*)
   {
      ::RooQuasiRandomGenerator *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooQuasiRandomGenerator >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooQuasiRandomGenerator", ::RooQuasiRandomGenerator::Class_Version(), "RooQuasiRandomGenerator.h", 21,
                  typeid(::RooQuasiRandomGenerator), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooQuasiRandomGenerator::Dictionary, isa_proxy, 4,
                  sizeof(::RooQuasiRandomGenerator) );
      instance.SetNew(&new_RooQuasiRandomGenerator);
      instance.SetNewArray(&newArray_RooQuasiRandomGenerator);
      instance.SetDelete(&delete_RooQuasiRandomGenerator);
      instance.SetDeleteArray(&deleteArray_RooQuasiRandomGenerator);
      instance.SetDestructor(&destruct_RooQuasiRandomGenerator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooQuasiRandomGenerator*)
   {
      return GenerateInitInstanceLocal((::RooQuasiRandomGenerator*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRatio(void *p = nullptr);
   static void *newArray_RooRatio(Long_t size, void *p);
   static void delete_RooRatio(void *p);
   static void deleteArray_RooRatio(void *p);
   static void destruct_RooRatio(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRatio*)
   {
      ::RooRatio *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRatio >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRatio", ::RooRatio::Class_Version(), "RooRatio.h", 30,
                  typeid(::RooRatio), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRatio::Dictionary, isa_proxy, 4,
                  sizeof(::RooRatio) );
      instance.SetNew(&new_RooRatio);
      instance.SetNewArray(&newArray_RooRatio);
      instance.SetDelete(&delete_RooRatio);
      instance.SetDeleteArray(&deleteArray_RooRatio);
      instance.SetDestructor(&destruct_RooRatio);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRatio*)
   {
      return GenerateInitInstanceLocal((::RooRatio*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRatio*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRandom(void *p);
   static void deleteArray_RooRandom(void *p);
   static void destruct_RooRandom(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRandom*)
   {
      ::RooRandom *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRandom >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRandom", ::RooRandom::Class_Version(), "RooRandom.h", 24,
                  typeid(::RooRandom), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRandom::Dictionary, isa_proxy, 4,
                  sizeof(::RooRandom) );
      instance.SetDelete(&delete_RooRandom);
      instance.SetDeleteArray(&deleteArray_RooRandom);
      instance.SetDestructor(&destruct_RooRandom);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRandom*)
   {
      return GenerateInitInstanceLocal((::RooRandom*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRandom*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRandomizeParamMCSModule(void *p = nullptr);
   static void *newArray_RooRandomizeParamMCSModule(Long_t size, void *p);
   static void delete_RooRandomizeParamMCSModule(void *p);
   static void deleteArray_RooRandomizeParamMCSModule(void *p);
   static void destruct_RooRandomizeParamMCSModule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRandomizeParamMCSModule*)
   {
      ::RooRandomizeParamMCSModule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRandomizeParamMCSModule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRandomizeParamMCSModule", ::RooRandomizeParamMCSModule::Class_Version(), "RooRandomizeParamMCSModule.h", 24,
                  typeid(::RooRandomizeParamMCSModule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRandomizeParamMCSModule::Dictionary, isa_proxy, 4,
                  sizeof(::RooRandomizeParamMCSModule) );
      instance.SetNew(&new_RooRandomizeParamMCSModule);
      instance.SetNewArray(&newArray_RooRandomizeParamMCSModule);
      instance.SetDelete(&delete_RooRandomizeParamMCSModule);
      instance.SetDeleteArray(&deleteArray_RooRandomizeParamMCSModule);
      instance.SetDestructor(&destruct_RooRandomizeParamMCSModule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRandomizeParamMCSModule*)
   {
      return GenerateInitInstanceLocal((::RooRandomizeParamMCSModule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRangeBinning(void *p = nullptr);
   static void *newArray_RooRangeBinning(Long_t size, void *p);
   static void delete_RooRangeBinning(void *p);
   static void deleteArray_RooRangeBinning(void *p);
   static void destruct_RooRangeBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRangeBinning*)
   {
      ::RooRangeBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRangeBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRangeBinning", ::RooRangeBinning::Class_Version(), "RooRangeBinning.h", 21,
                  typeid(::RooRangeBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRangeBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooRangeBinning) );
      instance.SetNew(&new_RooRangeBinning);
      instance.SetNewArray(&newArray_RooRangeBinning);
      instance.SetDelete(&delete_RooRangeBinning);
      instance.SetDeleteArray(&deleteArray_RooRangeBinning);
      instance.SetDestructor(&destruct_RooRangeBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRangeBinning*)
   {
      return GenerateInitInstanceLocal((::RooRangeBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRangeBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRangeBoolean(void *p = nullptr);
   static void *newArray_RooRangeBoolean(Long_t size, void *p);
   static void delete_RooRangeBoolean(void *p);
   static void deleteArray_RooRangeBoolean(void *p);
   static void destruct_RooRangeBoolean(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRangeBoolean*)
   {
      ::RooRangeBoolean *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRangeBoolean >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRangeBoolean", ::RooRangeBoolean::Class_Version(), "RooRangeBoolean.h", 27,
                  typeid(::RooRangeBoolean), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRangeBoolean::Dictionary, isa_proxy, 4,
                  sizeof(::RooRangeBoolean) );
      instance.SetNew(&new_RooRangeBoolean);
      instance.SetNewArray(&newArray_RooRangeBoolean);
      instance.SetDelete(&delete_RooRangeBoolean);
      instance.SetDeleteArray(&deleteArray_RooRangeBoolean);
      instance.SetDestructor(&destruct_RooRangeBoolean);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRangeBoolean*)
   {
      return GenerateInitInstanceLocal((::RooRangeBoolean*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRangeBoolean*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealAnalytic(void *p);
   static void deleteArray_RooRealAnalytic(void *p);
   static void destruct_RooRealAnalytic(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealAnalytic*)
   {
      ::RooRealAnalytic *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealAnalytic >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealAnalytic", ::RooRealAnalytic::Class_Version(), "RooRealAnalytic.h", 21,
                  typeid(::RooRealAnalytic), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealAnalytic::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealAnalytic) );
      instance.SetDelete(&delete_RooRealAnalytic);
      instance.SetDeleteArray(&deleteArray_RooRealAnalytic);
      instance.SetDestructor(&destruct_RooRealAnalytic);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealAnalytic*)
   {
      return GenerateInitInstanceLocal((::RooRealAnalytic*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealAnalytic*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealConstant(void *p = nullptr);
   static void *newArray_RooRealConstant(Long_t size, void *p);
   static void delete_RooRealConstant(void *p);
   static void deleteArray_RooRealConstant(void *p);
   static void destruct_RooRealConstant(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealConstant*)
   {
      ::RooRealConstant *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealConstant >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealConstant", ::RooRealConstant::Class_Version(), "RooRealConstant.h", 25,
                  typeid(::RooRealConstant), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealConstant::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealConstant) );
      instance.SetNew(&new_RooRealConstant);
      instance.SetNewArray(&newArray_RooRealConstant);
      instance.SetDelete(&delete_RooRealConstant);
      instance.SetDeleteArray(&deleteArray_RooRealConstant);
      instance.SetDestructor(&destruct_RooRealConstant);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealConstant*)
   {
      return GenerateInitInstanceLocal((::RooRealConstant*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealConstant*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealIntegral(void *p = nullptr);
   static void *newArray_RooRealIntegral(Long_t size, void *p);
   static void delete_RooRealIntegral(void *p);
   static void deleteArray_RooRealIntegral(void *p);
   static void destruct_RooRealIntegral(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealIntegral*)
   {
      ::RooRealIntegral *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealIntegral >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealIntegral", ::RooRealIntegral::Class_Version(), "RooRealIntegral.h", 34,
                  typeid(::RooRealIntegral), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealIntegral::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealIntegral) );
      instance.SetNew(&new_RooRealIntegral);
      instance.SetNewArray(&newArray_RooRealIntegral);
      instance.SetDelete(&delete_RooRealIntegral);
      instance.SetDeleteArray(&deleteArray_RooRealIntegral);
      instance.SetDestructor(&destruct_RooRealIntegral);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealIntegral*)
   {
      return GenerateInitInstanceLocal((::RooRealIntegral*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealIntegral*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooRealMPFE(void *p);
   static void deleteArray_RooRealMPFE(void *p);
   static void destruct_RooRealMPFE(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealMPFE*)
   {
      ::RooRealMPFE *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealMPFE >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealMPFE", ::RooRealMPFE::Class_Version(), "RooRealMPFE.h", 30,
                  typeid(::RooRealMPFE), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealMPFE::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealMPFE) );
      instance.SetDelete(&delete_RooRealMPFE);
      instance.SetDeleteArray(&deleteArray_RooRealMPFE);
      instance.SetDestructor(&destruct_RooRealMPFE);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealMPFE*)
   {
      return GenerateInitInstanceLocal((::RooRealMPFE*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealMPFE*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealSumFunc(void *p = nullptr);
   static void *newArray_RooRealSumFunc(Long_t size, void *p);
   static void delete_RooRealSumFunc(void *p);
   static void deleteArray_RooRealSumFunc(void *p);
   static void destruct_RooRealSumFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealSumFunc*)
   {
      ::RooRealSumFunc *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealSumFunc >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealSumFunc", ::RooRealSumFunc::Class_Version(), "RooRealSumFunc.h", 25,
                  typeid(::RooRealSumFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealSumFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealSumFunc) );
      instance.SetNew(&new_RooRealSumFunc);
      instance.SetNewArray(&newArray_RooRealSumFunc);
      instance.SetDelete(&delete_RooRealSumFunc);
      instance.SetDeleteArray(&deleteArray_RooRealSumFunc);
      instance.SetDestructor(&destruct_RooRealSumFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealSumFunc*)
   {
      return GenerateInitInstanceLocal((::RooRealSumFunc*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealSumFunc*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealSumPdf(void *p = nullptr);
   static void *newArray_RooRealSumPdf(Long_t size, void *p);
   static void delete_RooRealSumPdf(void *p);
   static void deleteArray_RooRealSumPdf(void *p);
   static void destruct_RooRealSumPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealSumPdf*)
   {
      ::RooRealSumPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealSumPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealSumPdf", ::RooRealSumPdf::Class_Version(), "RooRealSumPdf.h", 24,
                  typeid(::RooRealSumPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealSumPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealSumPdf) );
      instance.SetNew(&new_RooRealSumPdf);
      instance.SetNewArray(&newArray_RooRealSumPdf);
      instance.SetDelete(&delete_RooRealSumPdf);
      instance.SetDeleteArray(&deleteArray_RooRealSumPdf);
      instance.SetDestructor(&destruct_RooRealSumPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealSumPdf*)
   {
      return GenerateInitInstanceLocal((::RooRealSumPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealSumPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSharedProperties(void *p = nullptr);
   static void *newArray_RooSharedProperties(Long_t size, void *p);
   static void delete_RooSharedProperties(void *p);
   static void deleteArray_RooSharedProperties(void *p);
   static void destruct_RooSharedProperties(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSharedProperties*)
   {
      ::RooSharedProperties *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSharedProperties >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSharedProperties", ::RooSharedProperties::Class_Version(), "RooSharedProperties.h", 23,
                  typeid(::RooSharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooSharedProperties) );
      instance.SetNew(&new_RooSharedProperties);
      instance.SetNewArray(&newArray_RooSharedProperties);
      instance.SetDelete(&delete_RooSharedProperties);
      instance.SetDeleteArray(&deleteArray_RooSharedProperties);
      instance.SetDestructor(&destruct_RooSharedProperties);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooSharedProperties*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSharedProperties*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRealVarSharedProperties(void *p = nullptr);
   static void *newArray_RooRealVarSharedProperties(Long_t size, void *p);
   static void delete_RooRealVarSharedProperties(void *p);
   static void deleteArray_RooRealVarSharedProperties(void *p);
   static void destruct_RooRealVarSharedProperties(void *p);

   // Schema evolution read functions
   static void read_RooRealVarSharedProperties_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__altBinning = oldObj->GetId("_altBinning");
#endif
      struct RooRealVarSharedProperties_Onfile {
         RooLinkedList &_altBinning;
         RooRealVarSharedProperties_Onfile(RooLinkedList &onfile__altBinning ): _altBinning(onfile__altBinning) {}
      };
      static Long_t offset_Onfile_RooRealVarSharedProperties__altBinning = oldObj->GetClass()->GetDataMemberOffset("_altBinning");
      char *onfile_add = (char*)oldObj->GetObject();
      RooRealVarSharedProperties_Onfile onfile(
         *(RooLinkedList*)(onfile_add+offset_Onfile_RooRealVarSharedProperties__altBinning) );

      static TClassRef cls("RooRealVarSharedProperties");
      static Long_t offset__altBinning = cls->GetDataMemberOffset("_altBinning");
      unordered_map<string,RooAbsBinning*>& _altBinning = *(unordered_map<string,RooAbsBinning*>*)(target+offset__altBinning);
      RooRealVarSharedProperties* newObj = (RooRealVarSharedProperties*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
      \
    for (TObject * binning : onfile._altBinning) { _altBinning[binning->GetName()] = static_cast<RooAbsBinning*>(binning); } \
  
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRealVarSharedProperties*)
   {
      ::RooRealVarSharedProperties *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRealVarSharedProperties >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRealVarSharedProperties", ::RooRealVarSharedProperties::Class_Version(), "RooRealVarSharedProperties.h", 39,
                  typeid(::RooRealVarSharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRealVarSharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooRealVarSharedProperties) );
      instance.SetNew(&new_RooRealVarSharedProperties);
      instance.SetNewArray(&newArray_RooRealVarSharedProperties);
      instance.SetDelete(&delete_RooRealVarSharedProperties);
      instance.SetDeleteArray(&deleteArray_RooRealVarSharedProperties);
      instance.SetDestructor(&destruct_RooRealVarSharedProperties);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooRealVarSharedProperties";
      rule->fTarget      = "_altBinning";
      rule->fSource      = "RooLinkedList _altBinning";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooRealVarSharedProperties_0);
      rule->fCode        = " \\n    for (TObject * binning : onfile._altBinning) { _altBinning[binning->GetName()] = static_cast<RooAbsBinning*>(binning); } \\n  ";
      rule->fVersion     = "[1]";
      rule->fInclude     = "RooLinkedList.h";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRealVarSharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooRealVarSharedProperties*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRecursiveFraction(void *p = nullptr);
   static void *newArray_RooRecursiveFraction(Long_t size, void *p);
   static void delete_RooRecursiveFraction(void *p);
   static void deleteArray_RooRecursiveFraction(void *p);
   static void destruct_RooRecursiveFraction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRecursiveFraction*)
   {
      ::RooRecursiveFraction *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRecursiveFraction >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRecursiveFraction", ::RooRecursiveFraction::Class_Version(), "RooRecursiveFraction.h", 25,
                  typeid(::RooRecursiveFraction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRecursiveFraction::Dictionary, isa_proxy, 4,
                  sizeof(::RooRecursiveFraction) );
      instance.SetNew(&new_RooRecursiveFraction);
      instance.SetNewArray(&newArray_RooRecursiveFraction);
      instance.SetDelete(&delete_RooRecursiveFraction);
      instance.SetDeleteArray(&deleteArray_RooRecursiveFraction);
      instance.SetDestructor(&destruct_RooRecursiveFraction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRecursiveFraction*)
   {
      return GenerateInitInstanceLocal((::RooRecursiveFraction*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRecursiveFraction*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooRefCountList(void *p = nullptr);
   static void *newArray_RooRefCountList(Long_t size, void *p);
   static void delete_RooRefCountList(void *p);
   static void deleteArray_RooRefCountList(void *p);
   static void destruct_RooRefCountList(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooRefCountList*)
   {
      ::RooRefCountList *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooRefCountList >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooRefCountList", ::RooRefCountList::Class_Version(), "RooRefCountList.h", 21,
                  typeid(::RooRefCountList), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooRefCountList::Dictionary, isa_proxy, 4,
                  sizeof(::RooRefCountList) );
      instance.SetNew(&new_RooRefCountList);
      instance.SetNewArray(&newArray_RooRefCountList);
      instance.SetDelete(&delete_RooRefCountList);
      instance.SetDeleteArray(&deleteArray_RooRefCountList);
      instance.SetDestructor(&destruct_RooRefCountList);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooRefCountList*)
   {
      return GenerateInitInstanceLocal((::RooRefCountList*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooRefCountList*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooScaledFunc(void *p);
   static void deleteArray_RooScaledFunc(void *p);
   static void destruct_RooScaledFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooScaledFunc*)
   {
      ::RooScaledFunc *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooScaledFunc >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooScaledFunc", ::RooScaledFunc::Class_Version(), "RooScaledFunc.h", 22,
                  typeid(::RooScaledFunc), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooScaledFunc::Dictionary, isa_proxy, 4,
                  sizeof(::RooScaledFunc) );
      instance.SetDelete(&delete_RooScaledFunc);
      instance.SetDeleteArray(&deleteArray_RooScaledFunc);
      instance.SetDestructor(&destruct_RooScaledFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooScaledFunc*)
   {
      return GenerateInitInstanceLocal((::RooScaledFunc*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooScaledFunc*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSecondMoment(void *p = nullptr);
   static void *newArray_RooSecondMoment(Long_t size, void *p);
   static void delete_RooSecondMoment(void *p);
   static void deleteArray_RooSecondMoment(void *p);
   static void destruct_RooSecondMoment(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSecondMoment*)
   {
      ::RooSecondMoment *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSecondMoment >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSecondMoment", ::RooSecondMoment::Class_Version(), "RooSecondMoment.h", 27,
                  typeid(::RooSecondMoment), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSecondMoment::Dictionary, isa_proxy, 4,
                  sizeof(::RooSecondMoment) );
      instance.SetNew(&new_RooSecondMoment);
      instance.SetNewArray(&newArray_RooSecondMoment);
      instance.SetDelete(&delete_RooSecondMoment);
      instance.SetDeleteArray(&deleteArray_RooSecondMoment);
      instance.SetDestructor(&destruct_RooSecondMoment);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSecondMoment*)
   {
      return GenerateInitInstanceLocal((::RooSecondMoment*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSecondMoment*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSegmentedIntegrator1D(void *p = nullptr);
   static void *newArray_RooSegmentedIntegrator1D(Long_t size, void *p);
   static void delete_RooSegmentedIntegrator1D(void *p);
   static void deleteArray_RooSegmentedIntegrator1D(void *p);
   static void destruct_RooSegmentedIntegrator1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSegmentedIntegrator1D*)
   {
      ::RooSegmentedIntegrator1D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSegmentedIntegrator1D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSegmentedIntegrator1D", ::RooSegmentedIntegrator1D::Class_Version(), "RooSegmentedIntegrator1D.h", 23,
                  typeid(::RooSegmentedIntegrator1D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSegmentedIntegrator1D::Dictionary, isa_proxy, 4,
                  sizeof(::RooSegmentedIntegrator1D) );
      instance.SetNew(&new_RooSegmentedIntegrator1D);
      instance.SetNewArray(&newArray_RooSegmentedIntegrator1D);
      instance.SetDelete(&delete_RooSegmentedIntegrator1D);
      instance.SetDeleteArray(&deleteArray_RooSegmentedIntegrator1D);
      instance.SetDestructor(&destruct_RooSegmentedIntegrator1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSegmentedIntegrator1D*)
   {
      return GenerateInitInstanceLocal((::RooSegmentedIntegrator1D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSegmentedIntegrator2D(void *p = nullptr);
   static void *newArray_RooSegmentedIntegrator2D(Long_t size, void *p);
   static void delete_RooSegmentedIntegrator2D(void *p);
   static void deleteArray_RooSegmentedIntegrator2D(void *p);
   static void destruct_RooSegmentedIntegrator2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSegmentedIntegrator2D*)
   {
      ::RooSegmentedIntegrator2D *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSegmentedIntegrator2D >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSegmentedIntegrator2D", ::RooSegmentedIntegrator2D::Class_Version(), "RooSegmentedIntegrator2D.h", 23,
                  typeid(::RooSegmentedIntegrator2D), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSegmentedIntegrator2D::Dictionary, isa_proxy, 4,
                  sizeof(::RooSegmentedIntegrator2D) );
      instance.SetNew(&new_RooSegmentedIntegrator2D);
      instance.SetNewArray(&newArray_RooSegmentedIntegrator2D);
      instance.SetDelete(&delete_RooSegmentedIntegrator2D);
      instance.SetDeleteArray(&deleteArray_RooSegmentedIntegrator2D);
      instance.SetDestructor(&destruct_RooSegmentedIntegrator2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSegmentedIntegrator2D*)
   {
      return GenerateInitInstanceLocal((::RooSegmentedIntegrator2D*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimGenContext(void *p);
   static void deleteArray_RooSimGenContext(void *p);
   static void destruct_RooSimGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimGenContext*)
   {
      ::RooSimGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimGenContext", ::RooSimGenContext::Class_Version(), "RooSimGenContext.h", 27,
                  typeid(::RooSimGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimGenContext) );
      instance.SetDelete(&delete_RooSimGenContext);
      instance.SetDeleteArray(&deleteArray_RooSimGenContext);
      instance.SetDestructor(&destruct_RooSimGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimGenContext*)
   {
      return GenerateInitInstanceLocal((::RooSimGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimPdfBuilder(void *p);
   static void deleteArray_RooSimPdfBuilder(void *p);
   static void destruct_RooSimPdfBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimPdfBuilder*)
   {
      ::RooSimPdfBuilder *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimPdfBuilder >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimPdfBuilder", ::RooSimPdfBuilder::Class_Version(), "RooSimPdfBuilder.h", 32,
                  typeid(::RooSimPdfBuilder), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimPdfBuilder::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimPdfBuilder) );
      instance.SetDelete(&delete_RooSimPdfBuilder);
      instance.SetDeleteArray(&deleteArray_RooSimPdfBuilder);
      instance.SetDestructor(&destruct_RooSimPdfBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimPdfBuilder*)
   {
      return GenerateInitInstanceLocal((::RooSimPdfBuilder*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimSplitGenContext(void *p);
   static void deleteArray_RooSimSplitGenContext(void *p);
   static void destruct_RooSimSplitGenContext(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimSplitGenContext*)
   {
      ::RooSimSplitGenContext *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimSplitGenContext >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimSplitGenContext", ::RooSimSplitGenContext::Class_Version(), "RooSimSplitGenContext.h", 27,
                  typeid(::RooSimSplitGenContext), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimSplitGenContext::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimSplitGenContext) );
      instance.SetDelete(&delete_RooSimSplitGenContext);
      instance.SetDeleteArray(&deleteArray_RooSimSplitGenContext);
      instance.SetDestructor(&destruct_RooSimSplitGenContext);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimSplitGenContext*)
   {
      return GenerateInitInstanceLocal((::RooSimSplitGenContext*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimultaneous(void *p = nullptr);
   static void *newArray_RooSimultaneous(Long_t size, void *p);
   static void delete_RooSimultaneous(void *p);
   static void deleteArray_RooSimultaneous(void *p);
   static void destruct_RooSimultaneous(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimultaneous*)
   {
      ::RooSimultaneous *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimultaneous >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimultaneous", ::RooSimultaneous::Class_Version(), "RooSimultaneous.h", 37,
                  typeid(::RooSimultaneous), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimultaneous::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimultaneous) );
      instance.SetNew(&new_RooSimultaneous);
      instance.SetNewArray(&newArray_RooSimultaneous);
      instance.SetDelete(&delete_RooSimultaneous);
      instance.SetDeleteArray(&deleteArray_RooSimultaneous);
      instance.SetDestructor(&destruct_RooSimultaneous);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimultaneous*)
   {
      return GenerateInitInstanceLocal((::RooSimultaneous*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimultaneous*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooWorkspace(void *p = nullptr);
   static void *newArray_RooWorkspace(Long_t size, void *p);
   static void delete_RooWorkspace(void *p);
   static void deleteArray_RooWorkspace(void *p);
   static void destruct_RooWorkspace(void *p);
   static void streamer_RooWorkspace(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace*)
   {
      ::RooWorkspace *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace", ::RooWorkspace::Class_Version(), "RooWorkspace.h", 43,
                  typeid(::RooWorkspace), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::Dictionary, isa_proxy, 17,
                  sizeof(::RooWorkspace) );
      instance.SetNew(&new_RooWorkspace);
      instance.SetNewArray(&newArray_RooWorkspace);
      instance.SetDelete(&delete_RooWorkspace);
      instance.SetDeleteArray(&deleteArray_RooWorkspace);
      instance.SetDestructor(&destruct_RooWorkspace);
      instance.SetStreamerFunc(&streamer_RooWorkspace);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooWorkspacecLcLCodeRepo(void *p = nullptr);
   static void *newArray_RooWorkspacecLcLCodeRepo(Long_t size, void *p);
   static void delete_RooWorkspacecLcLCodeRepo(void *p);
   static void deleteArray_RooWorkspacecLcLCodeRepo(void *p);
   static void destruct_RooWorkspacecLcLCodeRepo(void *p);
   static void streamer_RooWorkspacecLcLCodeRepo(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace::CodeRepo*)
   {
      ::RooWorkspace::CodeRepo *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace::CodeRepo >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace::CodeRepo", ::RooWorkspace::CodeRepo::Class_Version(), "RooWorkspace.h", 170,
                  typeid(::RooWorkspace::CodeRepo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::CodeRepo::Dictionary, isa_proxy, 17,
                  sizeof(::RooWorkspace::CodeRepo) );
      instance.SetNew(&new_RooWorkspacecLcLCodeRepo);
      instance.SetNewArray(&newArray_RooWorkspacecLcLCodeRepo);
      instance.SetDelete(&delete_RooWorkspacecLcLCodeRepo);
      instance.SetDeleteArray(&deleteArray_RooWorkspacecLcLCodeRepo);
      instance.SetDestructor(&destruct_RooWorkspacecLcLCodeRepo);
      instance.SetStreamerFunc(&streamer_RooWorkspacecLcLCodeRepo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace::CodeRepo*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace::CodeRepo*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooWorkspacecLcLWSDir(void *p);
   static void deleteArray_RooWorkspacecLcLWSDir(void *p);
   static void destruct_RooWorkspacecLcLWSDir(void *p);
   static void reset_RooWorkspacecLcLWSDir(void *obj, TFileMergeInfo *info);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspace::WSDir*)
   {
      ::RooWorkspace::WSDir *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspace::WSDir >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspace::WSDir", ::RooWorkspace::WSDir::Class_Version(), "RooWorkspace.h", 225,
                  typeid(::RooWorkspace::WSDir), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspace::WSDir::Dictionary, isa_proxy, 4,
                  sizeof(::RooWorkspace::WSDir) );
      instance.SetDelete(&delete_RooWorkspacecLcLWSDir);
      instance.SetDeleteArray(&deleteArray_RooWorkspacecLcLWSDir);
      instance.SetDestructor(&destruct_RooWorkspacecLcLWSDir);
      instance.SetResetAfterMerge(&reset_RooWorkspacecLcLWSDir);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspace::WSDir*)
   {
      return GenerateInitInstanceLocal((::RooWorkspace::WSDir*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSTool(void *p);
   static void deleteArray_RooSimWSTool(void *p);
   static void destruct_RooSimWSTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool*)
   {
      ::RooSimWSTool *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool", ::RooSimWSTool::Class_Version(), "RooSimWSTool.h", 37,
                  typeid(::RooSimWSTool), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool) );
      instance.SetDelete(&delete_RooSimWSTool);
      instance.SetDeleteArray(&deleteArray_RooSimWSTool);
      instance.SetDestructor(&destruct_RooSimWSTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLSplitRule(void *p = nullptr);
   static void *newArray_RooSimWSToolcLcLSplitRule(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLSplitRule(void *p);
   static void deleteArray_RooSimWSToolcLcLSplitRule(void *p);
   static void destruct_RooSimWSToolcLcLSplitRule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::SplitRule*)
   {
      ::RooSimWSTool::SplitRule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::SplitRule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::SplitRule", ::RooSimWSTool::SplitRule::Class_Version(), "RooSimWSTool.h", 80,
                  typeid(::RooSimWSTool::SplitRule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::SplitRule::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::SplitRule) );
      instance.SetNew(&new_RooSimWSToolcLcLSplitRule);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLSplitRule);
      instance.SetDelete(&delete_RooSimWSToolcLcLSplitRule);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLSplitRule);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLSplitRule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::SplitRule*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::SplitRule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSToolcLcLBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::BuildConfig*)
   {
      ::RooSimWSTool::BuildConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::BuildConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::BuildConfig", ::RooSimWSTool::BuildConfig::Class_Version(), "RooSimWSTool.h", 102,
                  typeid(::RooSimWSTool::BuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::BuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::BuildConfig) );
      instance.SetDelete(&delete_RooSimWSToolcLcLBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::BuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::BuildConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooSimWSToolcLcLMultiBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLMultiBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLMultiBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::MultiBuildConfig*)
   {
      ::RooSimWSTool::MultiBuildConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::MultiBuildConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::MultiBuildConfig", ::RooSimWSTool::MultiBuildConfig::Class_Version(), "RooSimWSTool.h", 129,
                  typeid(::RooSimWSTool::MultiBuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::MultiBuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::MultiBuildConfig) );
      instance.SetDelete(&delete_RooSimWSToolcLcLMultiBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLMultiBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLMultiBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::MultiBuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::MultiBuildConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLObjSplitRule(void *p = nullptr);
   static void *newArray_RooSimWSToolcLcLObjSplitRule(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLObjSplitRule(void *p);
   static void deleteArray_RooSimWSToolcLcLObjSplitRule(void *p);
   static void destruct_RooSimWSToolcLcLObjSplitRule(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::ObjSplitRule*)
   {
      ::RooSimWSTool::ObjSplitRule *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::ObjSplitRule >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::ObjSplitRule", ::RooSimWSTool::ObjSplitRule::Class_Version(), "RooSimWSTool.h", 151,
                  typeid(::RooSimWSTool::ObjSplitRule), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::ObjSplitRule::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::ObjSplitRule) );
      instance.SetNew(&new_RooSimWSToolcLcLObjSplitRule);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLObjSplitRule);
      instance.SetDelete(&delete_RooSimWSToolcLcLObjSplitRule);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLObjSplitRule);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLObjSplitRule);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::ObjSplitRule*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::ObjSplitRule*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSimWSToolcLcLObjBuildConfig(void *p = nullptr);
   static void *newArray_RooSimWSToolcLcLObjBuildConfig(Long_t size, void *p);
   static void delete_RooSimWSToolcLcLObjBuildConfig(void *p);
   static void deleteArray_RooSimWSToolcLcLObjBuildConfig(void *p);
   static void destruct_RooSimWSToolcLcLObjBuildConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSimWSTool::ObjBuildConfig*)
   {
      ::RooSimWSTool::ObjBuildConfig *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSimWSTool::ObjBuildConfig >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSimWSTool::ObjBuildConfig", ::RooSimWSTool::ObjBuildConfig::Class_Version(), "RooSimWSTool.h", 165,
                  typeid(::RooSimWSTool::ObjBuildConfig), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSimWSTool::ObjBuildConfig::Dictionary, isa_proxy, 4,
                  sizeof(::RooSimWSTool::ObjBuildConfig) );
      instance.SetNew(&new_RooSimWSToolcLcLObjBuildConfig);
      instance.SetNewArray(&newArray_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDelete(&delete_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDeleteArray(&deleteArray_RooSimWSToolcLcLObjBuildConfig);
      instance.SetDestructor(&destruct_RooSimWSToolcLcLObjBuildConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSimWSTool::ObjBuildConfig*)
   {
      return GenerateInitInstanceLocal((::RooSimWSTool::ObjBuildConfig*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooStreamParser(void *p);
   static void deleteArray_RooStreamParser(void *p);
   static void destruct_RooStreamParser(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStreamParser*)
   {
      ::RooStreamParser *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStreamParser >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooStreamParser", ::RooStreamParser::Class_Version(), "RooStreamParser.h", 21,
                  typeid(::RooStreamParser), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStreamParser::Dictionary, isa_proxy, 4,
                  sizeof(::RooStreamParser) );
      instance.SetDelete(&delete_RooStreamParser);
      instance.SetDeleteArray(&deleteArray_RooStreamParser);
      instance.SetDestructor(&destruct_RooStreamParser);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStreamParser*)
   {
      return GenerateInitInstanceLocal((::RooStreamParser*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStreamParser*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooStudyPackage(void *p = nullptr);
   static void *newArray_RooStudyPackage(Long_t size, void *p);
   static void delete_RooStudyPackage(void *p);
   static void deleteArray_RooStudyPackage(void *p);
   static void destruct_RooStudyPackage(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStudyPackage*)
   {
      ::RooStudyPackage *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStudyPackage >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooStudyPackage", ::RooStudyPackage::Class_Version(), "RooStudyPackage.h", 31,
                  typeid(::RooStudyPackage), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStudyPackage::Dictionary, isa_proxy, 4,
                  sizeof(::RooStudyPackage) );
      instance.SetNew(&new_RooStudyPackage);
      instance.SetNewArray(&newArray_RooStudyPackage);
      instance.SetDelete(&delete_RooStudyPackage);
      instance.SetDeleteArray(&deleteArray_RooStudyPackage);
      instance.SetDestructor(&destruct_RooStudyPackage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStudyPackage*)
   {
      return GenerateInitInstanceLocal((::RooStudyPackage*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStudyPackage*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooStudyManager(void *p);
   static void deleteArray_RooStudyManager(void *p);
   static void destruct_RooStudyManager(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooStudyManager*)
   {
      ::RooStudyManager *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooStudyManager >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooStudyManager", ::RooStudyManager::Class_Version(), "RooStudyManager.h", 33,
                  typeid(::RooStudyManager), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooStudyManager::Dictionary, isa_proxy, 4,
                  sizeof(::RooStudyManager) );
      instance.SetDelete(&delete_RooStudyManager);
      instance.SetDeleteArray(&deleteArray_RooStudyManager);
      instance.SetDestructor(&destruct_RooStudyManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooStudyManager*)
   {
      return GenerateInitInstanceLocal((::RooStudyManager*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooStudyManager*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSuperCategory(void *p = nullptr);
   static void *newArray_RooSuperCategory(Long_t size, void *p);
   static void delete_RooSuperCategory(void *p);
   static void deleteArray_RooSuperCategory(void *p);
   static void destruct_RooSuperCategory(void *p);

   // Schema evolution read functions
   static void read_RooSuperCategory_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__catSet = oldObj->GetId("_catSet");
#endif
      struct RooSuperCategory_Onfile {
         RooSetProxy &_catSet;
         RooSuperCategory_Onfile(RooSetProxy &onfile__catSet ): _catSet(onfile__catSet) {}
      };
      static Long_t offset_Onfile_RooSuperCategory__catSet = oldObj->GetClass()->GetDataMemberOffset("_catSet");
      char *onfile_add = (char*)oldObj->GetObject();
      RooSuperCategory_Onfile onfile(
         *(RooSetProxy*)(onfile_add+offset_Onfile_RooSuperCategory__catSet) );

      static TClassRef cls("RooSuperCategory");
      static Long_t offset__multiCat = cls->GetDataMemberOffset("_multiCat");
      RooTemplateProxy<RooMultiCategory>& _multiCat = *(RooTemplateProxy<RooMultiCategory>*)(target+offset__multiCat);
      RooSuperCategory* newObj = (RooSuperCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     auto newArg = new RooMultiCategory((std::string(newObj->GetName()) + "_internalMultiCat").c_str(), newObj->GetTitle(), onfile._catSet); \
         _multiCat.setArg(*newArg); 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSuperCategory*)
   {
      ::RooSuperCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSuperCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSuperCategory", ::RooSuperCategory::Class_Version(), "RooSuperCategory.h", 27,
                  typeid(::RooSuperCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSuperCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooSuperCategory) );
      instance.SetNew(&new_RooSuperCategory);
      instance.SetNewArray(&newArray_RooSuperCategory);
      instance.SetDelete(&delete_RooSuperCategory);
      instance.SetDeleteArray(&deleteArray_RooSuperCategory);
      instance.SetDestructor(&destruct_RooSuperCategory);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooSuperCategory";
      rule->fTarget      = "_multiCat";
      rule->fSource      = "RooSetProxy _catSet";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooSuperCategory_0);
      rule->fCode        = "auto newArg = new RooMultiCategory((std::string(newObj->GetName()) + \"_internalMultiCat\").c_str(), newObj->GetTitle(), onfile._catSet); \\n         _multiCat.setArg(*newArg); ";
      rule->fVersion     = "[1]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSuperCategory*)
   {
      return GenerateInitInstanceLocal((::RooSuperCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSuperCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTFoamBinding(void *p);
   static void deleteArray_RooTFoamBinding(void *p);
   static void destruct_RooTFoamBinding(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTFoamBinding*)
   {
      ::RooTFoamBinding *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTFoamBinding >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTFoamBinding", ::RooTFoamBinding::Class_Version(), "RooTFoamBinding.h", 24,
                  typeid(::RooTFoamBinding), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTFoamBinding::Dictionary, isa_proxy, 4,
                  sizeof(::RooTFoamBinding) );
      instance.SetDelete(&delete_RooTFoamBinding);
      instance.SetDeleteArray(&deleteArray_RooTFoamBinding);
      instance.SetDestructor(&destruct_RooTFoamBinding);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTFoamBinding*)
   {
      return GenerateInitInstanceLocal((::RooTFoamBinding*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTFoamBinding*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooThresholdCategory(void *p = nullptr);
   static void *newArray_RooThresholdCategory(Long_t size, void *p);
   static void delete_RooThresholdCategory(void *p);
   static void deleteArray_RooThresholdCategory(void *p);
   static void destruct_RooThresholdCategory(void *p);

   // Schema evolution read functions
   static void read_RooThresholdCategory_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__defCat = oldObj->GetId("_defCat");
      static Int_t id__threshList = oldObj->GetId("_threshList");
#endif
      struct RooThresholdCategory_Onfile {
         RooCatType* &_defCat;
         TSortedList &_threshList;
         RooThresholdCategory_Onfile(RooCatType* &onfile__defCat, TSortedList &onfile__threshList ): _defCat(onfile__defCat), _threshList(onfile__threshList) {}
      };
      static Long_t offset_Onfile_RooThresholdCategory__defCat = oldObj->GetClass()->GetDataMemberOffset("_defCat");
      static Long_t offset_Onfile_RooThresholdCategory__threshList = oldObj->GetClass()->GetDataMemberOffset("_threshList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooThresholdCategory_Onfile onfile(
         *(RooCatType**)(onfile_add+offset_Onfile_RooThresholdCategory__defCat),
         *(TSortedList*)(onfile_add+offset_Onfile_RooThresholdCategory__threshList) );

      static TClassRef cls("RooThresholdCategory");
      static Long_t offset__defIndex = cls->GetDataMemberOffset("_defIndex");
      const RooAbsCategory::value_type& _defIndex = *(const RooAbsCategory::value_type*)(target+offset__defIndex);
      static Long_t offset__threshList = cls->GetDataMemberOffset("_threshList");
      vector<pair<double,RooAbsCategory::value_type> >& _threshList = *(vector<pair<double,RooAbsCategory::value_type> >*)(target+offset__threshList);
      RooThresholdCategory* newObj = (RooThresholdCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     const_cast<int&>(_defIndex) = onfile._defCat->getVal(); \
         class RooThreshEntry : public TObject { public: Double_t _thresh; RooCatType _cat;}; \
         RooThreshEntry* te; \
         auto iter = onfile._threshList.MakeIterator();\
         while( (te = (RooThreshEntry*)iter->Next()) ) { \
           _threshList.emplace_back(te->_thresh, te->_cat.getVal()); \
         }\
         delete iter;\
         
   }
   static void read_RooThresholdCategory_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__defCat = oldObj->GetId("_defCat");
      static Int_t id__threshList = oldObj->GetId("_threshList");
#endif
      struct RooThresholdCategory_Onfile {
         RooCatType* &_defCat;
         std::vector<std::pair<double,RooCatType>> &_threshList;
         RooThresholdCategory_Onfile(RooCatType* &onfile__defCat, std::vector<std::pair<double,RooCatType>> &onfile__threshList ): _defCat(onfile__defCat), _threshList(onfile__threshList) {}
      };
      static Long_t offset_Onfile_RooThresholdCategory__defCat = oldObj->GetClass()->GetDataMemberOffset("_defCat");
      static Long_t offset_Onfile_RooThresholdCategory__threshList = oldObj->GetClass()->GetDataMemberOffset("_threshList");
      char *onfile_add = (char*)oldObj->GetObject();
      RooThresholdCategory_Onfile onfile(
         *(RooCatType**)(onfile_add+offset_Onfile_RooThresholdCategory__defCat),
         *(std::vector<std::pair<double,RooCatType>>*)(onfile_add+offset_Onfile_RooThresholdCategory__threshList) );

      static TClassRef cls("RooThresholdCategory");
      static Long_t offset__defIndex = cls->GetDataMemberOffset("_defIndex");
      const RooAbsCategory::value_type& _defIndex = *(const RooAbsCategory::value_type*)(target+offset__defIndex);
      static Long_t offset__threshList = cls->GetDataMemberOffset("_threshList");
      vector<pair<double,RooAbsCategory::value_type> >& _threshList = *(vector<pair<double,RooAbsCategory::value_type> >*)(target+offset__threshList);
      RooThresholdCategory* newObj = (RooThresholdCategory*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     const_cast<int&>(_defIndex) = onfile._defCat->getVal(); \
         for (const auto& threshCatPair : onfile._threshList) { \
           _threshList.emplace_back(threshCatPair.first, threshCatPair.second.getVal()); \
         }\
         
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooThresholdCategory*)
   {
      ::RooThresholdCategory *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooThresholdCategory >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooThresholdCategory", ::RooThresholdCategory::Class_Version(), "RooThresholdCategory.h", 26,
                  typeid(::RooThresholdCategory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooThresholdCategory::Dictionary, isa_proxy, 4,
                  sizeof(::RooThresholdCategory) );
      instance.SetNew(&new_RooThresholdCategory);
      instance.SetNewArray(&newArray_RooThresholdCategory);
      instance.SetDelete(&delete_RooThresholdCategory);
      instance.SetDeleteArray(&deleteArray_RooThresholdCategory);
      instance.SetDestructor(&destruct_RooThresholdCategory);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "RooThresholdCategory";
      rule->fTarget      = "_defIndex,_threshList";
      rule->fSource      = "RooCatType* _defCat; TSortedList _threshList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooThresholdCategory_0);
      rule->fCode        = "const_cast<int&>(_defIndex) = onfile._defCat->getVal(); \\n         class RooThreshEntry : public TObject { public: Double_t _thresh; RooCatType _cat;}; \\n         RooThreshEntry* te; \\n         auto iter = onfile._threshList.MakeIterator();\\n         while( (te = (RooThreshEntry*)iter->Next()) ) { \\n           _threshList.emplace_back(te->_thresh, te->_cat.getVal()); \\n         }\\n         delete iter;\\n         ";
      rule->fVersion     = "[1]";
      rule->fInclude     = "TSortedList.h";
      rule = &readrules[1];
      rule->fSourceClass = "RooThresholdCategory";
      rule->fTarget      = "_defIndex,_threshList";
      rule->fSource      = "RooCatType* _defCat; std::vector<std::pair<double,RooCatType>> _threshList";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooThresholdCategory_1);
      rule->fCode        = "const_cast<int&>(_defIndex) = onfile._defCat->getVal(); \\n         for (const auto& threshCatPair : onfile._threshList) { \\n           _threshList.emplace_back(threshCatPair.first, threshCatPair.second.getVal()); \\n         }\\n         ";
      rule->fVersion     = "[2]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooThresholdCategory*)
   {
      return GenerateInitInstanceLocal((::RooThresholdCategory*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooThresholdCategory*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTObjWrap(void *p = nullptr);
   static void *newArray_RooTObjWrap(Long_t size, void *p);
   static void delete_RooTObjWrap(void *p);
   static void deleteArray_RooTObjWrap(void *p);
   static void destruct_RooTObjWrap(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTObjWrap*)
   {
      ::RooTObjWrap *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTObjWrap >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTObjWrap", ::RooTObjWrap::Class_Version(), "RooTObjWrap.h", 23,
                  typeid(::RooTObjWrap), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTObjWrap::Dictionary, isa_proxy, 4,
                  sizeof(::RooTObjWrap) );
      instance.SetNew(&new_RooTObjWrap);
      instance.SetNewArray(&newArray_RooTObjWrap);
      instance.SetDelete(&delete_RooTObjWrap);
      instance.SetDeleteArray(&deleteArray_RooTObjWrap);
      instance.SetDestructor(&destruct_RooTObjWrap);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTObjWrap*)
   {
      return GenerateInitInstanceLocal((::RooTObjWrap*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTObjWrap*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTreeDataStore(void *p = nullptr);
   static void *newArray_RooTreeDataStore(Long_t size, void *p);
   static void delete_RooTreeDataStore(void *p);
   static void deleteArray_RooTreeDataStore(void *p);
   static void destruct_RooTreeDataStore(void *p);
   static void streamer_RooTreeDataStore(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTreeDataStore*)
   {
      ::RooTreeDataStore *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTreeDataStore >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTreeDataStore", ::RooTreeDataStore::Class_Version(), "RooTreeDataStore.h", 35,
                  typeid(::RooTreeDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTreeDataStore::Dictionary, isa_proxy, 17,
                  sizeof(::RooTreeDataStore) );
      instance.SetNew(&new_RooTreeDataStore);
      instance.SetNewArray(&newArray_RooTreeDataStore);
      instance.SetDelete(&delete_RooTreeDataStore);
      instance.SetDeleteArray(&deleteArray_RooTreeDataStore);
      instance.SetDestructor(&destruct_RooTreeDataStore);
      instance.SetStreamerFunc(&streamer_RooTreeDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTreeDataStore*)
   {
      return GenerateInitInstanceLocal((::RooTreeDataStore*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTreeDataStore*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooTruthModel(void *p = nullptr);
   static void *newArray_RooTruthModel(Long_t size, void *p);
   static void delete_RooTruthModel(void *p);
   static void deleteArray_RooTruthModel(void *p);
   static void destruct_RooTruthModel(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTruthModel*)
   {
      ::RooTruthModel *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTruthModel >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTruthModel", ::RooTruthModel::Class_Version(), "RooTruthModel.h", 21,
                  typeid(::RooTruthModel), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTruthModel::Dictionary, isa_proxy, 4,
                  sizeof(::RooTruthModel) );
      instance.SetNew(&new_RooTruthModel);
      instance.SetNewArray(&newArray_RooTruthModel);
      instance.SetDelete(&delete_RooTruthModel);
      instance.SetDeleteArray(&deleteArray_RooTruthModel);
      instance.SetDestructor(&destruct_RooTruthModel);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTruthModel*)
   {
      return GenerateInitInstanceLocal((::RooTruthModel*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTruthModel*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooUniformBinning(void *p = nullptr);
   static void *newArray_RooUniformBinning(Long_t size, void *p);
   static void delete_RooUniformBinning(void *p);
   static void deleteArray_RooUniformBinning(void *p);
   static void destruct_RooUniformBinning(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooUniformBinning*)
   {
      ::RooUniformBinning *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooUniformBinning >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooUniformBinning", ::RooUniformBinning::Class_Version(), "RooUniformBinning.h", 23,
                  typeid(::RooUniformBinning), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooUniformBinning::Dictionary, isa_proxy, 4,
                  sizeof(::RooUniformBinning) );
      instance.SetNew(&new_RooUniformBinning);
      instance.SetNewArray(&newArray_RooUniformBinning);
      instance.SetDelete(&delete_RooUniformBinning);
      instance.SetDeleteArray(&deleteArray_RooUniformBinning);
      instance.SetDestructor(&destruct_RooUniformBinning);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooUniformBinning*)
   {
      return GenerateInitInstanceLocal((::RooUniformBinning*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooUniformBinning*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooUnitTest(void *p);
   static void deleteArray_RooUnitTest(void *p);
   static void destruct_RooUnitTest(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooUnitTest*)
   {
      ::RooUnitTest *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooUnitTest >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooUnitTest", ::RooUnitTest::Class_Version(), "RooUnitTest.h", 37,
                  typeid(::RooUnitTest), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooUnitTest::Dictionary, isa_proxy, 4,
                  sizeof(::RooUnitTest) );
      instance.SetDelete(&delete_RooUnitTest);
      instance.SetDeleteArray(&deleteArray_RooUnitTest);
      instance.SetDestructor(&destruct_RooUnitTest);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooUnitTest*)
   {
      return GenerateInitInstanceLocal((::RooUnitTest*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooUnitTest*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStore(void *p = nullptr);
   static void *newArray_RooVectorDataStore(Long_t size, void *p);
   static void delete_RooVectorDataStore(void *p);
   static void deleteArray_RooVectorDataStore(void *p);
   static void destruct_RooVectorDataStore(void *p);
   static void streamer_RooVectorDataStore(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore*)
   {
      ::RooVectorDataStore *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore", ::RooVectorDataStore::Class_Version(), "RooVectorDataStore.h", 40,
                  typeid(::RooVectorDataStore), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore) );
      instance.SetNew(&new_RooVectorDataStore);
      instance.SetNewArray(&newArray_RooVectorDataStore);
      instance.SetDelete(&delete_RooVectorDataStore);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStore);
      instance.SetDestructor(&destruct_RooVectorDataStore);
      instance.SetStreamerFunc(&streamer_RooVectorDataStore);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLRealVector(void *p = nullptr);
   static void *newArray_RooVectorDataStorecLcLRealVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLRealVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLRealVector(void *p);
   static void destruct_RooVectorDataStorecLcLRealVector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::RealVector*)
   {
      ::RooVectorDataStore::RealVector *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::RealVector >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::RealVector", ::RooVectorDataStore::RealVector::Class_Version(), "RooVectorDataStore.h", 194,
                  typeid(::RooVectorDataStore::RealVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::RealVector::Dictionary, isa_proxy, 4,
                  sizeof(::RooVectorDataStore::RealVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLRealVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLRealVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLRealVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLRealVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLRealVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::RealVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::RealVector*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLRealFullVector(void *p = nullptr);
   static void *newArray_RooVectorDataStorecLcLRealFullVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLRealFullVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLRealFullVector(void *p);
   static void destruct_RooVectorDataStorecLcLRealFullVector(void *p);
   static void streamer_RooVectorDataStorecLcLRealFullVector(TBuffer &buf, void *obj);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::RealFullVector*)
   {
      ::RooVectorDataStore::RealFullVector *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::RealFullVector >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::RealFullVector", ::RooVectorDataStore::RealFullVector::Class_Version(), "RooVectorDataStore.h", 344,
                  typeid(::RooVectorDataStore::RealFullVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::RealFullVector::Dictionary, isa_proxy, 17,
                  sizeof(::RooVectorDataStore::RealFullVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLRealFullVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLRealFullVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLRealFullVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLRealFullVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLRealFullVector);
      instance.SetStreamerFunc(&streamer_RooVectorDataStorecLcLRealFullVector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::RealFullVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::RealFullVector*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooVectorDataStorecLcLCatVector(void *p = nullptr);
   static void *newArray_RooVectorDataStorecLcLCatVector(Long_t size, void *p);
   static void delete_RooVectorDataStorecLcLCatVector(void *p);
   static void deleteArray_RooVectorDataStorecLcLCatVector(void *p);
   static void destruct_RooVectorDataStorecLcLCatVector(void *p);

   // Schema evolution read functions
   static void read_RooVectorDataStorecLcLCatVector_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id__vec = oldObj->GetId("_vec");
#endif
      struct RooVectorDataStorecLcLCatVector_Onfile {
         std::vector<RooCatType> &_vec;
         RooVectorDataStorecLcLCatVector_Onfile(std::vector<RooCatType> &onfile__vec ): _vec(onfile__vec) {}
      };
      static Long_t offset_Onfile_RooVectorDataStorecLcLCatVector__vec = oldObj->GetClass()->GetDataMemberOffset("_vec");
      char *onfile_add = (char*)oldObj->GetObject();
      RooVectorDataStorecLcLCatVector_Onfile onfile(
         *(std::vector<RooCatType>*)(onfile_add+offset_Onfile_RooVectorDataStorecLcLCatVector__vec) );

      static TClassRef cls("RooVectorDataStore::CatVector");
      static Long_t offset__vec = cls->GetDataMemberOffset("_vec");
      vector<RooAbsCategory::value_type>& _vec = *(vector<RooAbsCategory::value_type>*)(target+offset__vec);
      RooVectorDataStore::CatVector* newObj = (RooVectorDataStore::CatVector*)target;
      // Supress warning message.
      (void)oldObj;

      (void)newObj;

      //--- User's code ---
     _vec.reserve(onfile._vec.size()); for (const auto& cat : onfile._vec) { _vec.push_back(cat.getVal()); } 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooVectorDataStore::CatVector*)
   {
      ::RooVectorDataStore::CatVector *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooVectorDataStore::CatVector >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooVectorDataStore::CatVector", ::RooVectorDataStore::CatVector::Class_Version(), "RooVectorDataStore.h", 531,
                  typeid(::RooVectorDataStore::CatVector), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooVectorDataStore::CatVector::Dictionary, isa_proxy, 4,
                  sizeof(::RooVectorDataStore::CatVector) );
      instance.SetNew(&new_RooVectorDataStorecLcLCatVector);
      instance.SetNewArray(&newArray_RooVectorDataStorecLcLCatVector);
      instance.SetDelete(&delete_RooVectorDataStorecLcLCatVector);
      instance.SetDeleteArray(&deleteArray_RooVectorDataStorecLcLCatVector);
      instance.SetDestructor(&destruct_RooVectorDataStorecLcLCatVector);

      ::ROOT::Internal::TSchemaHelper* rule;

      // the io read rules
      std::vector<::ROOT::Internal::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "RooVectorDataStore::CatVector";
      rule->fTarget      = "_vec";
      rule->fSource      = "std::vector<RooCatType> _vec;";
      rule->fFunctionPtr = (void *)TFunc2void( read_RooVectorDataStorecLcLCatVector_0);
      rule->fCode        = "_vec.reserve(onfile._vec.size()); for (const auto& cat : onfile._vec) { _vec.push_back(cat.getVal()); } ";
      rule->fVersion     = "[1]";
      rule->fInclude     = "RooFitLegacy/RooCatTypeLegacy.h";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooVectorDataStore::CatVector*)
   {
      return GenerateInitInstanceLocal((::RooVectorDataStore::CatVector*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooWorkspaceHandle(void *p);
   static void deleteArray_RooWorkspaceHandle(void *p);
   static void destruct_RooWorkspaceHandle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWorkspaceHandle*)
   {
      ::RooWorkspaceHandle *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWorkspaceHandle >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooWorkspaceHandle", ::RooWorkspaceHandle::Class_Version(), "RooWorkspaceHandle.h", 21,
                  typeid(::RooWorkspaceHandle), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWorkspaceHandle::Dictionary, isa_proxy, 4,
                  sizeof(::RooWorkspaceHandle) );
      instance.SetDelete(&delete_RooWorkspaceHandle);
      instance.SetDeleteArray(&deleteArray_RooWorkspaceHandle);
      instance.SetDestructor(&destruct_RooWorkspaceHandle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWorkspaceHandle*)
   {
      return GenerateInitInstanceLocal((::RooWorkspaceHandle*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWorkspaceHandle*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooXYChi2Var(void *p = nullptr);
   static void *newArray_RooXYChi2Var(Long_t size, void *p);
   static void delete_RooXYChi2Var(void *p);
   static void deleteArray_RooXYChi2Var(void *p);
   static void destruct_RooXYChi2Var(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooXYChi2Var*)
   {
      ::RooXYChi2Var *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooXYChi2Var >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooXYChi2Var", ::RooXYChi2Var::Class_Version(), "RooXYChi2Var.h", 29,
                  typeid(::RooXYChi2Var), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooXYChi2Var::Dictionary, isa_proxy, 4,
                  sizeof(::RooXYChi2Var) );
      instance.SetNew(&new_RooXYChi2Var);
      instance.SetNewArray(&newArray_RooXYChi2Var);
      instance.SetDelete(&delete_RooXYChi2Var);
      instance.SetDeleteArray(&deleteArray_RooXYChi2Var);
      instance.SetDestructor(&destruct_RooXYChi2Var);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooXYChi2Var*)
   {
      return GenerateInitInstanceLocal((::RooXYChi2Var*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooXYChi2Var*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooWrapperPdf(void *p = nullptr);
   static void *newArray_RooWrapperPdf(Long_t size, void *p);
   static void delete_RooWrapperPdf(void *p);
   static void deleteArray_RooWrapperPdf(void *p);
   static void destruct_RooWrapperPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooWrapperPdf*)
   {
      ::RooWrapperPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooWrapperPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooWrapperPdf", ::RooWrapperPdf::Class_Version(), "RooWrapperPdf.h", 24,
                  typeid(::RooWrapperPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooWrapperPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooWrapperPdf) );
      instance.SetNew(&new_RooWrapperPdf);
      instance.SetNewArray(&newArray_RooWrapperPdf);
      instance.SetDelete(&delete_RooWrapperPdf);
      instance.SetDeleteArray(&deleteArray_RooWrapperPdf);
      instance.SetDestructor(&destruct_RooWrapperPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooWrapperPdf*)
   {
      return GenerateInitInstanceLocal((::RooWrapperPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooWrapperPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinSamplingPdf(void *p = nullptr);
   static void *newArray_RooBinSamplingPdf(Long_t size, void *p);
   static void delete_RooBinSamplingPdf(void *p);
   static void deleteArray_RooBinSamplingPdf(void *p);
   static void destruct_RooBinSamplingPdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinSamplingPdf*)
   {
      ::RooBinSamplingPdf *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinSamplingPdf >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinSamplingPdf", ::RooBinSamplingPdf::Class_Version(), "RooBinSamplingPdf.h", 28,
                  typeid(::RooBinSamplingPdf), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinSamplingPdf::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinSamplingPdf) );
      instance.SetNew(&new_RooBinSamplingPdf);
      instance.SetNewArray(&newArray_RooBinSamplingPdf);
      instance.SetDelete(&delete_RooBinSamplingPdf);
      instance.SetDeleteArray(&deleteArray_RooBinSamplingPdf);
      instance.SetDestructor(&destruct_RooBinSamplingPdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinSamplingPdf*)
   {
      return GenerateInitInstanceLocal((::RooBinSamplingPdf*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinSamplingPdf*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooBinWidthFunction(void *p = nullptr);
   static void *newArray_RooBinWidthFunction(Long_t size, void *p);
   static void delete_RooBinWidthFunction(void *p);
   static void deleteArray_RooBinWidthFunction(void *p);
   static void destruct_RooBinWidthFunction(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooBinWidthFunction*)
   {
      ::RooBinWidthFunction *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooBinWidthFunction >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooBinWidthFunction", ::RooBinWidthFunction::Class_Version(), "RooBinWidthFunction.h", 27,
                  typeid(::RooBinWidthFunction), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooBinWidthFunction::Dictionary, isa_proxy, 4,
                  sizeof(::RooBinWidthFunction) );
      instance.SetNew(&new_RooBinWidthFunction);
      instance.SetNewArray(&newArray_RooBinWidthFunction);
      instance.SetDelete(&delete_RooBinWidthFunction);
      instance.SetDeleteArray(&deleteArray_RooBinWidthFunction);
      instance.SetDestructor(&destruct_RooBinWidthFunction);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooBinWidthFunction*)
   {
      return GenerateInitInstanceLocal((::RooBinWidthFunction*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooBinWidthFunction*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooCategorySharedProperties(void *p = nullptr);
   static void *newArray_RooCategorySharedProperties(Long_t size, void *p);
   static void delete_RooCategorySharedProperties(void *p);
   static void deleteArray_RooCategorySharedProperties(void *p);
   static void destruct_RooCategorySharedProperties(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooCategorySharedProperties*)
   {
      ::RooCategorySharedProperties *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooCategorySharedProperties >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooCategorySharedProperties", ::RooCategorySharedProperties::Class_Version(), "RooFitLegacy/RooCategorySharedProperties.h", 34,
                  typeid(::RooCategorySharedProperties), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooCategorySharedProperties::Dictionary, isa_proxy, 4,
                  sizeof(::RooCategorySharedProperties) );
      instance.SetNew(&new_RooCategorySharedProperties);
      instance.SetNewArray(&newArray_RooCategorySharedProperties);
      instance.SetDelete(&delete_RooCategorySharedProperties);
      instance.SetDeleteArray(&deleteArray_RooCategorySharedProperties);
      instance.SetDestructor(&destruct_RooCategorySharedProperties);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooCategorySharedProperties*)
   {
      return GenerateInitInstanceLocal((::RooCategorySharedProperties*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooHashTable(void *p = nullptr);
   static void *newArray_RooHashTable(Long_t size, void *p);
   static void delete_RooHashTable(void *p);
   static void deleteArray_RooHashTable(void *p);
   static void destruct_RooHashTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooHashTable*)
   {
      ::RooHashTable *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooHashTable >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooHashTable", ::RooHashTable::Class_Version(), "RooFitLegacy/RooHashTable.h", 30,
                  typeid(::RooHashTable), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooHashTable::Dictionary, isa_proxy, 4,
                  sizeof(::RooHashTable) );
      instance.SetNew(&new_RooHashTable);
      instance.SetNewArray(&newArray_RooHashTable);
      instance.SetDelete(&delete_RooHashTable);
      instance.SetDeleteArray(&deleteArray_RooHashTable);
      instance.SetDestructor(&destruct_RooHashTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooHashTable*)
   {
      return GenerateInitInstanceLocal((::RooHashTable*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooHashTable*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooMinuit(void *p);
   static void deleteArray_RooMinuit(void *p);
   static void destruct_RooMinuit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooMinuit*)
   {
      ::RooMinuit *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooMinuit >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooMinuit", ::RooMinuit::Class_Version(), "RooFitLegacy/RooMinuit.h", 41,
                  typeid(::RooMinuit), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooMinuit::Dictionary, isa_proxy, 4,
                  sizeof(::RooMinuit) );
      instance.SetDelete(&delete_RooMinuit);
      instance.SetDeleteArray(&deleteArray_RooMinuit);
      instance.SetDestructor(&destruct_RooMinuit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooMinuit*)
   {
      return GenerateInitInstanceLocal((::RooMinuit*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooMinuit*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooNameSet(void *p = nullptr);
   static void *newArray_RooNameSet(Long_t size, void *p);
   static void delete_RooNameSet(void *p);
   static void deleteArray_RooNameSet(void *p);
   static void destruct_RooNameSet(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooNameSet*)
   {
      ::RooNameSet *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooNameSet >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooNameSet", ::RooNameSet::Class_Version(), "RooFitLegacy/RooNameSet.h", 26,
                  typeid(::RooNameSet), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooNameSet::Dictionary, isa_proxy, 4,
                  sizeof(::RooNameSet) );
      instance.SetNew(&new_RooNameSet);
      instance.SetNewArray(&newArray_RooNameSet);
      instance.SetDelete(&delete_RooNameSet);
      instance.SetDeleteArray(&deleteArray_RooNameSet);
      instance.SetDestructor(&destruct_RooNameSet);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooNameSet*)
   {
      return GenerateInitInstanceLocal((::RooNameSet*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooNameSet*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void *new_RooSetPair(void *p = nullptr);
   static void *newArray_RooSetPair(Long_t size, void *p);
   static void delete_RooSetPair(void *p);
   static void deleteArray_RooSetPair(void *p);
   static void destruct_RooSetPair(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooSetPair*)
   {
      ::RooSetPair *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooSetPair >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooSetPair", ::RooSetPair::Class_Version(), "RooFitLegacy/RooSetPair.h", 26,
                  typeid(::RooSetPair), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooSetPair::Dictionary, isa_proxy, 4,
                  sizeof(::RooSetPair) );
      instance.SetNew(&new_RooSetPair);
      instance.SetNewArray(&newArray_RooSetPair);
      instance.SetDelete(&delete_RooSetPair);
      instance.SetDeleteArray(&deleteArray_RooSetPair);
      instance.SetDestructor(&destruct_RooSetPair);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooSetPair*)
   {
      return GenerateInitInstanceLocal((::RooSetPair*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooSetPair*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooTreeData(void *p);
   static void deleteArray_RooTreeData(void *p);
   static void destruct_RooTreeData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooTreeData*)
   {
      ::RooTreeData *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooTreeData >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooTreeData", ::RooTreeData::Class_Version(), "RooFitLegacy/RooTreeData.h", 25,
                  typeid(::RooTreeData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooTreeData::Dictionary, isa_proxy, 4,
                  sizeof(::RooTreeData) );
      instance.SetDelete(&delete_RooTreeData);
      instance.SetDeleteArray(&deleteArray_RooTreeData);
      instance.SetDestructor(&destruct_RooTreeData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooTreeData*)
   {
      return GenerateInitInstanceLocal((::RooTreeData*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooTreeData*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

namespace ROOT {
   static void delete_RooFitcLcLTestStatisticscLcLRooRealL(void *p);
   static void deleteArray_RooFitcLcLTestStatisticscLcLRooRealL(void *p);
   static void destruct_RooFitcLcLTestStatisticscLcLRooRealL(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::RooFit::TestStatistics::RooRealL*)
   {
      ::RooFit::TestStatistics::RooRealL *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::RooFit::TestStatistics::RooRealL >(nullptr);
      static ::ROOT::TGenericClassInfo 
         instance("RooFit::TestStatistics::RooRealL", ::RooFit::TestStatistics::RooRealL::Class_Version(), "RooFit/TestStatistics/RooRealL.h", 28,
                  typeid(::RooFit::TestStatistics::RooRealL), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &::RooFit::TestStatistics::RooRealL::Dictionary, isa_proxy, 4,
                  sizeof(::RooFit::TestStatistics::RooRealL) );
      instance.SetDelete(&delete_RooFitcLcLTestStatisticscLcLRooRealL);
      instance.SetDeleteArray(&deleteArray_RooFitcLcLTestStatisticscLcLRooRealL);
      instance.SetDestructor(&destruct_RooFitcLcLTestStatisticscLcLRooRealL);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::RooFit::TestStatistics::RooRealL*)
   {
      return GenerateInitInstanceLocal((::RooFit::TestStatistics::RooRealL*)nullptr);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const ::RooFit::TestStatistics::RooRealL*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));
} // end of namespace ROOT

//______________________________________________________________________________
atomic_TClass_ptr RooPrintable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPrintable::Class_Name()
{
   return "RooPrintable";
}

//______________________________________________________________________________
const char *RooPrintable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPrintable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPrintable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPrintable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPrintable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooSTLRefCountList<RooAbsArg>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooSTLRefCountList<RooAbsArg>::Class_Name()
{
   return "RooSTLRefCountList<RooAbsArg>";
}

//______________________________________________________________________________
template <> const char *RooSTLRefCountList<RooAbsArg>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooSTLRefCountList<RooAbsArg>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooSTLRefCountList<RooAbsArg>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooSTLRefCountList<RooAbsArg>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSTLRefCountList<RooAbsArg>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCache::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCache::Class_Name()
{
   return "RooAbsCache";
}

//______________________________________________________________________________
const char *RooAbsCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCache*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinkedListElem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinkedListElem::Class_Name()
{
   return "RooLinkedListElem";
}

//______________________________________________________________________________
const char *RooLinkedListElem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinkedListElem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinkedListElem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinkedListElem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedListElem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinkedList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinkedList::Class_Name()
{
   return "RooLinkedList";
}

//______________________________________________________________________________
const char *RooLinkedList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinkedList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinkedList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinkedList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinkedList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRefArray::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRefArray::Class_Name()
{
   return "RooRefArray";
}

//______________________________________________________________________________
const char *RooRefArray::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRefArray::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRefArray::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRefArray::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefArray*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsArg::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsArg::Class_Name()
{
   return "RooAbsArg";
}

//______________________________________________________________________________
const char *RooAbsArg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsArg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsArg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsArg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsArg*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCatType::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCatType::Class_Name()
{
   return "RooCatType";
}

//______________________________________________________________________________
const char *RooCatType::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCatType::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCatType::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCatType::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCatType*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCategory::Class_Name()
{
   return "RooAbsCategory";
}

//______________________________________________________________________________
const char *RooAbsCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTable::Class_Name()
{
   return "RooTable";
}

//______________________________________________________________________________
const char *RooTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr Roo1DTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *Roo1DTable::Class_Name()
{
   return "Roo1DTable";
}

//______________________________________________________________________________
const char *Roo1DTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int Roo1DTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *Roo1DTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *Roo1DTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::Roo1DTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCmdArg::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCmdArg::Class_Name()
{
   return "RooCmdArg";
}

//______________________________________________________________________________
const char *RooCmdArg::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCmdArg::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCmdArg::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCmdArg::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdArg*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPlotable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPlotable::Class_Name()
{
   return "RooPlotable";
}

//______________________________________________________________________________
const char *RooPlotable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPlotable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPlotable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPlotable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlotable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCurve::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCurve::Class_Name()
{
   return "RooCurve";
}

//______________________________________________________________________________
const char *RooCurve::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCurve::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCurve::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCurve::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCurve*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCollection::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCollection::Class_Name()
{
   return "RooAbsCollection";
}

//______________________________________________________________________________
const char *RooAbsCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCollection::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCollection*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgSet::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgSet::Class_Name()
{
   return "RooArgSet";
}

//______________________________________________________________________________
const char *RooArgSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgSet*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgList::Class_Name()
{
   return "RooArgList";
}

//______________________________________________________________________________
const char *RooArgList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsReal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsReal::Class_Name()
{
   return "RooAbsReal";
}

//______________________________________________________________________________
const char *RooAbsReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsReal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNormSetCache::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNormSetCache::Class_Name()
{
   return "RooNormSetCache";
}

//______________________________________________________________________________
const char *RooNormSetCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNormSetCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNormSetCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNormSetCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNormSetCache*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCacheElement::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCacheElement::Class_Name()
{
   return "RooAbsCacheElement";
}

//______________________________________________________________________________
const char *RooAbsCacheElement::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCacheElement::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCacheElement::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCacheElement::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCacheElement*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMsgService::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMsgService::Class_Name()
{
   return "RooMsgService";
}

//______________________________________________________________________________
const char *RooMsgService::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMsgService::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMsgService::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMsgService::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMsgService*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooCacheManager<RooAbsCacheElement>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooCacheManager<RooAbsCacheElement>::Class_Name()
{
   return "RooCacheManager<RooAbsCacheElement>";
}

//______________________________________________________________________________
template <> const char *RooCacheManager<RooAbsCacheElement>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooCacheManager<RooAbsCacheElement>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<RooAbsCacheElement>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<RooAbsCacheElement>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<RooAbsCacheElement>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooCacheManager<vector<double> >::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooCacheManager<vector<double> >::Class_Name()
{
   return "RooCacheManager<vector<double> >";
}

//______________________________________________________________________________
template <> const char *RooCacheManager<vector<double> >::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooCacheManager<vector<double> >::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<vector<double> >::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooCacheManager<vector<double> >::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCacheManager<vector<double> >*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooObjCacheManager::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooObjCacheManager::Class_Name()
{
   return "RooObjCacheManager";
}

//______________________________________________________________________________
const char *RooObjCacheManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooObjCacheManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooObjCacheManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooObjCacheManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooObjCacheManager*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsPdf::Class_Name()
{
   return "RooAbsPdf";
}

//______________________________________________________________________________
const char *RooAbsPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsPdf::GenSpec::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsPdf::GenSpec::Class_Name()
{
   return "RooAbsPdf::GenSpec";
}

//______________________________________________________________________________
const char *RooAbsPdf::GenSpec::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsPdf::GenSpec::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsPdf::GenSpec::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsPdf::GenSpec::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsPdf::GenSpec*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsProxy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsProxy::Class_Name()
{
   return "RooAbsProxy";
}

//______________________________________________________________________________
const char *RooAbsProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsProxy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooArgProxy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooArgProxy::Class_Name()
{
   return "RooArgProxy";
}

//______________________________________________________________________________
const char *RooArgProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooArgProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooArgProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooArgProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooArgProxy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumber::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumber::Class_Name()
{
   return "RooNumber";
}

//______________________________________________________________________________
const char *RooNumber::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumber::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumber::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumber::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumber*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsLValue::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsLValue::Class_Name()
{
   return "RooAbsLValue";
}

//______________________________________________________________________________
const char *RooAbsLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsLValue*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsBinning::Class_Name()
{
   return "RooAbsBinning";
}

//______________________________________________________________________________
const char *RooAbsBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsRealLValue::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsRealLValue::Class_Name()
{
   return "RooAbsRealLValue";
}

//______________________________________________________________________________
const char *RooAbsRealLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsRealLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsRealLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsRealLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRealLValue*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooAbsReal>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsReal>::Class_Name()
{
   return "RooTemplateProxy<RooAbsReal>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsReal>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooAbsReal>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsReal>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsReal>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsReal>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooAbsCategory>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsCategory>::Class_Name()
{
   return "RooTemplateProxy<RooAbsCategory>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsCategory>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooAbsCategory>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsCategory>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsCategory>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategory>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooAbsRealLValue>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsRealLValue>::Class_Name()
{
   return "RooTemplateProxy<RooAbsRealLValue>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsRealLValue>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooAbsRealLValue>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsRealLValue>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsRealLValue>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsRealLValue>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooAbsPdf>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsPdf>::Class_Name()
{
   return "RooTemplateProxy<RooAbsPdf>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsPdf>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooAbsPdf>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsPdf>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsPdf>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsPdf>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooRealVar>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooRealVar>::Class_Name()
{
   return "RooTemplateProxy<RooRealVar>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooRealVar>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooRealVar>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooRealVar>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooRealVar>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooRealVar>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooMultiCategory>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooMultiCategory>::Class_Name()
{
   return "RooTemplateProxy<RooMultiCategory>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooMultiCategory>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooMultiCategory>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooMultiCategory>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooMultiCategory>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooMultiCategory>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<const RooHistFunc>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<const RooHistFunc>::Class_Name()
{
   return "RooTemplateProxy<const RooHistFunc>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<const RooHistFunc>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<const RooHistFunc>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<const RooHistFunc>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<const RooHistFunc>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<const RooHistFunc>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooAbsCategoryLValue>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsCategoryLValue>::Class_Name()
{
   return "RooTemplateProxy<RooAbsCategoryLValue>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooAbsCategoryLValue>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooAbsCategoryLValue>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsCategoryLValue>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooAbsCategoryLValue>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooAbsCategoryLValue>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
template <> atomic_TClass_ptr RooTemplateProxy<RooHistFunc>::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooHistFunc>::Class_Name()
{
   return "RooTemplateProxy<RooHistFunc>";
}

//______________________________________________________________________________
template <> const char *RooTemplateProxy<RooHistFunc>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
template <> int RooTemplateProxy<RooHistFunc>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooHistFunc>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *RooTemplateProxy<RooHistFunc>::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTemplateProxy<RooHistFunc>*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooListProxy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooListProxy::Class_Name()
{
   return "RooListProxy";
}

//______________________________________________________________________________
const char *RooListProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooListProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooListProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooListProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooListProxy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsData::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsData::Class_Name()
{
   return "RooAbsData";
}

//______________________________________________________________________________
const char *RooAbsData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsData*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDirItem::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDirItem::Class_Name()
{
   return "RooDirItem";
}

//______________________________________________________________________________
const char *RooDirItem::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDirItem::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDirItem::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDirItem::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDirItem*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataSet::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataSet::Class_Name()
{
   return "RooDataSet";
}

//______________________________________________________________________________
const char *RooDataSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataSet*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAICRegistry::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAICRegistry::Class_Name()
{
   return "RooAICRegistry";
}

//______________________________________________________________________________
const char *RooAICRegistry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAICRegistry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAICRegistry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAICRegistry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAICRegistry*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsAnaConvPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsAnaConvPdf::Class_Name()
{
   return "RooAbsAnaConvPdf";
}

//______________________________________________________________________________
const char *RooAbsAnaConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsAnaConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsAnaConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsAnaConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsAnaConvPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSetProxy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSetProxy::Class_Name()
{
   return "RooSetProxy";
}

//______________________________________________________________________________
const char *RooSetProxy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSetProxy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSetProxy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSetProxy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetProxy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistPdf::Class_Name()
{
   return "RooHistPdf";
}

//______________________________________________________________________________
const char *RooHistPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooChangeTracker::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooChangeTracker::Class_Name()
{
   return "RooChangeTracker";
}

//______________________________________________________________________________
const char *RooChangeTracker::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooChangeTracker::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooChangeTracker::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooChangeTracker::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChangeTracker*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCachedPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCachedPdf::Class_Name()
{
   return "RooAbsCachedPdf";
}

//______________________________________________________________________________
const char *RooAbsCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTrace::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTrace::Class_Name()
{
   return "RooTrace";
}

//______________________________________________________________________________
const char *RooTrace::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTrace::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTrace::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTrace::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTrace*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistFunc::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistFunc::Class_Name()
{
   return "RooHistFunc";
}

//______________________________________________________________________________
const char *RooHistFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistFunc*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCachedReal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCachedReal::Class_Name()
{
   return "RooAbsCachedReal";
}

//______________________________________________________________________________
const char *RooAbsCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCachedReal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsCategoryLValue::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsCategoryLValue::Class_Name()
{
   return "RooAbsCategoryLValue";
}

//______________________________________________________________________________
const char *RooAbsCategoryLValue::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsCategoryLValue::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsCategoryLValue::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsCategoryLValue::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsCategoryLValue*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsDataStore::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsDataStore::Class_Name()
{
   return "RooAbsDataStore";
}

//______________________________________________________________________________
const char *RooAbsDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsDataStore*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsFunc::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsFunc::Class_Name()
{
   return "RooAbsFunc";
}

//______________________________________________________________________________
const char *RooAbsFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsFunc*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsGenContext::Class_Name()
{
   return "RooAbsGenContext";
}

//______________________________________________________________________________
const char *RooAbsGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsHiddenReal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsHiddenReal::Class_Name()
{
   return "RooAbsHiddenReal";
}

//______________________________________________________________________________
const char *RooAbsHiddenReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsHiddenReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsHiddenReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsHiddenReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsHiddenReal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCategory::Class_Name()
{
   return "RooCategory";
}

//______________________________________________________________________________
const char *RooCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumIntConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumIntConfig::Class_Name()
{
   return "RooNumIntConfig";
}

//______________________________________________________________________________
const char *RooNumIntConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumIntConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumIntConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumIntConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsIntegrator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsIntegrator::Class_Name()
{
   return "RooAbsIntegrator";
}

//______________________________________________________________________________
const char *RooAbsIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsIntegrator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMCStudy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMCStudy::Class_Name()
{
   return "RooMCStudy";
}

//______________________________________________________________________________
const char *RooMCStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMCStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMCStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMCStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCStudy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsMCStudyModule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsMCStudyModule::Class_Name()
{
   return "RooAbsMCStudyModule";
}

//______________________________________________________________________________
const char *RooAbsMCStudyModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsMCStudyModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsMCStudyModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsMCStudyModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMCStudyModule*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealVar::Class_Name()
{
   return "RooRealVar";
}

//______________________________________________________________________________
const char *RooRealVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsMoment::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsMoment::Class_Name()
{
   return "RooAbsMoment";
}

//______________________________________________________________________________
const char *RooAbsMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsMoment*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsNumGenerator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsNumGenerator::Class_Name()
{
   return "RooAbsNumGenerator";
}

//______________________________________________________________________________
const char *RooAbsNumGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsNumGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsNumGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsNumGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsNumGenerator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsTestStatistic::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsTestStatistic::Class_Name()
{
   return "RooAbsTestStatistic";
}

//______________________________________________________________________________
const char *RooAbsTestStatistic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsTestStatistic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsTestStatistic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsTestStatistic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsTestStatistic*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsOptTestStatistic::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsOptTestStatistic::Class_Name()
{
   return "RooAbsOptTestStatistic";
}

//______________________________________________________________________________
const char *RooAbsOptTestStatistic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsOptTestStatistic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsOptTestStatistic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsOptTestStatistic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsOptTestStatistic*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsRootFinder::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsRootFinder::Class_Name()
{
   return "RooAbsRootFinder";
}

//______________________________________________________________________________
const char *RooAbsRootFinder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsRootFinder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsRootFinder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsRootFinder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsRootFinder*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsSelfCachedPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsSelfCachedPdf::Class_Name()
{
   return "RooAbsSelfCachedPdf";
}

//______________________________________________________________________________
const char *RooAbsSelfCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsSelfCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsSelfCachedReal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsSelfCachedReal::Class_Name()
{
   return "RooAbsSelfCachedReal";
}

//______________________________________________________________________________
const char *RooAbsSelfCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsSelfCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsSelfCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsSelfCachedReal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStringVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStringVar::Class_Name()
{
   return "RooStringVar";
}

//______________________________________________________________________________
const char *RooStringVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooStringVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStringVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStringVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStringVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAbsStudy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAbsStudy::Class_Name()
{
   return "RooAbsStudy";
}

//______________________________________________________________________________
const char *RooAbsStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAbsStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAbsStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAbsStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAbsStudy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAcceptReject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAcceptReject::Class_Name()
{
   return "RooAcceptReject";
}

//______________________________________________________________________________
const char *RooAcceptReject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAcceptReject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAcceptReject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAcceptReject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAcceptReject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAdaptiveIntegratorND::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAdaptiveIntegratorND::Class_Name()
{
   return "RooAdaptiveIntegratorND";
}

//______________________________________________________________________________
const char *RooAdaptiveIntegratorND::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAdaptiveIntegratorND::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAdaptiveIntegratorND::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAdaptiveIntegratorND::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAdaptiveIntegratorND*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddPdf::Class_Name()
{
   return "RooAddPdf";
}

//______________________________________________________________________________
const char *RooAddPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFormula::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFormula::Class_Name()
{
   return "RooFormula";
}

//______________________________________________________________________________
const char *RooFormula::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFormula::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFormula::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFormula::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormula*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFormulaVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFormulaVar::Class_Name()
{
   return "RooFormulaVar";
}

//______________________________________________________________________________
const char *RooFormulaVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFormulaVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFormulaVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFormulaVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFormulaVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooResolutionModel::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooResolutionModel::Class_Name()
{
   return "RooResolutionModel";
}

//______________________________________________________________________________
const char *RooResolutionModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooResolutionModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooResolutionModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooResolutionModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooResolutionModel*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddModel::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddModel::Class_Name()
{
   return "RooAddModel";
}

//______________________________________________________________________________
const char *RooAddModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddModel*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddGenContext::Class_Name()
{
   return "RooAddGenContext";
}

//______________________________________________________________________________
const char *RooAddGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooAddition::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooAddition::Class_Name()
{
   return "RooAddition";
}

//______________________________________________________________________________
const char *RooAddition::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooAddition::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooAddition::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooAddition::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooAddition*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinIntegrator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinIntegrator::Class_Name()
{
   return "RooBinIntegrator";
}

//______________________________________________________________________________
const char *RooBinIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinIntegrator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinnedGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinnedGenContext::Class_Name()
{
   return "RooBinnedGenContext";
}

//______________________________________________________________________________
const char *RooBinnedGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinnedGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinnedGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinnedGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinnedGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinningCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinningCategory::Class_Name()
{
   return "RooBinningCategory";
}

//______________________________________________________________________________
const char *RooBinningCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinningCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinningCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinningCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinningCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDouble::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDouble::Class_Name()
{
   return "RooDouble";
}

//______________________________________________________________________________
const char *RooDouble::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDouble::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDouble::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDouble::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDouble*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinning::Class_Name()
{
   return "RooBinning";
}

//______________________________________________________________________________
const char *RooBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBrentRootFinder::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBrentRootFinder::Class_Name()
{
   return "RooBrentRootFinder";
}

//______________________________________________________________________________
const char *RooBrentRootFinder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBrentRootFinder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBrentRootFinder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBrentRootFinder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBrentRootFinder*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCachedPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCachedPdf::Class_Name()
{
   return "RooCachedPdf";
}

//______________________________________________________________________________
const char *RooCachedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCachedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCachedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCachedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCachedReal::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCachedReal::Class_Name()
{
   return "RooCachedReal";
}

//______________________________________________________________________________
const char *RooCachedReal::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCachedReal::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCachedReal::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCachedReal::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCachedReal*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataHist::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataHist::Class_Name()
{
   return "RooDataHist";
}

//______________________________________________________________________________
const char *RooDataHist::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataHist::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataHist::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataHist::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHist*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooChi2Var::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooChi2Var::Class_Name()
{
   return "RooChi2Var";
}

//______________________________________________________________________________
const char *RooChi2Var::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooChi2Var::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooChi2Var::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooChi2Var::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooChi2Var*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFactoryWSTool::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFactoryWSTool::Class_Name()
{
   return "RooFactoryWSTool";
}

//______________________________________________________________________________
const char *RooFactoryWSTool::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFactoryWSTool::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFactoryWSTool::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFactoryWSTool::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFactoryWSTool*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooClassFactory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooClassFactory::Class_Name()
{
   return "RooClassFactory";
}

//______________________________________________________________________________
const char *RooClassFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooClassFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooClassFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooClassFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooClassFactory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCmdConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCmdConfig::Class_Name()
{
   return "RooCmdConfig";
}

//______________________________________________________________________________
const char *RooCmdConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCmdConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCmdConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCmdConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCmdConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCompositeDataStore::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCompositeDataStore::Class_Name()
{
   return "RooCompositeDataStore";
}

//______________________________________________________________________________
const char *RooCompositeDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCompositeDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCompositeDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCompositeDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCompositeDataStore*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConstraintSum::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConstraintSum::Class_Name()
{
   return "RooConstraintSum";
}

//______________________________________________________________________________
const char *RooConstraintSum::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooConstraintSum::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConstraintSum::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConstraintSum::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstraintSum*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConstVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConstVar::Class_Name()
{
   return "RooConstVar";
}

//______________________________________________________________________________
const char *RooConstVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooConstVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConstVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConstVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConstVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvCoefVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvCoefVar::Class_Name()
{
   return "RooConvCoefVar";
}

//______________________________________________________________________________
const char *RooConvCoefVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvCoefVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvCoefVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvCoefVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvCoefVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvGenContext::Class_Name()
{
   return "RooConvGenContext";
}

//______________________________________________________________________________
const char *RooConvGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooConvIntegrandBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooConvIntegrandBinding::Class_Name()
{
   return "RooConvIntegrandBinding";
}

//______________________________________________________________________________
const char *RooConvIntegrandBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooConvIntegrandBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooConvIntegrandBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooConvIntegrandBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooConvIntegrandBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCustomizer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCustomizer::Class_Name()
{
   return "RooCustomizer";
}

//______________________________________________________________________________
const char *RooCustomizer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCustomizer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCustomizer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCustomizer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCustomizer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataHistSliceIter::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataHistSliceIter::Class_Name()
{
   return "RooDataHistSliceIter";
}

//______________________________________________________________________________
const char *RooDataHistSliceIter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataHistSliceIter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataHistSliceIter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataHistSliceIter::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataHistSliceIter*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealBinding::Class_Name()
{
   return "RooRealBinding";
}

//______________________________________________________________________________
const char *RooRealBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataProjBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataProjBinding::Class_Name()
{
   return "RooDataProjBinding";
}

//______________________________________________________________________________
const char *RooDataProjBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataProjBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataProjBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataProjBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataProjBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDataWeightedAverage::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDataWeightedAverage::Class_Name()
{
   return "RooDataWeightedAverage";
}

//______________________________________________________________________________
const char *RooDataWeightedAverage::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDataWeightedAverage::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDataWeightedAverage::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDataWeightedAverage::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDataWeightedAverage*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDerivative::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDerivative::Class_Name()
{
   return "RooDerivative";
}

//______________________________________________________________________________
const char *RooDerivative::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDerivative::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDerivative::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDerivative::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDerivative*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooDLLSignificanceMCSModule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooDLLSignificanceMCSModule::Class_Name()
{
   return "RooDLLSignificanceMCSModule";
}

//______________________________________________________________________________
const char *RooDLLSignificanceMCSModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooDLLSignificanceMCSModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooDLLSignificanceMCSModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooDLLSignificanceMCSModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooDLLSignificanceMCSModule*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEffGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEffGenContext::Class_Name()
{
   return "RooEffGenContext";
}

//______________________________________________________________________________
const char *RooEffGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooEffGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEffGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEffGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEfficiency::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEfficiency::Class_Name()
{
   return "RooEfficiency";
}

//______________________________________________________________________________
const char *RooEfficiency::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooEfficiency::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEfficiency::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEfficiency::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEfficiency*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEffProd::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEffProd::Class_Name()
{
   return "RooEffProd";
}

//______________________________________________________________________________
const char *RooEffProd::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooEffProd::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEffProd::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEffProd::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEffProd*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooEllipse::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooEllipse::Class_Name()
{
   return "RooEllipse";
}

//______________________________________________________________________________
const char *RooEllipse::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooEllipse::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooEllipse::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooEllipse::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooEllipse*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooErrorVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooErrorVar::Class_Name()
{
   return "RooErrorVar";
}

//______________________________________________________________________________
const char *RooErrorVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooErrorVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooErrorVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooErrorVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooErrorVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExpensiveObjectCache::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExpensiveObjectCache::Class_Name()
{
   return "RooExpensiveObjectCache";
}

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooExpensiveObjectCache::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExpensiveObjectCache::ExpensiveObject::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ExpensiveObject::Class_Name()
{
   return "RooExpensiveObjectCache::ExpensiveObject";
}

//______________________________________________________________________________
const char *RooExpensiveObjectCache::ExpensiveObject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooExpensiveObjectCache::ExpensiveObject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::ExpensiveObject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExpensiveObjectCache::ExpensiveObject::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExpensiveObjectCache::ExpensiveObject*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendedBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendedBinding::Class_Name()
{
   return "RooExtendedBinding";
}

//______________________________________________________________________________
const char *RooExtendedBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendedBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendedBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendedBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendedTerm::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendedTerm::Class_Name()
{
   return "RooExtendedTerm";
}

//______________________________________________________________________________
const char *RooExtendedTerm::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendedTerm::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendedTerm::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendedTerm::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendedTerm*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooExtendPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooExtendPdf::Class_Name()
{
   return "RooExtendPdf";
}

//______________________________________________________________________________
const char *RooExtendPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooExtendPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooExtendPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooExtendPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooExtendPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFFTConvPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFFTConvPdf::Class_Name()
{
   return "RooFFTConvPdf";
}

//______________________________________________________________________________
const char *RooFFTConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFFTConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFFTConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFFTConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFFTConvPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFirstMoment::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFirstMoment::Class_Name()
{
   return "RooFirstMoment";
}

//______________________________________________________________________________
const char *RooFirstMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFirstMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFirstMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFirstMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFirstMoment*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFitResult::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFitResult::Class_Name()
{
   return "RooFitResult";
}

//______________________________________________________________________________
const char *RooFitResult::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFitResult::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFitResult::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFitResult::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFitResult*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFoamGenerator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFoamGenerator::Class_Name()
{
   return "RooFoamGenerator";
}

//______________________________________________________________________________
const char *RooFoamGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFoamGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFoamGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFoamGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFoamGenerator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFracRemainder::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFracRemainder::Class_Name()
{
   return "RooFracRemainder";
}

//______________________________________________________________________________
const char *RooFracRemainder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFracRemainder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFracRemainder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFracRemainder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFracRemainder*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooFunctor::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooFunctor::Class_Name()
{
   return "RooFunctor";
}

//______________________________________________________________________________
const char *RooFunctor::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooFunctor::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooFunctor::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooFunctor::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFunctor*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenContext::Class_Name()
{
   return "RooGenContext";
}

//______________________________________________________________________________
const char *RooGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenericPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenericPdf::Class_Name()
{
   return "RooGenericPdf";
}

//______________________________________________________________________________
const char *RooGenericPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenericPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenericPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenericPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenericPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenFitStudy::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenFitStudy::Class_Name()
{
   return "RooGenFitStudy";
}

//______________________________________________________________________________
const char *RooGenFitStudy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenFitStudy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenFitStudy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenFitStudy::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFitStudy*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenFunction::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenFunction::Class_Name()
{
   return "RooGenFunction";
}

//______________________________________________________________________________
const char *RooGenFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenFunction*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGenProdProj::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGenProdProj::Class_Name()
{
   return "RooGenProdProj";
}

//______________________________________________________________________________
const char *RooGenProdProj::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGenProdProj::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGenProdProj::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGenProdProj::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGenProdProj*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooGrid::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooGrid::Class_Name()
{
   return "RooGrid";
}

//______________________________________________________________________________
const char *RooGrid::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooGrid::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooGrid::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooGrid::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooGrid*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHistError::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHistError::Class_Name()
{
   return "RooHistError";
}

//______________________________________________________________________________
const char *RooHistError::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooHistError::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHistError::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHistError::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHistError*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHist::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHist::Class_Name()
{
   return "RooHist";
}

//______________________________________________________________________________
const char *RooHist::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooHist::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHist::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHist::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHist*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooImproperIntegrator1D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooImproperIntegrator1D::Class_Name()
{
   return "RooImproperIntegrator1D";
}

//______________________________________________________________________________
const char *RooImproperIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooImproperIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooImproperIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooImproperIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooImproperIntegrator1D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegrator1D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegrator1D::Class_Name()
{
   return "RooIntegrator1D";
}

//______________________________________________________________________________
const char *RooIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator1D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegrator2D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegrator2D::Class_Name()
{
   return "RooIntegrator2D";
}

//______________________________________________________________________________
const char *RooIntegrator2D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegrator2D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegrator2D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegrator2D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegrator2D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooIntegratorBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooIntegratorBinding::Class_Name()
{
   return "RooIntegratorBinding";
}

//______________________________________________________________________________
const char *RooIntegratorBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooIntegratorBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooIntegratorBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooIntegratorBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooIntegratorBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooInt::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooInt::Class_Name()
{
   return "RooInt";
}

//______________________________________________________________________________
const char *RooInt::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooInt::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooInt::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooInt::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInt*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooInvTransform::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooInvTransform::Class_Name()
{
   return "RooInvTransform";
}

//______________________________________________________________________________
const char *RooInvTransform::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooInvTransform::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooInvTransform::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooInvTransform::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooInvTransform*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinearCombination::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinearCombination::Class_Name()
{
   return "RooLinearCombination";
}

//______________________________________________________________________________
const char *RooLinearCombination::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearCombination*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinearCombination::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearCombination*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinearCombination::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearCombination*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinearCombination::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearCombination*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinTransBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinTransBinning::Class_Name()
{
   return "RooLinTransBinning";
}

//______________________________________________________________________________
const char *RooLinTransBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinTransBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinTransBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinTransBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinTransBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooLinearVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooLinearVar::Class_Name()
{
   return "RooLinearVar";
}

//______________________________________________________________________________
const char *RooLinearVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooLinearVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooLinearVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooLinearVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooLinearVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooList::Class_Name()
{
   return "RooList";
}

//______________________________________________________________________________
const char *RooList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMappedCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMappedCategory::Class_Name()
{
   return "RooMappedCategory";
}

//______________________________________________________________________________
const char *RooMappedCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMappedCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMappedCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMappedCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMappedCategory::Entry::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMappedCategory::Entry::Class_Name()
{
   return "RooMappedCategory::Entry";
}

//______________________________________________________________________________
const char *RooMappedCategory::Entry::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMappedCategory::Entry::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMappedCategory::Entry::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMappedCategory::Entry::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMappedCategory::Entry*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMCIntegrator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMCIntegrator::Class_Name()
{
   return "RooMCIntegrator";
}

//______________________________________________________________________________
const char *RooMCIntegrator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMCIntegrator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMCIntegrator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMCIntegrator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMCIntegrator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMinimizer::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMinimizer::Class_Name()
{
   return "RooMinimizer";
}

//______________________________________________________________________________
const char *RooMinimizer::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMinimizer::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMinimizer::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMinimizer::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinimizer*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMoment::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMoment::Class_Name()
{
   return "RooMoment";
}

//______________________________________________________________________________
const char *RooMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMoment*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMPSentinel::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMPSentinel::Class_Name()
{
   return "RooMPSentinel";
}

//______________________________________________________________________________
const char *RooMPSentinel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMPSentinel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMPSentinel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMPSentinel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMPSentinel*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiCategory::Class_Name()
{
   return "RooMultiCategory";
}

//______________________________________________________________________________
const char *RooMultiCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiGenFunction::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiGenFunction::Class_Name()
{
   return "RooMultiGenFunction";
}

//______________________________________________________________________________
const char *RooMultiGenFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiGenFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiGenFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiGenFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiGenFunction*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMultiVarGaussian::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMultiVarGaussian::Class_Name()
{
   return "RooMultiVarGaussian";
}

//______________________________________________________________________________
const char *RooMultiVarGaussian::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMultiVarGaussian::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMultiVarGaussian::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMultiVarGaussian::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMultiVarGaussian*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNLLVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNLLVar::Class_Name()
{
   return "RooNLLVar";
}

//______________________________________________________________________________
const char *RooNLLVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNLLVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNLLVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNLLVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNLLVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumRunningInt::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumRunningInt::Class_Name()
{
   return "RooNumRunningInt";
}

//______________________________________________________________________________
const char *RooNumRunningInt::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumRunningInt::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumRunningInt::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumRunningInt::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumRunningInt*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumCdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumCdf::Class_Name()
{
   return "RooNumCdf";
}

//______________________________________________________________________________
const char *RooNumCdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumCdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumCdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumCdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumCdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumConvolution::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumConvolution::Class_Name()
{
   return "RooNumConvolution";
}

//______________________________________________________________________________
const char *RooNumConvolution::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumConvolution::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumConvolution::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumConvolution::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvolution*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumConvPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumConvPdf::Class_Name()
{
   return "RooNumConvPdf";
}

//______________________________________________________________________________
const char *RooNumConvPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumConvPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumConvPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumConvPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumConvPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumGenConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumGenConfig::Class_Name()
{
   return "RooNumGenConfig";
}

//______________________________________________________________________________
const char *RooNumGenConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumGenConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumGenConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumGenConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumGenFactory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumGenFactory::Class_Name()
{
   return "RooNumGenFactory";
}

//______________________________________________________________________________
const char *RooNumGenFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumGenFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumGenFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumGenFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumGenFactory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNumIntFactory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNumIntFactory::Class_Name()
{
   return "RooNumIntFactory";
}

//______________________________________________________________________________
const char *RooNumIntFactory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNumIntFactory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNumIntFactory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNumIntFactory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNumIntFactory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooParamBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooParamBinning::Class_Name()
{
   return "RooParamBinning";
}

//______________________________________________________________________________
const char *RooParamBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooParamBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooParamBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooParamBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooParamBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPlot::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPlot::Class_Name()
{
   return "RooPlot";
}

//______________________________________________________________________________
const char *RooPlot::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPlot::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPlot::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPlot::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPlot*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPolyFunc::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPolyFunc::Class_Name()
{
   return "RooPolyFunc";
}

//______________________________________________________________________________
const char *RooPolyFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyFunc*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPolyFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyFunc*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPolyFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyFunc*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPolyFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyFunc*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPolyVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPolyVar::Class_Name()
{
   return "RooPolyVar";
}

//______________________________________________________________________________
const char *RooPolyVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPolyVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPolyVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPolyVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPolyVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProdGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProdGenContext::Class_Name()
{
   return "RooProdGenContext";
}

//______________________________________________________________________________
const char *RooProdGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProdGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProdGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProdGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProdPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProdPdf::Class_Name()
{
   return "RooProdPdf";
}

//______________________________________________________________________________
const char *RooProdPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProdPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProdPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProdPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProdPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProduct::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProduct::Class_Name()
{
   return "RooProduct";
}

//______________________________________________________________________________
const char *RooProduct::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProduct::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProduct::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProduct::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProduct*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProfileLL::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProfileLL::Class_Name()
{
   return "RooProfileLL";
}

//______________________________________________________________________________
const char *RooProfileLL::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProfileLL::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProfileLL::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProfileLL::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProfileLL*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProjectedPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProjectedPdf::Class_Name()
{
   return "RooProjectedPdf";
}

//______________________________________________________________________________
const char *RooProjectedPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProjectedPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProjectedPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProjectedPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProjectedPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooProofDriverSelector::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooProofDriverSelector::Class_Name()
{
   return "RooProofDriverSelector";
}

//______________________________________________________________________________
const char *RooProofDriverSelector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooProofDriverSelector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooProofDriverSelector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooProofDriverSelector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooProofDriverSelector*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooPullVar::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooPullVar::Class_Name()
{
   return "RooPullVar";
}

//______________________________________________________________________________
const char *RooPullVar::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooPullVar::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooPullVar::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooPullVar::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooPullVar*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooQuasiRandomGenerator::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooQuasiRandomGenerator::Class_Name()
{
   return "RooQuasiRandomGenerator";
}

//______________________________________________________________________________
const char *RooQuasiRandomGenerator::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooQuasiRandomGenerator::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooQuasiRandomGenerator::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooQuasiRandomGenerator::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooQuasiRandomGenerator*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRatio::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRatio::Class_Name()
{
   return "RooRatio";
}

//______________________________________________________________________________
const char *RooRatio::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRatio*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRatio::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRatio*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRatio::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRatio*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRatio::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRatio*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRandom::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRandom::Class_Name()
{
   return "RooRandom";
}

//______________________________________________________________________________
const char *RooRandom::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRandom::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRandom::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRandom::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandom*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRandomizeParamMCSModule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRandomizeParamMCSModule::Class_Name()
{
   return "RooRandomizeParamMCSModule";
}

//______________________________________________________________________________
const char *RooRandomizeParamMCSModule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRandomizeParamMCSModule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRandomizeParamMCSModule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRandomizeParamMCSModule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRandomizeParamMCSModule*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRangeBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRangeBinning::Class_Name()
{
   return "RooRangeBinning";
}

//______________________________________________________________________________
const char *RooRangeBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRangeBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRangeBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRangeBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRangeBoolean::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRangeBoolean::Class_Name()
{
   return "RooRangeBoolean";
}

//______________________________________________________________________________
const char *RooRangeBoolean::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRangeBoolean::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRangeBoolean::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRangeBoolean::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRangeBoolean*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealAnalytic::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealAnalytic::Class_Name()
{
   return "RooRealAnalytic";
}

//______________________________________________________________________________
const char *RooRealAnalytic::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealAnalytic::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealAnalytic::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealAnalytic::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealAnalytic*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealConstant::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealConstant::Class_Name()
{
   return "RooRealConstant";
}

//______________________________________________________________________________
const char *RooRealConstant::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealConstant::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealConstant::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealConstant::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealConstant*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealIntegral::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealIntegral::Class_Name()
{
   return "RooRealIntegral";
}

//______________________________________________________________________________
const char *RooRealIntegral::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealIntegral::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealIntegral::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealIntegral::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealIntegral*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealMPFE::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealMPFE::Class_Name()
{
   return "RooRealMPFE";
}

//______________________________________________________________________________
const char *RooRealMPFE::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealMPFE::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealMPFE::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealMPFE::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealMPFE*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealSumFunc::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealSumFunc::Class_Name()
{
   return "RooRealSumFunc";
}

//______________________________________________________________________________
const char *RooRealSumFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumFunc*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealSumFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumFunc*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealSumFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumFunc*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealSumFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumFunc*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealSumPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealSumPdf::Class_Name()
{
   return "RooRealSumPdf";
}

//______________________________________________________________________________
const char *RooRealSumPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealSumPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealSumPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealSumPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealSumPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSharedProperties::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSharedProperties::Class_Name()
{
   return "RooSharedProperties";
}

//______________________________________________________________________________
const char *RooSharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSharedProperties*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRealVarSharedProperties::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealVarSharedProperties::Class_Name()
{
   return "RooRealVarSharedProperties";
}

//______________________________________________________________________________
const char *RooRealVarSharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealVarSharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealVarSharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealVarSharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRealVarSharedProperties*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRecursiveFraction::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRecursiveFraction::Class_Name()
{
   return "RooRecursiveFraction";
}

//______________________________________________________________________________
const char *RooRecursiveFraction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRecursiveFraction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRecursiveFraction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRecursiveFraction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRecursiveFraction*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooRefCountList::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRefCountList::Class_Name()
{
   return "RooRefCountList";
}

//______________________________________________________________________________
const char *RooRefCountList::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRefCountList::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRefCountList::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRefCountList::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooRefCountList*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooScaledFunc::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooScaledFunc::Class_Name()
{
   return "RooScaledFunc";
}

//______________________________________________________________________________
const char *RooScaledFunc::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooScaledFunc::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooScaledFunc::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooScaledFunc::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooScaledFunc*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSecondMoment::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSecondMoment::Class_Name()
{
   return "RooSecondMoment";
}

//______________________________________________________________________________
const char *RooSecondMoment::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSecondMoment::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSecondMoment::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSecondMoment::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSecondMoment*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSegmentedIntegrator1D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSegmentedIntegrator1D::Class_Name()
{
   return "RooSegmentedIntegrator1D";
}

//______________________________________________________________________________
const char *RooSegmentedIntegrator1D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSegmentedIntegrator1D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator1D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator1D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator1D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSegmentedIntegrator2D::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSegmentedIntegrator2D::Class_Name()
{
   return "RooSegmentedIntegrator2D";
}

//______________________________________________________________________________
const char *RooSegmentedIntegrator2D::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSegmentedIntegrator2D::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator2D::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSegmentedIntegrator2D::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSegmentedIntegrator2D*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimGenContext::Class_Name()
{
   return "RooSimGenContext";
}

//______________________________________________________________________________
const char *RooSimGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimPdfBuilder::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimPdfBuilder::Class_Name()
{
   return "RooSimPdfBuilder";
}

//______________________________________________________________________________
const char *RooSimPdfBuilder::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimPdfBuilder::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimPdfBuilder::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimPdfBuilder::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimPdfBuilder*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimSplitGenContext::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimSplitGenContext::Class_Name()
{
   return "RooSimSplitGenContext";
}

//______________________________________________________________________________
const char *RooSimSplitGenContext::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimSplitGenContext::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimSplitGenContext::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimSplitGenContext::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimSplitGenContext*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimultaneous::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimultaneous::Class_Name()
{
   return "RooSimultaneous";
}

//______________________________________________________________________________
const char *RooSimultaneous::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimultaneous::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimultaneous::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimultaneous::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimultaneous*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::Class_Name()
{
   return "RooWorkspace";
}

//______________________________________________________________________________
const char *RooWorkspace::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::CodeRepo::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::CodeRepo::Class_Name()
{
   return "RooWorkspace::CodeRepo";
}

//______________________________________________________________________________
const char *RooWorkspace::CodeRepo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::CodeRepo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::CodeRepo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::CodeRepo::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::CodeRepo*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspace::WSDir::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspace::WSDir::Class_Name()
{
   return "RooWorkspace::WSDir";
}

//______________________________________________________________________________
const char *RooWorkspace::WSDir::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspace::WSDir::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspace::WSDir::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspace::WSDir::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspace::WSDir*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::Class_Name()
{
   return "RooSimWSTool";
}

//______________________________________________________________________________
const char *RooSimWSTool::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::SplitRule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::SplitRule::Class_Name()
{
   return "RooSimWSTool::SplitRule";
}

//______________________________________________________________________________
const char *RooSimWSTool::SplitRule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::SplitRule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::SplitRule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::SplitRule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::SplitRule*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::BuildConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::BuildConfig::Class_Name()
{
   return "RooSimWSTool::BuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::BuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::BuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::BuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::BuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::BuildConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::MultiBuildConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::MultiBuildConfig::Class_Name()
{
   return "RooSimWSTool::MultiBuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::MultiBuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::MultiBuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::MultiBuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::MultiBuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::MultiBuildConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::ObjSplitRule::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::ObjSplitRule::Class_Name()
{
   return "RooSimWSTool::ObjSplitRule";
}

//______________________________________________________________________________
const char *RooSimWSTool::ObjSplitRule::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ObjSplitRule::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjSplitRule::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjSplitRule::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjSplitRule*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSimWSTool::ObjBuildConfig::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSimWSTool::ObjBuildConfig::Class_Name()
{
   return "RooSimWSTool::ObjBuildConfig";
}

//______________________________________________________________________________
const char *RooSimWSTool::ObjBuildConfig::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSimWSTool::ObjBuildConfig::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjBuildConfig::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSimWSTool::ObjBuildConfig::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSimWSTool::ObjBuildConfig*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStreamParser::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStreamParser::Class_Name()
{
   return "RooStreamParser";
}

//______________________________________________________________________________
const char *RooStreamParser::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooStreamParser::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStreamParser::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStreamParser::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStreamParser*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStudyPackage::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStudyPackage::Class_Name()
{
   return "RooStudyPackage";
}

//______________________________________________________________________________
const char *RooStudyPackage::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooStudyPackage::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStudyPackage::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStudyPackage::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyPackage*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooStudyManager::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooStudyManager::Class_Name()
{
   return "RooStudyManager";
}

//______________________________________________________________________________
const char *RooStudyManager::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooStudyManager::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooStudyManager::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooStudyManager::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooStudyManager*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSuperCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSuperCategory::Class_Name()
{
   return "RooSuperCategory";
}

//______________________________________________________________________________
const char *RooSuperCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSuperCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSuperCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSuperCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSuperCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTFoamBinding::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTFoamBinding::Class_Name()
{
   return "RooTFoamBinding";
}

//______________________________________________________________________________
const char *RooTFoamBinding::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTFoamBinding::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTFoamBinding::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTFoamBinding::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTFoamBinding*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooThresholdCategory::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooThresholdCategory::Class_Name()
{
   return "RooThresholdCategory";
}

//______________________________________________________________________________
const char *RooThresholdCategory::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooThresholdCategory::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooThresholdCategory::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooThresholdCategory::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooThresholdCategory*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTObjWrap::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTObjWrap::Class_Name()
{
   return "RooTObjWrap";
}

//______________________________________________________________________________
const char *RooTObjWrap::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTObjWrap::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTObjWrap::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTObjWrap::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTObjWrap*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTreeDataStore::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTreeDataStore::Class_Name()
{
   return "RooTreeDataStore";
}

//______________________________________________________________________________
const char *RooTreeDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTreeDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTreeDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTreeDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeDataStore*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTruthModel::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTruthModel::Class_Name()
{
   return "RooTruthModel";
}

//______________________________________________________________________________
const char *RooTruthModel::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTruthModel::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTruthModel::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTruthModel::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTruthModel*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooUniformBinning::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooUniformBinning::Class_Name()
{
   return "RooUniformBinning";
}

//______________________________________________________________________________
const char *RooUniformBinning::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooUniformBinning::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooUniformBinning::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooUniformBinning::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUniformBinning*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooUnitTest::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooUnitTest::Class_Name()
{
   return "RooUnitTest";
}

//______________________________________________________________________________
const char *RooUnitTest::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooUnitTest::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooUnitTest::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooUnitTest::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooUnitTest*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::Class_Name()
{
   return "RooVectorDataStore";
}

//______________________________________________________________________________
const char *RooVectorDataStore::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::RealVector::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::RealVector::Class_Name()
{
   return "RooVectorDataStore::RealVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::RealVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::RealVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealVector*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::RealFullVector::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::RealFullVector::Class_Name()
{
   return "RooVectorDataStore::RealFullVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::RealFullVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::RealFullVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealFullVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::RealFullVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::RealFullVector*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooVectorDataStore::CatVector::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooVectorDataStore::CatVector::Class_Name()
{
   return "RooVectorDataStore::CatVector";
}

//______________________________________________________________________________
const char *RooVectorDataStore::CatVector::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooVectorDataStore::CatVector::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooVectorDataStore::CatVector::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooVectorDataStore::CatVector::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooVectorDataStore::CatVector*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWorkspaceHandle::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWorkspaceHandle::Class_Name()
{
   return "RooWorkspaceHandle";
}

//______________________________________________________________________________
const char *RooWorkspaceHandle::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspaceHandle*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooWorkspaceHandle::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspaceHandle*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWorkspaceHandle::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspaceHandle*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWorkspaceHandle::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWorkspaceHandle*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooXYChi2Var::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooXYChi2Var::Class_Name()
{
   return "RooXYChi2Var";
}

//______________________________________________________________________________
const char *RooXYChi2Var::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooXYChi2Var::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooXYChi2Var::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooXYChi2Var::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooXYChi2Var*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooWrapperPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooWrapperPdf::Class_Name()
{
   return "RooWrapperPdf";
}

//______________________________________________________________________________
const char *RooWrapperPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWrapperPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooWrapperPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooWrapperPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooWrapperPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWrapperPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooWrapperPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooWrapperPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinSamplingPdf::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinSamplingPdf::Class_Name()
{
   return "RooBinSamplingPdf";
}

//______________________________________________________________________________
const char *RooBinSamplingPdf::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinSamplingPdf*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinSamplingPdf::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinSamplingPdf*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinSamplingPdf::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinSamplingPdf*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinSamplingPdf::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinSamplingPdf*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooBinWidthFunction::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooBinWidthFunction::Class_Name()
{
   return "RooBinWidthFunction";
}

//______________________________________________________________________________
const char *RooBinWidthFunction::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinWidthFunction*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooBinWidthFunction::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooBinWidthFunction*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooBinWidthFunction::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinWidthFunction*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooBinWidthFunction::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooBinWidthFunction*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooCategorySharedProperties::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooCategorySharedProperties::Class_Name()
{
   return "RooCategorySharedProperties";
}

//______________________________________________________________________________
const char *RooCategorySharedProperties::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooCategorySharedProperties::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooCategorySharedProperties::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooCategorySharedProperties::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooCategorySharedProperties*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooHashTable::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooHashTable::Class_Name()
{
   return "RooHashTable";
}

//______________________________________________________________________________
const char *RooHashTable::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooHashTable::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooHashTable::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooHashTable::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooHashTable*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooMinuit::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooMinuit::Class_Name()
{
   return "RooMinuit";
}

//______________________________________________________________________________
const char *RooMinuit::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooMinuit::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooMinuit::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooMinuit::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooMinuit*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooNameSet::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooNameSet::Class_Name()
{
   return "RooNameSet";
}

//______________________________________________________________________________
const char *RooNameSet::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooNameSet::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooNameSet::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooNameSet::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooNameSet*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooSetPair::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooSetPair::Class_Name()
{
   return "RooSetPair";
}

//______________________________________________________________________________
const char *RooSetPair::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooSetPair::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooSetPair::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooSetPair::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooSetPair*)nullptr)->GetClass(); }
   return fgIsA;
}

//______________________________________________________________________________
atomic_TClass_ptr RooTreeData::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooTreeData::Class_Name()
{
   return "RooTreeData";
}

//______________________________________________________________________________
const char *RooTreeData::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooTreeData::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooTreeData::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooTreeData::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooTreeData*)nullptr)->GetClass(); }
   return fgIsA;
}

namespace RooFit {
   namespace TestStatistics {
//______________________________________________________________________________
atomic_TClass_ptr RooRealL::fgIsA(nullptr);  // static to hold class pointer

//______________________________________________________________________________
const char *RooRealL::Class_Name()
{
   return "RooFit::TestStatistics::RooRealL";
}

//______________________________________________________________________________
const char *RooRealL::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFit::TestStatistics::RooRealL*)nullptr)->GetImplFileName();
}

//______________________________________________________________________________
int RooRealL::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::RooFit::TestStatistics::RooRealL*)nullptr)->GetImplFileLine();
}

//______________________________________________________________________________
TClass *RooRealL::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFit::TestStatistics::RooRealL*)nullptr)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *RooRealL::Class()
{
   if (!fgIsA.load()) { R__LOCKGUARD(gInterpreterMutex); fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::RooFit::TestStatistics::RooRealL*)nullptr)->GetClass(); }
   return fgIsA;
}

} // namespace RooFit::TestStatistics
} // namespace RooFit::TestStatistics
namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcORooLinkedListElemmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,RooLinkedListElem*> : new pair<int,RooLinkedListElem*>;
   }
   static void *newArray_pairlEintcORooLinkedListElemmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<int,RooLinkedListElem*>[nElements] : new pair<int,RooLinkedListElem*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcORooLinkedListElemmUgR(void *p) {
      delete ((pair<int,RooLinkedListElem*>*)p);
   }
   static void deleteArray_pairlEintcORooLinkedListElemmUgR(void *p) {
      delete [] ((pair<int,RooLinkedListElem*>*)p);
   }
   static void destruct_pairlEintcORooLinkedListElemmUgR(void *p) {
      typedef pair<int,RooLinkedListElem*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,RooLinkedListElem*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcORooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,RooAbsData*> : new pair<string,RooAbsData*>;
   }
   static void *newArray_pairlEstringcORooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<string,RooAbsData*>[nElements] : new pair<string,RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcORooAbsDatamUgR(void *p) {
      delete ((pair<string,RooAbsData*>*)p);
   }
   static void deleteArray_pairlEstringcORooAbsDatamUgR(void *p) {
      delete [] ((pair<string,RooAbsData*>*)p);
   }
   static void destruct_pairlEstringcORooAbsDatamUgR(void *p) {
      typedef pair<string,RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,RooAbsData*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::stack<RooAbsArg*,deque<RooAbsArg*> > : new ::stack<RooAbsArg*,deque<RooAbsArg*> >;
   }
   static void *newArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::stack<RooAbsArg*,deque<RooAbsArg*> >[nElements] : new ::stack<RooAbsArg*,deque<RooAbsArg*> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      delete ((::stack<RooAbsArg*,deque<RooAbsArg*> >*)p);
   }
   static void deleteArray_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      delete [] ((::stack<RooAbsArg*,deque<RooAbsArg*> >*)p);
   }
   static void destruct_stacklERooAbsArgmUcOdequelERooAbsArgmUgRsPgR(void *p) {
      typedef ::stack<RooAbsArg*,deque<RooAbsArg*> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::stack<RooAbsArg*,deque<RooAbsArg*> >

//______________________________________________________________________________
void RooPrintable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPrintable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPrintable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPrintable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPrintable(void *p) {
      return  p ? new(p) ::RooPrintable : new ::RooPrintable;
   }
   static void *newArray_RooPrintable(Long_t nElements, void *p) {
      return p ? new(p) ::RooPrintable[nElements] : new ::RooPrintable[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPrintable(void *p) {
      delete ((::RooPrintable*)p);
   }
   static void deleteArray_RooPrintable(void *p) {
      delete [] ((::RooPrintable*)p);
   }
   static void destruct_RooPrintable(void *p) {
      typedef ::RooPrintable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPrintable

//______________________________________________________________________________
template <> void RooSTLRefCountList<RooAbsArg>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSTLRefCountList<RooAbsArg>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSTLRefCountList<RooAbsArg>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSTLRefCountList<RooAbsArg>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSTLRefCountListlERooAbsArggR(void *p) {
      return  p ? new(p) ::RooSTLRefCountList<RooAbsArg> : new ::RooSTLRefCountList<RooAbsArg>;
   }
   static void *newArray_RooSTLRefCountListlERooAbsArggR(Long_t nElements, void *p) {
      return p ? new(p) ::RooSTLRefCountList<RooAbsArg>[nElements] : new ::RooSTLRefCountList<RooAbsArg>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSTLRefCountListlERooAbsArggR(void *p) {
      delete ((::RooSTLRefCountList<RooAbsArg>*)p);
   }
   static void deleteArray_RooSTLRefCountListlERooAbsArggR(void *p) {
      delete [] ((::RooSTLRefCountList<RooAbsArg>*)p);
   }
   static void destruct_RooSTLRefCountListlERooAbsArggR(void *p) {
      typedef ::RooSTLRefCountList<RooAbsArg> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSTLRefCountList<RooAbsArg>

//______________________________________________________________________________
void RooAbsCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAbsCache(void *p) {
      return  p ? new(p) ::RooAbsCache : new ::RooAbsCache;
   }
   static void *newArray_RooAbsCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooAbsCache[nElements] : new ::RooAbsCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAbsCache(void *p) {
      delete ((::RooAbsCache*)p);
   }
   static void deleteArray_RooAbsCache(void *p) {
      delete [] ((::RooAbsCache*)p);
   }
   static void destruct_RooAbsCache(void *p) {
      typedef ::RooAbsCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCache

//______________________________________________________________________________
void RooLinkedListElem::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinkedListElem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinkedListElem::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinkedListElem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinkedListElem(void *p) {
      return  p ? new(p) ::RooLinkedListElem : new ::RooLinkedListElem;
   }
   static void *newArray_RooLinkedListElem(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinkedListElem[nElements] : new ::RooLinkedListElem[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinkedListElem(void *p) {
      delete ((::RooLinkedListElem*)p);
   }
   static void deleteArray_RooLinkedListElem(void *p) {
      delete [] ((::RooLinkedListElem*)p);
   }
   static void destruct_RooLinkedListElem(void *p) {
      typedef ::RooLinkedListElem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinkedListElem

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinkedList(void *p) {
      return  p ? new(p) ::RooLinkedList : new ::RooLinkedList;
   }
   static void *newArray_RooLinkedList(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinkedList[nElements] : new ::RooLinkedList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinkedList(void *p) {
      delete ((::RooLinkedList*)p);
   }
   static void deleteArray_RooLinkedList(void *p) {
      delete [] ((::RooLinkedList*)p);
   }
   static void destruct_RooLinkedList(void *p) {
      typedef ::RooLinkedList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooLinkedList(TBuffer &buf, void *obj) {
      ((::RooLinkedList*)obj)->::RooLinkedList::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooLinkedList

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFIter(void *p) {
      delete ((::RooFIter*)p);
   }
   static void deleteArray_RooFIter(void *p) {
      delete [] ((::RooFIter*)p);
   }
   static void destruct_RooFIter(void *p) {
      typedef ::RooFIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFIter

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRefArray(void *p) {
      return  p ? new(p) ::RooRefArray : new ::RooRefArray;
   }
   static void *newArray_RooRefArray(Long_t nElements, void *p) {
      return p ? new(p) ::RooRefArray[nElements] : new ::RooRefArray[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRefArray(void *p) {
      delete ((::RooRefArray*)p);
   }
   static void deleteArray_RooRefArray(void *p) {
      delete [] ((::RooRefArray*)p);
   }
   static void destruct_RooRefArray(void *p) {
      typedef ::RooRefArray current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooRefArray(TBuffer &buf, void *obj) {
      ((::RooRefArray*)obj)->::RooRefArray::Streamer(buf);
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooRefArray(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooRefArray*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooRefArray

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsArg(void *p) {
      delete ((::RooAbsArg*)p);
   }
   static void deleteArray_RooAbsArg(void *p) {
      delete [] ((::RooAbsArg*)p);
   }
   static void destruct_RooAbsArg(void *p) {
      typedef ::RooAbsArg current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsArg(TBuffer &buf, void *obj) {
      ((::RooAbsArg*)obj)->::RooAbsArg::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsArg

//______________________________________________________________________________
void RooCatType::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCatType.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCatType::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCatType::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCatType(void *p) {
      return  p ? new(p) ::RooCatType : new ::RooCatType;
   }
   static void *newArray_RooCatType(Long_t nElements, void *p) {
      return p ? new(p) ::RooCatType[nElements] : new ::RooCatType[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCatType(void *p) {
      delete ((::RooCatType*)p);
   }
   static void deleteArray_RooCatType(void *p) {
      delete [] ((::RooCatType*)p);
   }
   static void destruct_RooCatType(void *p) {
      typedef ::RooCatType current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCatType

//______________________________________________________________________________
void RooAbsCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCategory(void *p) {
      delete ((::RooAbsCategory*)p);
   }
   static void deleteArray_RooAbsCategory(void *p) {
      delete [] ((::RooAbsCategory*)p);
   }
   static void destruct_RooAbsCategory(void *p) {
      typedef ::RooAbsCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCategory

//______________________________________________________________________________
void RooTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTable::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTable(void *p) {
      delete ((::RooTable*)p);
   }
   static void deleteArray_RooTable(void *p) {
      delete [] ((::RooTable*)p);
   }
   static void destruct_RooTable(void *p) {
      typedef ::RooTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTable

//______________________________________________________________________________
void Roo1DTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class Roo1DTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(Roo1DTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(Roo1DTable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_Roo1DTable(void *p) {
      return  p ? new(p) ::Roo1DTable : new ::Roo1DTable;
   }
   static void *newArray_Roo1DTable(Long_t nElements, void *p) {
      return p ? new(p) ::Roo1DTable[nElements] : new ::Roo1DTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_Roo1DTable(void *p) {
      delete ((::Roo1DTable*)p);
   }
   static void deleteArray_Roo1DTable(void *p) {
      delete [] ((::Roo1DTable*)p);
   }
   static void destruct_Roo1DTable(void *p) {
      typedef ::Roo1DTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Roo1DTable

//______________________________________________________________________________
void RooCmdArg::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCmdArg.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCmdArg::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCmdArg::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCmdArg(void *p) {
      return  p ? new(p) ::RooCmdArg : new ::RooCmdArg;
   }
   static void *newArray_RooCmdArg(Long_t nElements, void *p) {
      return p ? new(p) ::RooCmdArg[nElements] : new ::RooCmdArg[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCmdArg(void *p) {
      delete ((::RooCmdArg*)p);
   }
   static void deleteArray_RooCmdArg(void *p) {
      delete [] ((::RooCmdArg*)p);
   }
   static void destruct_RooCmdArg(void *p) {
      typedef ::RooCmdArg current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCmdArg

//______________________________________________________________________________
void RooPlotable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPlotable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPlotable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPlotable::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooPlotable(void *p) {
      delete ((::RooPlotable*)p);
   }
   static void deleteArray_RooPlotable(void *p) {
      delete [] ((::RooPlotable*)p);
   }
   static void destruct_RooPlotable(void *p) {
      typedef ::RooPlotable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPlotable

//______________________________________________________________________________
void RooCurve::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCurve.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCurve::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCurve::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCurve(void *p) {
      return  p ? new(p) ::RooCurve : new ::RooCurve;
   }
   static void *newArray_RooCurve(Long_t nElements, void *p) {
      return p ? new(p) ::RooCurve[nElements] : new ::RooCurve[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCurve(void *p) {
      delete ((::RooCurve*)p);
   }
   static void deleteArray_RooCurve(void *p) {
      delete [] ((::RooCurve*)p);
   }
   static void destruct_RooCurve(void *p) {
      typedef ::RooCurve current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooCurve(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooCurve*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooCurve

//______________________________________________________________________________
void RooAbsCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCollection.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCollection::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCollection::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCollection(void *p) {
      delete ((::RooAbsCollection*)p);
   }
   static void deleteArray_RooAbsCollection(void *p) {
      delete [] ((::RooAbsCollection*)p);
   }
   static void destruct_RooAbsCollection(void *p) {
      typedef ::RooAbsCollection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCollection

//______________________________________________________________________________
void RooArgSet::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgSet.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgSet::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgSet::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgSet(void *p) {
      return  p ? new(p) ::RooArgSet : new ::RooArgSet;
   }
   static void *newArray_RooArgSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgSet[nElements] : new ::RooArgSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgSet(void *p) {
      delete ((::RooArgSet*)p);
   }
   static void deleteArray_RooArgSet(void *p) {
      delete [] ((::RooArgSet*)p);
   }
   static void destruct_RooArgSet(void *p) {
      typedef ::RooArgSet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgSet

//______________________________________________________________________________
void RooArgList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgList(void *p) {
      return  p ? new(p) ::RooArgList : new ::RooArgList;
   }
   static void *newArray_RooArgList(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgList[nElements] : new ::RooArgList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgList(void *p) {
      delete ((::RooArgList*)p);
   }
   static void deleteArray_RooArgList(void *p) {
      delete [] ((::RooArgList*)p);
   }
   static void destruct_RooArgList(void *p) {
      typedef ::RooArgList current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgList

//______________________________________________________________________________
void RooAbsReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsReal(void *p) {
      delete ((::RooAbsReal*)p);
   }
   static void deleteArray_RooAbsReal(void *p) {
      delete [] ((::RooAbsReal*)p);
   }
   static void destruct_RooAbsReal(void *p) {
      typedef ::RooAbsReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsReal

//______________________________________________________________________________
void RooNormSetCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNormSetCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNormSetCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNormSetCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNormSetCache(void *p) {
      return  p ? new(p) ::RooNormSetCache : new ::RooNormSetCache;
   }
   static void *newArray_RooNormSetCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooNormSetCache[nElements] : new ::RooNormSetCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNormSetCache(void *p) {
      delete ((::RooNormSetCache*)p);
   }
   static void deleteArray_RooNormSetCache(void *p) {
      delete [] ((::RooNormSetCache*)p);
   }
   static void destruct_RooNormSetCache(void *p) {
      typedef ::RooNormSetCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNormSetCache

//______________________________________________________________________________
void RooAbsCacheElement::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCacheElement.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCacheElement::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCacheElement::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCacheElement(void *p) {
      delete ((::RooAbsCacheElement*)p);
   }
   static void deleteArray_RooAbsCacheElement(void *p) {
      delete [] ((::RooAbsCacheElement*)p);
   }
   static void destruct_RooAbsCacheElement(void *p) {
      typedef ::RooAbsCacheElement current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCacheElement

//______________________________________________________________________________
void RooMsgService::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMsgService.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMsgService::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMsgService::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMsgService(void *p) {
      delete ((::RooMsgService*)p);
   }
   static void deleteArray_RooMsgService(void *p) {
      delete [] ((::RooMsgService*)p);
   }
   static void destruct_RooMsgService(void *p) {
      typedef ::RooMsgService current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMsgService

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMsgServicecLcLStreamConfig(void *p) {
      return  p ? new(p) ::RooMsgService::StreamConfig : new ::RooMsgService::StreamConfig;
   }
   static void *newArray_RooMsgServicecLcLStreamConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooMsgService::StreamConfig[nElements] : new ::RooMsgService::StreamConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMsgServicecLcLStreamConfig(void *p) {
      delete ((::RooMsgService::StreamConfig*)p);
   }
   static void deleteArray_RooMsgServicecLcLStreamConfig(void *p) {
      delete [] ((::RooMsgService::StreamConfig*)p);
   }
   static void destruct_RooMsgServicecLcLStreamConfig(void *p) {
      typedef ::RooMsgService::StreamConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMsgService::StreamConfig

//______________________________________________________________________________
template <> void RooCacheManager<RooAbsCacheElement>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCacheManager<RooAbsCacheElement>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCacheManager<RooAbsCacheElement>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCacheManager<RooAbsCacheElement>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      return  p ? new(p) ::RooCacheManager<RooAbsCacheElement> : new ::RooCacheManager<RooAbsCacheElement>;
   }
   static void *newArray_RooCacheManagerlERooAbsCacheElementgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooCacheManager<RooAbsCacheElement>[nElements] : new ::RooCacheManager<RooAbsCacheElement>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      delete ((::RooCacheManager<RooAbsCacheElement>*)p);
   }
   static void deleteArray_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      delete [] ((::RooCacheManager<RooAbsCacheElement>*)p);
   }
   static void destruct_RooCacheManagerlERooAbsCacheElementgR(void *p) {
      typedef ::RooCacheManager<RooAbsCacheElement> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCacheManager<RooAbsCacheElement>

//______________________________________________________________________________
template <> void RooCacheManager<vector<double> >::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCacheManager<vector<double> >.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCacheManager<vector<double> >::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCacheManager<vector<double> >::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      return  p ? new(p) ::RooCacheManager<vector<double> > : new ::RooCacheManager<vector<double> >;
   }
   static void *newArray_RooCacheManagerlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooCacheManager<vector<double> >[nElements] : new ::RooCacheManager<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      delete ((::RooCacheManager<vector<double> >*)p);
   }
   static void deleteArray_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((::RooCacheManager<vector<double> >*)p);
   }
   static void destruct_RooCacheManagerlEvectorlEdoublegRsPgR(void *p) {
      typedef ::RooCacheManager<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCacheManager<vector<double> >

//______________________________________________________________________________
void RooObjCacheManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooObjCacheManager.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooObjCacheManager::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooObjCacheManager::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooObjCacheManager(void *p) {
      return  p ? new(p) ::RooObjCacheManager : new ::RooObjCacheManager;
   }
   static void *newArray_RooObjCacheManager(Long_t nElements, void *p) {
      return p ? new(p) ::RooObjCacheManager[nElements] : new ::RooObjCacheManager[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooObjCacheManager(void *p) {
      delete ((::RooObjCacheManager*)p);
   }
   static void deleteArray_RooObjCacheManager(void *p) {
      delete [] ((::RooObjCacheManager*)p);
   }
   static void destruct_RooObjCacheManager(void *p) {
      typedef ::RooObjCacheManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooObjCacheManager

//______________________________________________________________________________
void RooAbsPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsPdf(void *p) {
      delete ((::RooAbsPdf*)p);
   }
   static void deleteArray_RooAbsPdf(void *p) {
      delete [] ((::RooAbsPdf*)p);
   }
   static void destruct_RooAbsPdf(void *p) {
      typedef ::RooAbsPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsPdf

//______________________________________________________________________________
void RooAbsPdf::GenSpec::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsPdf::GenSpec.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsPdf::GenSpec::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsPdf::GenSpec::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAbsPdfcLcLGenSpec(void *p) {
      return  p ? new(p) ::RooAbsPdf::GenSpec : new ::RooAbsPdf::GenSpec;
   }
   static void *newArray_RooAbsPdfcLcLGenSpec(Long_t nElements, void *p) {
      return p ? new(p) ::RooAbsPdf::GenSpec[nElements] : new ::RooAbsPdf::GenSpec[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAbsPdfcLcLGenSpec(void *p) {
      delete ((::RooAbsPdf::GenSpec*)p);
   }
   static void deleteArray_RooAbsPdfcLcLGenSpec(void *p) {
      delete [] ((::RooAbsPdf::GenSpec*)p);
   }
   static void destruct_RooAbsPdfcLcLGenSpec(void *p) {
      typedef ::RooAbsPdf::GenSpec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsPdf::GenSpec

//______________________________________________________________________________
void RooAbsProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsProxy(void *p) {
      delete ((::RooAbsProxy*)p);
   }
   static void deleteArray_RooAbsProxy(void *p) {
      delete [] ((::RooAbsProxy*)p);
   }
   static void destruct_RooAbsProxy(void *p) {
      typedef ::RooAbsProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsProxy

//______________________________________________________________________________
void RooArgProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooArgProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooArgProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooArgProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooArgProxy(void *p) {
      return  p ? new(p) ::RooArgProxy : new ::RooArgProxy;
   }
   static void *newArray_RooArgProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooArgProxy[nElements] : new ::RooArgProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooArgProxy(void *p) {
      delete ((::RooArgProxy*)p);
   }
   static void deleteArray_RooArgProxy(void *p) {
      delete [] ((::RooArgProxy*)p);
   }
   static void destruct_RooArgProxy(void *p) {
      typedef ::RooArgProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooArgProxy

//______________________________________________________________________________
void RooNumber::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumber.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumber::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumber::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumber(void *p) {
      return  p ? new(p) ::RooNumber : new ::RooNumber;
   }
   static void *newArray_RooNumber(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumber[nElements] : new ::RooNumber[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumber(void *p) {
      delete ((::RooNumber*)p);
   }
   static void deleteArray_RooNumber(void *p) {
      delete [] ((::RooNumber*)p);
   }
   static void destruct_RooNumber(void *p) {
      typedef ::RooNumber current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumber

//______________________________________________________________________________
void RooAbsLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsLValue(void *p) {
      delete ((::RooAbsLValue*)p);
   }
   static void deleteArray_RooAbsLValue(void *p) {
      delete [] ((::RooAbsLValue*)p);
   }
   static void destruct_RooAbsLValue(void *p) {
      typedef ::RooAbsLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsLValue

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsBinning(void *p) {
      delete ((::RooAbsBinning*)p);
   }
   static void deleteArray_RooAbsBinning(void *p) {
      delete [] ((::RooAbsBinning*)p);
   }
   static void destruct_RooAbsBinning(void *p) {
      typedef ::RooAbsBinning current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsBinning(TBuffer &buf, void *obj) {
      ((::RooAbsBinning*)obj)->::RooAbsBinning::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsBinning

//______________________________________________________________________________
void RooAbsRealLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsRealLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsRealLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsRealLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsRealLValue(void *p) {
      delete ((::RooAbsRealLValue*)p);
   }
   static void deleteArray_RooAbsRealLValue(void *p) {
      delete [] ((::RooAbsRealLValue*)p);
   }
   static void destruct_RooAbsRealLValue(void *p) {
      typedef ::RooAbsRealLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsRealLValue

//______________________________________________________________________________
template <> void RooTemplateProxy<RooAbsReal>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooAbsReal>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooAbsReal>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooAbsReal>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooAbsRealgR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooAbsReal> : new ::RooTemplateProxy<RooAbsReal>;
   }
   static void *newArray_RooTemplateProxylERooAbsRealgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooAbsReal>[nElements] : new ::RooTemplateProxy<RooAbsReal>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooAbsRealgR(void *p) {
      delete ((::RooTemplateProxy<RooAbsReal>*)p);
   }
   static void deleteArray_RooTemplateProxylERooAbsRealgR(void *p) {
      delete [] ((::RooTemplateProxy<RooAbsReal>*)p);
   }
   static void destruct_RooTemplateProxylERooAbsRealgR(void *p) {
      typedef ::RooTemplateProxy<RooAbsReal> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooAbsReal>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooAbsCategory>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooAbsCategory>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooAbsCategory>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooAbsCategory>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooAbsCategorygR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooAbsCategory> : new ::RooTemplateProxy<RooAbsCategory>;
   }
   static void *newArray_RooTemplateProxylERooAbsCategorygR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooAbsCategory>[nElements] : new ::RooTemplateProxy<RooAbsCategory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooAbsCategorygR(void *p) {
      delete ((::RooTemplateProxy<RooAbsCategory>*)p);
   }
   static void deleteArray_RooTemplateProxylERooAbsCategorygR(void *p) {
      delete [] ((::RooTemplateProxy<RooAbsCategory>*)p);
   }
   static void destruct_RooTemplateProxylERooAbsCategorygR(void *p) {
      typedef ::RooTemplateProxy<RooAbsCategory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooAbsCategory>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooAbsRealLValue>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooAbsRealLValue>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooAbsRealLValue>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooAbsRealLValue>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooAbsRealLValuegR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooAbsRealLValue> : new ::RooTemplateProxy<RooAbsRealLValue>;
   }
   static void *newArray_RooTemplateProxylERooAbsRealLValuegR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooAbsRealLValue>[nElements] : new ::RooTemplateProxy<RooAbsRealLValue>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooAbsRealLValuegR(void *p) {
      delete ((::RooTemplateProxy<RooAbsRealLValue>*)p);
   }
   static void deleteArray_RooTemplateProxylERooAbsRealLValuegR(void *p) {
      delete [] ((::RooTemplateProxy<RooAbsRealLValue>*)p);
   }
   static void destruct_RooTemplateProxylERooAbsRealLValuegR(void *p) {
      typedef ::RooTemplateProxy<RooAbsRealLValue> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooAbsRealLValue>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooAbsPdf>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooAbsPdf>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooAbsPdf>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooAbsPdf>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooAbsPdfgR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooAbsPdf> : new ::RooTemplateProxy<RooAbsPdf>;
   }
   static void *newArray_RooTemplateProxylERooAbsPdfgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooAbsPdf>[nElements] : new ::RooTemplateProxy<RooAbsPdf>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooAbsPdfgR(void *p) {
      delete ((::RooTemplateProxy<RooAbsPdf>*)p);
   }
   static void deleteArray_RooTemplateProxylERooAbsPdfgR(void *p) {
      delete [] ((::RooTemplateProxy<RooAbsPdf>*)p);
   }
   static void destruct_RooTemplateProxylERooAbsPdfgR(void *p) {
      typedef ::RooTemplateProxy<RooAbsPdf> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooAbsPdf>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooRealVar>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooRealVar>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooRealVar>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooRealVar>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooRealVargR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooRealVar> : new ::RooTemplateProxy<RooRealVar>;
   }
   static void *newArray_RooTemplateProxylERooRealVargR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooRealVar>[nElements] : new ::RooTemplateProxy<RooRealVar>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooRealVargR(void *p) {
      delete ((::RooTemplateProxy<RooRealVar>*)p);
   }
   static void deleteArray_RooTemplateProxylERooRealVargR(void *p) {
      delete [] ((::RooTemplateProxy<RooRealVar>*)p);
   }
   static void destruct_RooTemplateProxylERooRealVargR(void *p) {
      typedef ::RooTemplateProxy<RooRealVar> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooRealVar>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooMultiCategory>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooMultiCategory>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooMultiCategory>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooMultiCategory>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooMultiCategorygR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooMultiCategory> : new ::RooTemplateProxy<RooMultiCategory>;
   }
   static void *newArray_RooTemplateProxylERooMultiCategorygR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooMultiCategory>[nElements] : new ::RooTemplateProxy<RooMultiCategory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooMultiCategorygR(void *p) {
      delete ((::RooTemplateProxy<RooMultiCategory>*)p);
   }
   static void deleteArray_RooTemplateProxylERooMultiCategorygR(void *p) {
      delete [] ((::RooTemplateProxy<RooMultiCategory>*)p);
   }
   static void destruct_RooTemplateProxylERooMultiCategorygR(void *p) {
      typedef ::RooTemplateProxy<RooMultiCategory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooMultiCategory>

//______________________________________________________________________________
template <> void RooTemplateProxy<const RooHistFunc>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<const RooHistFunc>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<const RooHistFunc>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<const RooHistFunc>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylEconstsPRooHistFuncgR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<const RooHistFunc> : new ::RooTemplateProxy<const RooHistFunc>;
   }
   static void *newArray_RooTemplateProxylEconstsPRooHistFuncgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<const RooHistFunc>[nElements] : new ::RooTemplateProxy<const RooHistFunc>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylEconstsPRooHistFuncgR(void *p) {
      delete ((::RooTemplateProxy<const RooHistFunc>*)p);
   }
   static void deleteArray_RooTemplateProxylEconstsPRooHistFuncgR(void *p) {
      delete [] ((::RooTemplateProxy<const RooHistFunc>*)p);
   }
   static void destruct_RooTemplateProxylEconstsPRooHistFuncgR(void *p) {
      typedef ::RooTemplateProxy<const RooHistFunc> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<const RooHistFunc>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooAbsCategoryLValue>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooAbsCategoryLValue>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooAbsCategoryLValue>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooAbsCategoryLValue>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooAbsCategoryLValuegR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooAbsCategoryLValue> : new ::RooTemplateProxy<RooAbsCategoryLValue>;
   }
   static void *newArray_RooTemplateProxylERooAbsCategoryLValuegR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooAbsCategoryLValue>[nElements] : new ::RooTemplateProxy<RooAbsCategoryLValue>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooAbsCategoryLValuegR(void *p) {
      delete ((::RooTemplateProxy<RooAbsCategoryLValue>*)p);
   }
   static void deleteArray_RooTemplateProxylERooAbsCategoryLValuegR(void *p) {
      delete [] ((::RooTemplateProxy<RooAbsCategoryLValue>*)p);
   }
   static void destruct_RooTemplateProxylERooAbsCategoryLValuegR(void *p) {
      typedef ::RooTemplateProxy<RooAbsCategoryLValue> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooAbsCategoryLValue>

//______________________________________________________________________________
template <> void RooTemplateProxy<RooHistFunc>::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTemplateProxy<RooHistFunc>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTemplateProxy<RooHistFunc>::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTemplateProxy<RooHistFunc>::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTemplateProxylERooHistFuncgR(void *p) {
      return  p ? new(p) ::RooTemplateProxy<RooHistFunc> : new ::RooTemplateProxy<RooHistFunc>;
   }
   static void *newArray_RooTemplateProxylERooHistFuncgR(Long_t nElements, void *p) {
      return p ? new(p) ::RooTemplateProxy<RooHistFunc>[nElements] : new ::RooTemplateProxy<RooHistFunc>[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTemplateProxylERooHistFuncgR(void *p) {
      delete ((::RooTemplateProxy<RooHistFunc>*)p);
   }
   static void deleteArray_RooTemplateProxylERooHistFuncgR(void *p) {
      delete [] ((::RooTemplateProxy<RooHistFunc>*)p);
   }
   static void destruct_RooTemplateProxylERooHistFuncgR(void *p) {
      typedef ::RooTemplateProxy<RooHistFunc> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTemplateProxy<RooHistFunc>

//______________________________________________________________________________
void RooListProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooListProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooListProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooListProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooListProxy(void *p) {
      return  p ? new(p) ::RooListProxy : new ::RooListProxy;
   }
   static void *newArray_RooListProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooListProxy[nElements] : new ::RooListProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooListProxy(void *p) {
      delete ((::RooListProxy*)p);
   }
   static void deleteArray_RooListProxy(void *p) {
      delete [] ((::RooListProxy*)p);
   }
   static void destruct_RooListProxy(void *p) {
      typedef ::RooListProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooListProxy

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsData(void *p) {
      delete ((::RooAbsData*)p);
   }
   static void deleteArray_RooAbsData(void *p) {
      delete [] ((::RooAbsData*)p);
   }
   static void destruct_RooAbsData(void *p) {
      typedef ::RooAbsData current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooAbsData(TBuffer &buf, void *obj) {
      ((::RooAbsData*)obj)->::RooAbsData::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooAbsData

//______________________________________________________________________________
void RooDirItem::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDirItem.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDirItem::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDirItem::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDirItem(void *p) {
      return  p ? new(p) ::RooDirItem : new ::RooDirItem;
   }
   static void *newArray_RooDirItem(Long_t nElements, void *p) {
      return p ? new(p) ::RooDirItem[nElements] : new ::RooDirItem[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDirItem(void *p) {
      delete ((::RooDirItem*)p);
   }
   static void deleteArray_RooDirItem(void *p) {
      delete [] ((::RooDirItem*)p);
   }
   static void destruct_RooDirItem(void *p) {
      typedef ::RooDirItem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDirItem

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataSet(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::RooDataSet : new ::RooDataSet;
   }
   static void *newArray_RooDataSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataSet[nElements] : new ::RooDataSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataSet(void *p) {
      delete ((::RooDataSet*)p);
   }
   static void deleteArray_RooDataSet(void *p) {
      delete [] ((::RooDataSet*)p);
   }
   static void destruct_RooDataSet(void *p) {
      typedef ::RooDataSet current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooDataSet(TBuffer &buf, void *obj) {
      ((::RooDataSet*)obj)->::RooDataSet::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooDataSet

//______________________________________________________________________________
void RooAICRegistry::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAICRegistry.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAICRegistry::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAICRegistry::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAICRegistry(void *p) {
      return  p ? new(p) ::RooAICRegistry : new ::RooAICRegistry;
   }
   static void *newArray_RooAICRegistry(Long_t nElements, void *p) {
      return p ? new(p) ::RooAICRegistry[nElements] : new ::RooAICRegistry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAICRegistry(void *p) {
      delete ((::RooAICRegistry*)p);
   }
   static void deleteArray_RooAICRegistry(void *p) {
      delete [] ((::RooAICRegistry*)p);
   }
   static void destruct_RooAICRegistry(void *p) {
      typedef ::RooAICRegistry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAICRegistry

//______________________________________________________________________________
void RooAbsAnaConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsAnaConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsAnaConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsAnaConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsAnaConvPdf(void *p) {
      delete ((::RooAbsAnaConvPdf*)p);
   }
   static void deleteArray_RooAbsAnaConvPdf(void *p) {
      delete [] ((::RooAbsAnaConvPdf*)p);
   }
   static void destruct_RooAbsAnaConvPdf(void *p) {
      typedef ::RooAbsAnaConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsAnaConvPdf

//______________________________________________________________________________
void RooSetProxy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSetProxy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSetProxy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSetProxy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSetProxy(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::RooSetProxy : new ::RooSetProxy;
   }
   static void *newArray_RooSetProxy(Long_t nElements, void *p) {
      return p ? new(p) ::RooSetProxy[nElements] : new ::RooSetProxy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSetProxy(void *p) {
      delete ((::RooSetProxy*)p);
   }
   static void deleteArray_RooSetProxy(void *p) {
      delete [] ((::RooSetProxy*)p);
   }
   static void destruct_RooSetProxy(void *p) {
      typedef ::RooSetProxy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSetProxy

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHistPdf(void *p) {
      return  p ? new(p) ::RooHistPdf : new ::RooHistPdf;
   }
   static void *newArray_RooHistPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooHistPdf[nElements] : new ::RooHistPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHistPdf(void *p) {
      delete ((::RooHistPdf*)p);
   }
   static void deleteArray_RooHistPdf(void *p) {
      delete [] ((::RooHistPdf*)p);
   }
   static void destruct_RooHistPdf(void *p) {
      typedef ::RooHistPdf current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooHistPdf(TBuffer &buf, void *obj) {
      ((::RooHistPdf*)obj)->::RooHistPdf::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooHistPdf

//______________________________________________________________________________
void RooChangeTracker::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooChangeTracker.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooChangeTracker::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooChangeTracker::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooChangeTracker(void *p) {
      return  p ? new(p) ::RooChangeTracker : new ::RooChangeTracker;
   }
   static void *newArray_RooChangeTracker(Long_t nElements, void *p) {
      return p ? new(p) ::RooChangeTracker[nElements] : new ::RooChangeTracker[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooChangeTracker(void *p) {
      delete ((::RooChangeTracker*)p);
   }
   static void deleteArray_RooChangeTracker(void *p) {
      delete [] ((::RooChangeTracker*)p);
   }
   static void destruct_RooChangeTracker(void *p) {
      typedef ::RooChangeTracker current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooChangeTracker

//______________________________________________________________________________
void RooAbsCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedPdf(void *p) {
      delete ((::RooAbsCachedPdf*)p);
   }
   static void deleteArray_RooAbsCachedPdf(void *p) {
      delete [] ((::RooAbsCachedPdf*)p);
   }
   static void destruct_RooAbsCachedPdf(void *p) {
      typedef ::RooAbsCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedPdf

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      delete ((::RooAbsCachedPdf::PdfCacheElem*)p);
   }
   static void deleteArray_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      delete [] ((::RooAbsCachedPdf::PdfCacheElem*)p);
   }
   static void destruct_RooAbsCachedPdfcLcLPdfCacheElem(void *p) {
      typedef ::RooAbsCachedPdf::PdfCacheElem current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedPdf::PdfCacheElem

//______________________________________________________________________________
void RooTrace::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTrace.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTrace::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTrace::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTrace(void *p) {
      return  p ? new(p) ::RooTrace : new ::RooTrace;
   }
   static void *newArray_RooTrace(Long_t nElements, void *p) {
      return p ? new(p) ::RooTrace[nElements] : new ::RooTrace[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTrace(void *p) {
      delete ((::RooTrace*)p);
   }
   static void deleteArray_RooTrace(void *p) {
      delete [] ((::RooTrace*)p);
   }
   static void destruct_RooTrace(void *p) {
      typedef ::RooTrace current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTrace

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHistFunc(void *p) {
      return  p ? new(p) ::RooHistFunc : new ::RooHistFunc;
   }
   static void *newArray_RooHistFunc(Long_t nElements, void *p) {
      return p ? new(p) ::RooHistFunc[nElements] : new ::RooHistFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHistFunc(void *p) {
      delete ((::RooHistFunc*)p);
   }
   static void deleteArray_RooHistFunc(void *p) {
      delete [] ((::RooHistFunc*)p);
   }
   static void destruct_RooHistFunc(void *p) {
      typedef ::RooHistFunc current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooHistFunc(TBuffer &buf, void *obj) {
      ((::RooHistFunc*)obj)->::RooHistFunc::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooHistFunc

//______________________________________________________________________________
void RooAbsCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCachedReal(void *p) {
      delete ((::RooAbsCachedReal*)p);
   }
   static void deleteArray_RooAbsCachedReal(void *p) {
      delete [] ((::RooAbsCachedReal*)p);
   }
   static void destruct_RooAbsCachedReal(void *p) {
      typedef ::RooAbsCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCachedReal

//______________________________________________________________________________
void RooAbsCategoryLValue::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsCategoryLValue.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsCategoryLValue::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsCategoryLValue::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsCategoryLValue(void *p) {
      delete ((::RooAbsCategoryLValue*)p);
   }
   static void deleteArray_RooAbsCategoryLValue(void *p) {
      delete [] ((::RooAbsCategoryLValue*)p);
   }
   static void destruct_RooAbsCategoryLValue(void *p) {
      typedef ::RooAbsCategoryLValue current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsCategoryLValue

//______________________________________________________________________________
void RooAbsDataStore::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsDataStore.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsDataStore::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsDataStore::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsDataStore(void *p) {
      delete ((::RooAbsDataStore*)p);
   }
   static void deleteArray_RooAbsDataStore(void *p) {
      delete [] ((::RooAbsDataStore*)p);
   }
   static void destruct_RooAbsDataStore(void *p) {
      typedef ::RooAbsDataStore current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsDataStore

//______________________________________________________________________________
void RooAbsFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsFunc(void *p) {
      delete ((::RooAbsFunc*)p);
   }
   static void deleteArray_RooAbsFunc(void *p) {
      delete [] ((::RooAbsFunc*)p);
   }
   static void destruct_RooAbsFunc(void *p) {
      typedef ::RooAbsFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsFunc

//______________________________________________________________________________
void RooAbsGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsGenContext(void *p) {
      delete ((::RooAbsGenContext*)p);
   }
   static void deleteArray_RooAbsGenContext(void *p) {
      delete [] ((::RooAbsGenContext*)p);
   }
   static void destruct_RooAbsGenContext(void *p) {
      typedef ::RooAbsGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsGenContext

//______________________________________________________________________________
void RooAbsHiddenReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsHiddenReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsHiddenReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsHiddenReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsHiddenReal(void *p) {
      delete ((::RooAbsHiddenReal*)p);
   }
   static void deleteArray_RooAbsHiddenReal(void *p) {
      delete [] ((::RooAbsHiddenReal*)p);
   }
   static void destruct_RooAbsHiddenReal(void *p) {
      typedef ::RooAbsHiddenReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsHiddenReal

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCategory(void *p) {
      return  p ? new(p) ::RooCategory : new ::RooCategory;
   }
   static void *newArray_RooCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooCategory[nElements] : new ::RooCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCategory(void *p) {
      delete ((::RooCategory*)p);
   }
   static void deleteArray_RooCategory(void *p) {
      delete [] ((::RooCategory*)p);
   }
   static void destruct_RooCategory(void *p) {
      typedef ::RooCategory current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooCategory(TBuffer &buf, void *obj) {
      ((::RooCategory*)obj)->::RooCategory::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooCategory

//______________________________________________________________________________
void RooNumIntConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumIntConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumIntConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumIntConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumIntConfig(void *p) {
      return  p ? new(p) ::RooNumIntConfig : new ::RooNumIntConfig;
   }
   static void *newArray_RooNumIntConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumIntConfig[nElements] : new ::RooNumIntConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumIntConfig(void *p) {
      delete ((::RooNumIntConfig*)p);
   }
   static void deleteArray_RooNumIntConfig(void *p) {
      delete [] ((::RooNumIntConfig*)p);
   }
   static void destruct_RooNumIntConfig(void *p) {
      typedef ::RooNumIntConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumIntConfig

//______________________________________________________________________________
void RooAbsIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsIntegrator(void *p) {
      delete ((::RooAbsIntegrator*)p);
   }
   static void deleteArray_RooAbsIntegrator(void *p) {
      delete [] ((::RooAbsIntegrator*)p);
   }
   static void destruct_RooAbsIntegrator(void *p) {
      typedef ::RooAbsIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsIntegrator

//______________________________________________________________________________
void RooMCStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMCStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMCStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMCStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMCStudy(void *p) {
      delete ((::RooMCStudy*)p);
   }
   static void deleteArray_RooMCStudy(void *p) {
      delete [] ((::RooMCStudy*)p);
   }
   static void destruct_RooMCStudy(void *p) {
      typedef ::RooMCStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMCStudy

//______________________________________________________________________________
void RooAbsMCStudyModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsMCStudyModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsMCStudyModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsMCStudyModule::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsMCStudyModule(void *p) {
      delete ((::RooAbsMCStudyModule*)p);
   }
   static void deleteArray_RooAbsMCStudyModule(void *p) {
      delete [] ((::RooAbsMCStudyModule*)p);
   }
   static void destruct_RooAbsMCStudyModule(void *p) {
      typedef ::RooAbsMCStudyModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsMCStudyModule

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealVar(void *p) {
      return  p ? new(p) ::RooRealVar : new ::RooRealVar;
   }
   static void *newArray_RooRealVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealVar[nElements] : new ::RooRealVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealVar(void *p) {
      delete ((::RooRealVar*)p);
   }
   static void deleteArray_RooRealVar(void *p) {
      delete [] ((::RooRealVar*)p);
   }
   static void destruct_RooRealVar(void *p) {
      typedef ::RooRealVar current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooRealVar(TBuffer &buf, void *obj) {
      ((::RooRealVar*)obj)->::RooRealVar::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooRealVar

//______________________________________________________________________________
void RooAbsMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsMoment(void *p) {
      delete ((::RooAbsMoment*)p);
   }
   static void deleteArray_RooAbsMoment(void *p) {
      delete [] ((::RooAbsMoment*)p);
   }
   static void destruct_RooAbsMoment(void *p) {
      typedef ::RooAbsMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsMoment

//______________________________________________________________________________
void RooAbsNumGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsNumGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsNumGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsNumGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsNumGenerator(void *p) {
      delete ((::RooAbsNumGenerator*)p);
   }
   static void deleteArray_RooAbsNumGenerator(void *p) {
      delete [] ((::RooAbsNumGenerator*)p);
   }
   static void destruct_RooAbsNumGenerator(void *p) {
      typedef ::RooAbsNumGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsNumGenerator

//______________________________________________________________________________
void RooAbsTestStatistic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsTestStatistic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsTestStatistic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsTestStatistic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsTestStatistic(void *p) {
      delete ((::RooAbsTestStatistic*)p);
   }
   static void deleteArray_RooAbsTestStatistic(void *p) {
      delete [] ((::RooAbsTestStatistic*)p);
   }
   static void destruct_RooAbsTestStatistic(void *p) {
      typedef ::RooAbsTestStatistic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsTestStatistic

//______________________________________________________________________________
void RooAbsOptTestStatistic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsOptTestStatistic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsOptTestStatistic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsOptTestStatistic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsOptTestStatistic(void *p) {
      delete ((::RooAbsOptTestStatistic*)p);
   }
   static void deleteArray_RooAbsOptTestStatistic(void *p) {
      delete [] ((::RooAbsOptTestStatistic*)p);
   }
   static void destruct_RooAbsOptTestStatistic(void *p) {
      typedef ::RooAbsOptTestStatistic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsOptTestStatistic

//______________________________________________________________________________
void RooAbsRootFinder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsRootFinder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsRootFinder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsRootFinder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsRootFinder(void *p) {
      delete ((::RooAbsRootFinder*)p);
   }
   static void deleteArray_RooAbsRootFinder(void *p) {
      delete [] ((::RooAbsRootFinder*)p);
   }
   static void destruct_RooAbsRootFinder(void *p) {
      typedef ::RooAbsRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsRootFinder

//______________________________________________________________________________
void RooAbsSelfCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsSelfCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsSelfCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsSelfCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsSelfCachedPdf(void *p) {
      delete ((::RooAbsSelfCachedPdf*)p);
   }
   static void deleteArray_RooAbsSelfCachedPdf(void *p) {
      delete [] ((::RooAbsSelfCachedPdf*)p);
   }
   static void destruct_RooAbsSelfCachedPdf(void *p) {
      typedef ::RooAbsSelfCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsSelfCachedPdf

//______________________________________________________________________________
void RooAbsSelfCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsSelfCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsSelfCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsSelfCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsSelfCachedReal(void *p) {
      delete ((::RooAbsSelfCachedReal*)p);
   }
   static void deleteArray_RooAbsSelfCachedReal(void *p) {
      delete [] ((::RooAbsSelfCachedReal*)p);
   }
   static void destruct_RooAbsSelfCachedReal(void *p) {
      typedef ::RooAbsSelfCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsSelfCachedReal

//______________________________________________________________________________
void RooStringVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStringVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStringVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStringVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooStringVar(void *p) {
      return  p ? new(p) ::RooStringVar : new ::RooStringVar;
   }
   static void *newArray_RooStringVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooStringVar[nElements] : new ::RooStringVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooStringVar(void *p) {
      delete ((::RooStringVar*)p);
   }
   static void deleteArray_RooStringVar(void *p) {
      delete [] ((::RooStringVar*)p);
   }
   static void destruct_RooStringVar(void *p) {
      typedef ::RooStringVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStringVar

//______________________________________________________________________________
void RooAbsStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAbsStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAbsStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAbsStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAbsStudy(void *p) {
      delete ((::RooAbsStudy*)p);
   }
   static void deleteArray_RooAbsStudy(void *p) {
      delete [] ((::RooAbsStudy*)p);
   }
   static void destruct_RooAbsStudy(void *p) {
      typedef ::RooAbsStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAbsStudy

//______________________________________________________________________________
void RooAcceptReject::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAcceptReject.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAcceptReject::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAcceptReject::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAcceptReject(void *p) {
      return  p ? new(p) ::RooAcceptReject : new ::RooAcceptReject;
   }
   static void *newArray_RooAcceptReject(Long_t nElements, void *p) {
      return p ? new(p) ::RooAcceptReject[nElements] : new ::RooAcceptReject[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAcceptReject(void *p) {
      delete ((::RooAcceptReject*)p);
   }
   static void deleteArray_RooAcceptReject(void *p) {
      delete [] ((::RooAcceptReject*)p);
   }
   static void destruct_RooAcceptReject(void *p) {
      typedef ::RooAcceptReject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAcceptReject

//______________________________________________________________________________
void RooAdaptiveIntegratorND::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAdaptiveIntegratorND.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAdaptiveIntegratorND::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAdaptiveIntegratorND::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAdaptiveIntegratorND(void *p) {
      return  p ? new(p) ::RooAdaptiveIntegratorND : new ::RooAdaptiveIntegratorND;
   }
   static void *newArray_RooAdaptiveIntegratorND(Long_t nElements, void *p) {
      return p ? new(p) ::RooAdaptiveIntegratorND[nElements] : new ::RooAdaptiveIntegratorND[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAdaptiveIntegratorND(void *p) {
      delete ((::RooAdaptiveIntegratorND*)p);
   }
   static void deleteArray_RooAdaptiveIntegratorND(void *p) {
      delete [] ((::RooAdaptiveIntegratorND*)p);
   }
   static void destruct_RooAdaptiveIntegratorND(void *p) {
      typedef ::RooAdaptiveIntegratorND current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAdaptiveIntegratorND

//______________________________________________________________________________
void RooAddPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddPdf(void *p) {
      return  p ? new(p) ::RooAddPdf : new ::RooAddPdf;
   }
   static void *newArray_RooAddPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddPdf[nElements] : new ::RooAddPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddPdf(void *p) {
      delete ((::RooAddPdf*)p);
   }
   static void deleteArray_RooAddPdf(void *p) {
      delete [] ((::RooAddPdf*)p);
   }
   static void destruct_RooAddPdf(void *p) {
      typedef ::RooAddPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddPdf

//______________________________________________________________________________
void RooFormula::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFormula.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFormula::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFormula::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFormula(void *p) {
      return  p ? new(p) ::RooFormula : new ::RooFormula;
   }
   static void *newArray_RooFormula(Long_t nElements, void *p) {
      return p ? new(p) ::RooFormula[nElements] : new ::RooFormula[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFormula(void *p) {
      delete ((::RooFormula*)p);
   }
   static void deleteArray_RooFormula(void *p) {
      delete [] ((::RooFormula*)p);
   }
   static void destruct_RooFormula(void *p) {
      typedef ::RooFormula current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFormula

//______________________________________________________________________________
void RooFormulaVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFormulaVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFormulaVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFormulaVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFormulaVar(void *p) {
      return  p ? new(p) ::RooFormulaVar : new ::RooFormulaVar;
   }
   static void *newArray_RooFormulaVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooFormulaVar[nElements] : new ::RooFormulaVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFormulaVar(void *p) {
      delete ((::RooFormulaVar*)p);
   }
   static void deleteArray_RooFormulaVar(void *p) {
      delete [] ((::RooFormulaVar*)p);
   }
   static void destruct_RooFormulaVar(void *p) {
      typedef ::RooFormulaVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFormulaVar

//______________________________________________________________________________
void RooResolutionModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooResolutionModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooResolutionModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooResolutionModel::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooResolutionModel(void *p) {
      delete ((::RooResolutionModel*)p);
   }
   static void deleteArray_RooResolutionModel(void *p) {
      delete [] ((::RooResolutionModel*)p);
   }
   static void destruct_RooResolutionModel(void *p) {
      typedef ::RooResolutionModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooResolutionModel

//______________________________________________________________________________
void RooAddModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddModel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddModel(void *p) {
      return  p ? new(p) ::RooAddModel : new ::RooAddModel;
   }
   static void *newArray_RooAddModel(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddModel[nElements] : new ::RooAddModel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddModel(void *p) {
      delete ((::RooAddModel*)p);
   }
   static void deleteArray_RooAddModel(void *p) {
      delete [] ((::RooAddModel*)p);
   }
   static void destruct_RooAddModel(void *p) {
      typedef ::RooAddModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddModel

//______________________________________________________________________________
void RooAddGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooAddGenContext(void *p) {
      delete ((::RooAddGenContext*)p);
   }
   static void deleteArray_RooAddGenContext(void *p) {
      delete [] ((::RooAddGenContext*)p);
   }
   static void destruct_RooAddGenContext(void *p) {
      typedef ::RooAddGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddGenContext

//______________________________________________________________________________
void RooAddition::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooAddition.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooAddition::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooAddition::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooAddition(void *p) {
      return  p ? new(p) ::RooAddition : new ::RooAddition;
   }
   static void *newArray_RooAddition(Long_t nElements, void *p) {
      return p ? new(p) ::RooAddition[nElements] : new ::RooAddition[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooAddition(void *p) {
      delete ((::RooAddition*)p);
   }
   static void deleteArray_RooAddition(void *p) {
      delete [] ((::RooAddition*)p);
   }
   static void destruct_RooAddition(void *p) {
      typedef ::RooAddition current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooAddition

//______________________________________________________________________________
void RooBinIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinIntegrator(void *p) {
      return  p ? new(p) ::RooBinIntegrator : new ::RooBinIntegrator;
   }
   static void *newArray_RooBinIntegrator(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinIntegrator[nElements] : new ::RooBinIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinIntegrator(void *p) {
      delete ((::RooBinIntegrator*)p);
   }
   static void deleteArray_RooBinIntegrator(void *p) {
      delete [] ((::RooBinIntegrator*)p);
   }
   static void destruct_RooBinIntegrator(void *p) {
      typedef ::RooBinIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinIntegrator

//______________________________________________________________________________
void RooBinnedGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinnedGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinnedGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinnedGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooBinnedGenContext(void *p) {
      delete ((::RooBinnedGenContext*)p);
   }
   static void deleteArray_RooBinnedGenContext(void *p) {
      delete [] ((::RooBinnedGenContext*)p);
   }
   static void destruct_RooBinnedGenContext(void *p) {
      typedef ::RooBinnedGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinnedGenContext

//______________________________________________________________________________
void RooBinningCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinningCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinningCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinningCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinningCategory(void *p) {
      return  p ? new(p) ::RooBinningCategory : new ::RooBinningCategory;
   }
   static void *newArray_RooBinningCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinningCategory[nElements] : new ::RooBinningCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinningCategory(void *p) {
      delete ((::RooBinningCategory*)p);
   }
   static void deleteArray_RooBinningCategory(void *p) {
      delete [] ((::RooBinningCategory*)p);
   }
   static void destruct_RooBinningCategory(void *p) {
      typedef ::RooBinningCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinningCategory

//______________________________________________________________________________
void RooDouble::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDouble.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDouble::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDouble::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDouble(void *p) {
      return  p ? new(p) ::RooDouble : new ::RooDouble;
   }
   static void *newArray_RooDouble(Long_t nElements, void *p) {
      return p ? new(p) ::RooDouble[nElements] : new ::RooDouble[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDouble(void *p) {
      delete ((::RooDouble*)p);
   }
   static void deleteArray_RooDouble(void *p) {
      delete [] ((::RooDouble*)p);
   }
   static void destruct_RooDouble(void *p) {
      typedef ::RooDouble current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDouble

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinning(void *p) {
      return  p ? new(p) ::RooBinning : new ::RooBinning;
   }
   static void *newArray_RooBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinning[nElements] : new ::RooBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinning(void *p) {
      delete ((::RooBinning*)p);
   }
   static void deleteArray_RooBinning(void *p) {
      delete [] ((::RooBinning*)p);
   }
   static void destruct_RooBinning(void *p) {
      typedef ::RooBinning current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooBinning(TBuffer &buf, void *obj) {
      ((::RooBinning*)obj)->::RooBinning::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooBinning

//______________________________________________________________________________
void RooBrentRootFinder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBrentRootFinder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBrentRootFinder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBrentRootFinder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooBrentRootFinder(void *p) {
      delete ((::RooBrentRootFinder*)p);
   }
   static void deleteArray_RooBrentRootFinder(void *p) {
      delete [] ((::RooBrentRootFinder*)p);
   }
   static void destruct_RooBrentRootFinder(void *p) {
      typedef ::RooBrentRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBrentRootFinder

//______________________________________________________________________________
void RooCachedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCachedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCachedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCachedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCachedPdf(void *p) {
      return  p ? new(p) ::RooCachedPdf : new ::RooCachedPdf;
   }
   static void *newArray_RooCachedPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooCachedPdf[nElements] : new ::RooCachedPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCachedPdf(void *p) {
      delete ((::RooCachedPdf*)p);
   }
   static void deleteArray_RooCachedPdf(void *p) {
      delete [] ((::RooCachedPdf*)p);
   }
   static void destruct_RooCachedPdf(void *p) {
      typedef ::RooCachedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCachedPdf

//______________________________________________________________________________
void RooCachedReal::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCachedReal.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCachedReal::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCachedReal::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCachedReal(void *p) {
      return  p ? new(p) ::RooCachedReal : new ::RooCachedReal;
   }
   static void *newArray_RooCachedReal(Long_t nElements, void *p) {
      return p ? new(p) ::RooCachedReal[nElements] : new ::RooCachedReal[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCachedReal(void *p) {
      delete ((::RooCachedReal*)p);
   }
   static void deleteArray_RooCachedReal(void *p) {
      delete [] ((::RooCachedReal*)p);
   }
   static void destruct_RooCachedReal(void *p) {
      typedef ::RooCachedReal current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCachedReal

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataHist(void *p) {
      return  p ? new(p) ::RooDataHist : new ::RooDataHist;
   }
   static void *newArray_RooDataHist(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataHist[nElements] : new ::RooDataHist[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataHist(void *p) {
      delete ((::RooDataHist*)p);
   }
   static void deleteArray_RooDataHist(void *p) {
      delete [] ((::RooDataHist*)p);
   }
   static void destruct_RooDataHist(void *p) {
      typedef ::RooDataHist current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooDataHist(TBuffer &buf, void *obj) {
      ((::RooDataHist*)obj)->::RooDataHist::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooDataHist

//______________________________________________________________________________
void RooChi2Var::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooChi2Var.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooChi2Var::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooChi2Var::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooChi2Var(void *p) {
      delete ((::RooChi2Var*)p);
   }
   static void deleteArray_RooChi2Var(void *p) {
      delete [] ((::RooChi2Var*)p);
   }
   static void destruct_RooChi2Var(void *p) {
      typedef ::RooChi2Var current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooChi2Var

//______________________________________________________________________________
void RooFactoryWSTool::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFactoryWSTool.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFactoryWSTool::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFactoryWSTool::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFactoryWSTool(void *p) {
      delete ((::RooFactoryWSTool*)p);
   }
   static void deleteArray_RooFactoryWSTool(void *p) {
      delete [] ((::RooFactoryWSTool*)p);
   }
   static void destruct_RooFactoryWSTool(void *p) {
      typedef ::RooFactoryWSTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFactoryWSTool

//______________________________________________________________________________
void RooClassFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooClassFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooClassFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooClassFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooClassFactory(void *p) {
      return  p ? new(p) ::RooClassFactory : new ::RooClassFactory;
   }
   static void *newArray_RooClassFactory(Long_t nElements, void *p) {
      return p ? new(p) ::RooClassFactory[nElements] : new ::RooClassFactory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooClassFactory(void *p) {
      delete ((::RooClassFactory*)p);
   }
   static void deleteArray_RooClassFactory(void *p) {
      delete [] ((::RooClassFactory*)p);
   }
   static void destruct_RooClassFactory(void *p) {
      typedef ::RooClassFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooClassFactory

//______________________________________________________________________________
void RooCmdConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCmdConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCmdConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCmdConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooCmdConfig(void *p) {
      delete ((::RooCmdConfig*)p);
   }
   static void deleteArray_RooCmdConfig(void *p) {
      delete [] ((::RooCmdConfig*)p);
   }
   static void destruct_RooCmdConfig(void *p) {
      typedef ::RooCmdConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCmdConfig

//______________________________________________________________________________
void RooCompositeDataStore::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCompositeDataStore.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCompositeDataStore::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCompositeDataStore::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCompositeDataStore(void *p) {
      return  p ? new(p) ::RooCompositeDataStore : new ::RooCompositeDataStore;
   }
   static void *newArray_RooCompositeDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooCompositeDataStore[nElements] : new ::RooCompositeDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCompositeDataStore(void *p) {
      delete ((::RooCompositeDataStore*)p);
   }
   static void deleteArray_RooCompositeDataStore(void *p) {
      delete [] ((::RooCompositeDataStore*)p);
   }
   static void destruct_RooCompositeDataStore(void *p) {
      typedef ::RooCompositeDataStore current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCompositeDataStore

//______________________________________________________________________________
void RooConstraintSum::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConstraintSum.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConstraintSum::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConstraintSum::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConstraintSum(void *p) {
      return  p ? new(p) ::RooConstraintSum : new ::RooConstraintSum;
   }
   static void *newArray_RooConstraintSum(Long_t nElements, void *p) {
      return p ? new(p) ::RooConstraintSum[nElements] : new ::RooConstraintSum[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConstraintSum(void *p) {
      delete ((::RooConstraintSum*)p);
   }
   static void deleteArray_RooConstraintSum(void *p) {
      delete [] ((::RooConstraintSum*)p);
   }
   static void destruct_RooConstraintSum(void *p) {
      typedef ::RooConstraintSum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConstraintSum

//______________________________________________________________________________
void RooConstVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConstVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConstVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConstVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConstVar(void *p) {
      return  p ? new(p) ::RooConstVar : new ::RooConstVar;
   }
   static void *newArray_RooConstVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooConstVar[nElements] : new ::RooConstVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConstVar(void *p) {
      delete ((::RooConstVar*)p);
   }
   static void deleteArray_RooConstVar(void *p) {
      delete [] ((::RooConstVar*)p);
   }
   static void destruct_RooConstVar(void *p) {
      typedef ::RooConstVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConstVar

//______________________________________________________________________________
void RooConvCoefVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvCoefVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvCoefVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvCoefVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooConvCoefVar(void *p) {
      return  p ? new(p) ::RooConvCoefVar : new ::RooConvCoefVar;
   }
   static void *newArray_RooConvCoefVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooConvCoefVar[nElements] : new ::RooConvCoefVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooConvCoefVar(void *p) {
      delete ((::RooConvCoefVar*)p);
   }
   static void deleteArray_RooConvCoefVar(void *p) {
      delete [] ((::RooConvCoefVar*)p);
   }
   static void destruct_RooConvCoefVar(void *p) {
      typedef ::RooConvCoefVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvCoefVar

//______________________________________________________________________________
void RooConvGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooConvGenContext(void *p) {
      delete ((::RooConvGenContext*)p);
   }
   static void deleteArray_RooConvGenContext(void *p) {
      delete [] ((::RooConvGenContext*)p);
   }
   static void destruct_RooConvGenContext(void *p) {
      typedef ::RooConvGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvGenContext

//______________________________________________________________________________
void RooConvIntegrandBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooConvIntegrandBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooConvIntegrandBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooConvIntegrandBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooConvIntegrandBinding(void *p) {
      delete ((::RooConvIntegrandBinding*)p);
   }
   static void deleteArray_RooConvIntegrandBinding(void *p) {
      delete [] ((::RooConvIntegrandBinding*)p);
   }
   static void destruct_RooConvIntegrandBinding(void *p) {
      typedef ::RooConvIntegrandBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooConvIntegrandBinding

//______________________________________________________________________________
void RooCustomizer::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCustomizer.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCustomizer::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCustomizer::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooCustomizer(void *p) {
      delete ((::RooCustomizer*)p);
   }
   static void deleteArray_RooCustomizer(void *p) {
      delete [] ((::RooCustomizer*)p);
   }
   static void destruct_RooCustomizer(void *p) {
      typedef ::RooCustomizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCustomizer

//______________________________________________________________________________
void RooDataHistSliceIter::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataHistSliceIter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataHistSliceIter::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataHistSliceIter::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDataHistSliceIter(void *p) {
      delete ((::RooDataHistSliceIter*)p);
   }
   static void deleteArray_RooDataHistSliceIter(void *p) {
      delete [] ((::RooDataHistSliceIter*)p);
   }
   static void destruct_RooDataHistSliceIter(void *p) {
      typedef ::RooDataHistSliceIter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataHistSliceIter

//______________________________________________________________________________
void RooRealBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealBinding(void *p) {
      delete ((::RooRealBinding*)p);
   }
   static void deleteArray_RooRealBinding(void *p) {
      delete [] ((::RooRealBinding*)p);
   }
   static void destruct_RooRealBinding(void *p) {
      typedef ::RooRealBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealBinding

//______________________________________________________________________________
void RooDataProjBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataProjBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataProjBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataProjBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDataProjBinding(void *p) {
      delete ((::RooDataProjBinding*)p);
   }
   static void deleteArray_RooDataProjBinding(void *p) {
      delete [] ((::RooDataProjBinding*)p);
   }
   static void destruct_RooDataProjBinding(void *p) {
      typedef ::RooDataProjBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataProjBinding

//______________________________________________________________________________
void RooDataWeightedAverage::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDataWeightedAverage.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDataWeightedAverage::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDataWeightedAverage::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDataWeightedAverage(void *p) {
      return  p ? new(p) ::RooDataWeightedAverage : new ::RooDataWeightedAverage;
   }
   static void *newArray_RooDataWeightedAverage(Long_t nElements, void *p) {
      return p ? new(p) ::RooDataWeightedAverage[nElements] : new ::RooDataWeightedAverage[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDataWeightedAverage(void *p) {
      delete ((::RooDataWeightedAverage*)p);
   }
   static void deleteArray_RooDataWeightedAverage(void *p) {
      delete [] ((::RooDataWeightedAverage*)p);
   }
   static void destruct_RooDataWeightedAverage(void *p) {
      typedef ::RooDataWeightedAverage current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDataWeightedAverage

//______________________________________________________________________________
void RooDerivative::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDerivative.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDerivative::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDerivative::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooDerivative(void *p) {
      return  p ? new(p) ::RooDerivative : new ::RooDerivative;
   }
   static void *newArray_RooDerivative(Long_t nElements, void *p) {
      return p ? new(p) ::RooDerivative[nElements] : new ::RooDerivative[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooDerivative(void *p) {
      delete ((::RooDerivative*)p);
   }
   static void deleteArray_RooDerivative(void *p) {
      delete [] ((::RooDerivative*)p);
   }
   static void destruct_RooDerivative(void *p) {
      typedef ::RooDerivative current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDerivative

//______________________________________________________________________________
void RooDLLSignificanceMCSModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooDLLSignificanceMCSModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooDLLSignificanceMCSModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooDLLSignificanceMCSModule::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooDLLSignificanceMCSModule(void *p) {
      delete ((::RooDLLSignificanceMCSModule*)p);
   }
   static void deleteArray_RooDLLSignificanceMCSModule(void *p) {
      delete [] ((::RooDLLSignificanceMCSModule*)p);
   }
   static void destruct_RooDLLSignificanceMCSModule(void *p) {
      typedef ::RooDLLSignificanceMCSModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooDLLSignificanceMCSModule

//______________________________________________________________________________
void RooEffGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEffGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEffGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEffGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooEffGenContext(void *p) {
      delete ((::RooEffGenContext*)p);
   }
   static void deleteArray_RooEffGenContext(void *p) {
      delete [] ((::RooEffGenContext*)p);
   }
   static void destruct_RooEffGenContext(void *p) {
      typedef ::RooEffGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEffGenContext

//______________________________________________________________________________
void RooEfficiency::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEfficiency.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEfficiency::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEfficiency::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEfficiency(void *p) {
      return  p ? new(p) ::RooEfficiency : new ::RooEfficiency;
   }
   static void *newArray_RooEfficiency(Long_t nElements, void *p) {
      return p ? new(p) ::RooEfficiency[nElements] : new ::RooEfficiency[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEfficiency(void *p) {
      delete ((::RooEfficiency*)p);
   }
   static void deleteArray_RooEfficiency(void *p) {
      delete [] ((::RooEfficiency*)p);
   }
   static void destruct_RooEfficiency(void *p) {
      typedef ::RooEfficiency current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEfficiency

//______________________________________________________________________________
void RooEffProd::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEffProd.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEffProd::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEffProd::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEffProd(void *p) {
      return  p ? new(p) ::RooEffProd : new ::RooEffProd;
   }
   static void *newArray_RooEffProd(Long_t nElements, void *p) {
      return p ? new(p) ::RooEffProd[nElements] : new ::RooEffProd[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEffProd(void *p) {
      delete ((::RooEffProd*)p);
   }
   static void deleteArray_RooEffProd(void *p) {
      delete [] ((::RooEffProd*)p);
   }
   static void destruct_RooEffProd(void *p) {
      typedef ::RooEffProd current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooEffProd

//______________________________________________________________________________
void RooEllipse::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooEllipse.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooEllipse::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooEllipse::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooEllipse(void *p) {
      return  p ? new(p) ::RooEllipse : new ::RooEllipse;
   }
   static void *newArray_RooEllipse(Long_t nElements, void *p) {
      return p ? new(p) ::RooEllipse[nElements] : new ::RooEllipse[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooEllipse(void *p) {
      delete ((::RooEllipse*)p);
   }
   static void deleteArray_RooEllipse(void *p) {
      delete [] ((::RooEllipse*)p);
   }
   static void destruct_RooEllipse(void *p) {
      typedef ::RooEllipse current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooEllipse(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooEllipse*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooEllipse

//______________________________________________________________________________
void RooErrorVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooErrorVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooErrorVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooErrorVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooErrorVar(void *p) {
      return  p ? new(p) ::RooErrorVar : new ::RooErrorVar;
   }
   static void *newArray_RooErrorVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooErrorVar[nElements] : new ::RooErrorVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooErrorVar(void *p) {
      delete ((::RooErrorVar*)p);
   }
   static void deleteArray_RooErrorVar(void *p) {
      delete [] ((::RooErrorVar*)p);
   }
   static void destruct_RooErrorVar(void *p) {
      typedef ::RooErrorVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooErrorVar

//______________________________________________________________________________
void RooExpensiveObjectCache::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExpensiveObjectCache.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExpensiveObjectCache::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExpensiveObjectCache::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExpensiveObjectCache(void *p) {
      return  p ? new(p) ::RooExpensiveObjectCache : new ::RooExpensiveObjectCache;
   }
   static void *newArray_RooExpensiveObjectCache(Long_t nElements, void *p) {
      return p ? new(p) ::RooExpensiveObjectCache[nElements] : new ::RooExpensiveObjectCache[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExpensiveObjectCache(void *p) {
      delete ((::RooExpensiveObjectCache*)p);
   }
   static void deleteArray_RooExpensiveObjectCache(void *p) {
      delete [] ((::RooExpensiveObjectCache*)p);
   }
   static void destruct_RooExpensiveObjectCache(void *p) {
      typedef ::RooExpensiveObjectCache current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExpensiveObjectCache

//______________________________________________________________________________
void RooExpensiveObjectCache::ExpensiveObject::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExpensiveObjectCache::ExpensiveObject.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExpensiveObjectCache::ExpensiveObject::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExpensiveObjectCache::ExpensiveObject::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      return  p ? new(p) ::RooExpensiveObjectCache::ExpensiveObject : new ::RooExpensiveObjectCache::ExpensiveObject;
   }
   static void *newArray_RooExpensiveObjectCachecLcLExpensiveObject(Long_t nElements, void *p) {
      return p ? new(p) ::RooExpensiveObjectCache::ExpensiveObject[nElements] : new ::RooExpensiveObjectCache::ExpensiveObject[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      delete ((::RooExpensiveObjectCache::ExpensiveObject*)p);
   }
   static void deleteArray_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      delete [] ((::RooExpensiveObjectCache::ExpensiveObject*)p);
   }
   static void destruct_RooExpensiveObjectCachecLcLExpensiveObject(void *p) {
      typedef ::RooExpensiveObjectCache::ExpensiveObject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExpensiveObjectCache::ExpensiveObject

//______________________________________________________________________________
void RooExtendedBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendedBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendedBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendedBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendedBinding(void *p) {
      return  p ? new(p) ::RooExtendedBinding : new ::RooExtendedBinding;
   }
   static void *newArray_RooExtendedBinding(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendedBinding[nElements] : new ::RooExtendedBinding[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendedBinding(void *p) {
      delete ((::RooExtendedBinding*)p);
   }
   static void deleteArray_RooExtendedBinding(void *p) {
      delete [] ((::RooExtendedBinding*)p);
   }
   static void destruct_RooExtendedBinding(void *p) {
      typedef ::RooExtendedBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendedBinding

//______________________________________________________________________________
void RooExtendedTerm::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendedTerm.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendedTerm::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendedTerm::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendedTerm(void *p) {
      return  p ? new(p) ::RooExtendedTerm : new ::RooExtendedTerm;
   }
   static void *newArray_RooExtendedTerm(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendedTerm[nElements] : new ::RooExtendedTerm[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendedTerm(void *p) {
      delete ((::RooExtendedTerm*)p);
   }
   static void deleteArray_RooExtendedTerm(void *p) {
      delete [] ((::RooExtendedTerm*)p);
   }
   static void destruct_RooExtendedTerm(void *p) {
      typedef ::RooExtendedTerm current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendedTerm

//______________________________________________________________________________
void RooExtendPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooExtendPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooExtendPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooExtendPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooExtendPdf(void *p) {
      return  p ? new(p) ::RooExtendPdf : new ::RooExtendPdf;
   }
   static void *newArray_RooExtendPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooExtendPdf[nElements] : new ::RooExtendPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooExtendPdf(void *p) {
      delete ((::RooExtendPdf*)p);
   }
   static void deleteArray_RooExtendPdf(void *p) {
      delete [] ((::RooExtendPdf*)p);
   }
   static void destruct_RooExtendPdf(void *p) {
      typedef ::RooExtendPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooExtendPdf

//______________________________________________________________________________
void RooFFTConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFFTConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFFTConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFFTConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFFTConvPdf(void *p) {
      return  p ? new(p) ::RooFFTConvPdf : new ::RooFFTConvPdf;
   }
   static void *newArray_RooFFTConvPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooFFTConvPdf[nElements] : new ::RooFFTConvPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFFTConvPdf(void *p) {
      delete ((::RooFFTConvPdf*)p);
   }
   static void deleteArray_RooFFTConvPdf(void *p) {
      delete [] ((::RooFFTConvPdf*)p);
   }
   static void destruct_RooFFTConvPdf(void *p) {
      typedef ::RooFFTConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFFTConvPdf

//______________________________________________________________________________
void RooFirstMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFirstMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFirstMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFirstMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFirstMoment(void *p) {
      return  p ? new(p) ::RooFirstMoment : new ::RooFirstMoment;
   }
   static void *newArray_RooFirstMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooFirstMoment[nElements] : new ::RooFirstMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFirstMoment(void *p) {
      delete ((::RooFirstMoment*)p);
   }
   static void deleteArray_RooFirstMoment(void *p) {
      delete [] ((::RooFirstMoment*)p);
   }
   static void destruct_RooFirstMoment(void *p) {
      typedef ::RooFirstMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFirstMoment

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFitResult(void *p) {
      return  p ? new(p) ::RooFitResult : new ::RooFitResult;
   }
   static void *newArray_RooFitResult(Long_t nElements, void *p) {
      return p ? new(p) ::RooFitResult[nElements] : new ::RooFitResult[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFitResult(void *p) {
      delete ((::RooFitResult*)p);
   }
   static void deleteArray_RooFitResult(void *p) {
      delete [] ((::RooFitResult*)p);
   }
   static void destruct_RooFitResult(void *p) {
      typedef ::RooFitResult current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooFitResult(TBuffer &buf, void *obj) {
      ((::RooFitResult*)obj)->::RooFitResult::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooFitResult

//______________________________________________________________________________
void RooFoamGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFoamGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFoamGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFoamGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFoamGenerator(void *p) {
      return  p ? new(p) ::RooFoamGenerator : new ::RooFoamGenerator;
   }
   static void *newArray_RooFoamGenerator(Long_t nElements, void *p) {
      return p ? new(p) ::RooFoamGenerator[nElements] : new ::RooFoamGenerator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFoamGenerator(void *p) {
      delete ((::RooFoamGenerator*)p);
   }
   static void deleteArray_RooFoamGenerator(void *p) {
      delete [] ((::RooFoamGenerator*)p);
   }
   static void destruct_RooFoamGenerator(void *p) {
      typedef ::RooFoamGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFoamGenerator

//______________________________________________________________________________
void RooFracRemainder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFracRemainder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFracRemainder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFracRemainder::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooFracRemainder(void *p) {
      return  p ? new(p) ::RooFracRemainder : new ::RooFracRemainder;
   }
   static void *newArray_RooFracRemainder(Long_t nElements, void *p) {
      return p ? new(p) ::RooFracRemainder[nElements] : new ::RooFracRemainder[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooFracRemainder(void *p) {
      delete ((::RooFracRemainder*)p);
   }
   static void deleteArray_RooFracRemainder(void *p) {
      delete [] ((::RooFracRemainder*)p);
   }
   static void destruct_RooFracRemainder(void *p) {
      typedef ::RooFracRemainder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFracRemainder

//______________________________________________________________________________
void RooFunctor::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFunctor.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFunctor::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFunctor::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFunctor(void *p) {
      delete ((::RooFunctor*)p);
   }
   static void deleteArray_RooFunctor(void *p) {
      delete [] ((::RooFunctor*)p);
   }
   static void destruct_RooFunctor(void *p) {
      typedef ::RooFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFunctor

//______________________________________________________________________________
void RooGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooGenContext(void *p) {
      delete ((::RooGenContext*)p);
   }
   static void deleteArray_RooGenContext(void *p) {
      delete [] ((::RooGenContext*)p);
   }
   static void destruct_RooGenContext(void *p) {
      typedef ::RooGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenContext

//______________________________________________________________________________
void RooGenericPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenericPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenericPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenericPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenericPdf(void *p) {
      return  p ? new(p) ::RooGenericPdf : new ::RooGenericPdf;
   }
   static void *newArray_RooGenericPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenericPdf[nElements] : new ::RooGenericPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenericPdf(void *p) {
      delete ((::RooGenericPdf*)p);
   }
   static void deleteArray_RooGenericPdf(void *p) {
      delete [] ((::RooGenericPdf*)p);
   }
   static void destruct_RooGenericPdf(void *p) {
      typedef ::RooGenericPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenericPdf

//______________________________________________________________________________
void RooGenFitStudy::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenFitStudy.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenFitStudy::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenFitStudy::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenFitStudy(void *p) {
      return  p ? new(p) ::RooGenFitStudy : new ::RooGenFitStudy;
   }
   static void *newArray_RooGenFitStudy(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenFitStudy[nElements] : new ::RooGenFitStudy[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenFitStudy(void *p) {
      delete ((::RooGenFitStudy*)p);
   }
   static void deleteArray_RooGenFitStudy(void *p) {
      delete [] ((::RooGenFitStudy*)p);
   }
   static void destruct_RooGenFitStudy(void *p) {
      typedef ::RooGenFitStudy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenFitStudy

//______________________________________________________________________________
void RooGenFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenFunction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenFunction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenFunction::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooGenFunction(void *p) {
      delete ((::RooGenFunction*)p);
   }
   static void deleteArray_RooGenFunction(void *p) {
      delete [] ((::RooGenFunction*)p);
   }
   static void destruct_RooGenFunction(void *p) {
      typedef ::RooGenFunction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenFunction

//______________________________________________________________________________
void RooGenProdProj::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGenProdProj.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGenProdProj::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGenProdProj::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGenProdProj(void *p) {
      return  p ? new(p) ::RooGenProdProj : new ::RooGenProdProj;
   }
   static void *newArray_RooGenProdProj(Long_t nElements, void *p) {
      return p ? new(p) ::RooGenProdProj[nElements] : new ::RooGenProdProj[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGenProdProj(void *p) {
      delete ((::RooGenProdProj*)p);
   }
   static void deleteArray_RooGenProdProj(void *p) {
      delete [] ((::RooGenProdProj*)p);
   }
   static void destruct_RooGenProdProj(void *p) {
      typedef ::RooGenProdProj current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGenProdProj

//______________________________________________________________________________
void RooGrid::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooGrid.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooGrid::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooGrid::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooGrid(void *p) {
      return  p ? new(p) ::RooGrid : new ::RooGrid;
   }
   static void *newArray_RooGrid(Long_t nElements, void *p) {
      return p ? new(p) ::RooGrid[nElements] : new ::RooGrid[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooGrid(void *p) {
      delete ((::RooGrid*)p);
   }
   static void deleteArray_RooGrid(void *p) {
      delete [] ((::RooGrid*)p);
   }
   static void destruct_RooGrid(void *p) {
      typedef ::RooGrid current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooGrid

//______________________________________________________________________________
void RooHistError::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHistError.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHistError::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHistError::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooHistError(void *p) {
      delete ((::RooHistError*)p);
   }
   static void deleteArray_RooHistError(void *p) {
      delete [] ((::RooHistError*)p);
   }
   static void destruct_RooHistError(void *p) {
      typedef ::RooHistError current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooHistError

//______________________________________________________________________________
void RooHist::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHist.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHist::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHist::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHist(void *p) {
      return  p ? new(p) ::RooHist : new ::RooHist;
   }
   static void *newArray_RooHist(Long_t nElements, void *p) {
      return p ? new(p) ::RooHist[nElements] : new ::RooHist[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHist(void *p) {
      delete ((::RooHist*)p);
   }
   static void deleteArray_RooHist(void *p) {
      delete [] ((::RooHist*)p);
   }
   static void destruct_RooHist(void *p) {
      typedef ::RooHist current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooHist(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooHist*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooHist

//______________________________________________________________________________
void RooImproperIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooImproperIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooImproperIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooImproperIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooImproperIntegrator1D(void *p) {
      return  p ? new(p) ::RooImproperIntegrator1D : new ::RooImproperIntegrator1D;
   }
   static void *newArray_RooImproperIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooImproperIntegrator1D[nElements] : new ::RooImproperIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooImproperIntegrator1D(void *p) {
      delete ((::RooImproperIntegrator1D*)p);
   }
   static void deleteArray_RooImproperIntegrator1D(void *p) {
      delete [] ((::RooImproperIntegrator1D*)p);
   }
   static void destruct_RooImproperIntegrator1D(void *p) {
      typedef ::RooImproperIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooImproperIntegrator1D

//______________________________________________________________________________
void RooIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooIntegrator1D(void *p) {
      return  p ? new(p) ::RooIntegrator1D : new ::RooIntegrator1D;
   }
   static void *newArray_RooIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooIntegrator1D[nElements] : new ::RooIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooIntegrator1D(void *p) {
      delete ((::RooIntegrator1D*)p);
   }
   static void deleteArray_RooIntegrator1D(void *p) {
      delete [] ((::RooIntegrator1D*)p);
   }
   static void destruct_RooIntegrator1D(void *p) {
      typedef ::RooIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegrator1D

//______________________________________________________________________________
void RooIntegrator2D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegrator2D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegrator2D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegrator2D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooIntegrator2D(void *p) {
      return  p ? new(p) ::RooIntegrator2D : new ::RooIntegrator2D;
   }
   static void *newArray_RooIntegrator2D(Long_t nElements, void *p) {
      return p ? new(p) ::RooIntegrator2D[nElements] : new ::RooIntegrator2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooIntegrator2D(void *p) {
      delete ((::RooIntegrator2D*)p);
   }
   static void deleteArray_RooIntegrator2D(void *p) {
      delete [] ((::RooIntegrator2D*)p);
   }
   static void destruct_RooIntegrator2D(void *p) {
      typedef ::RooIntegrator2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegrator2D

//______________________________________________________________________________
void RooIntegratorBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooIntegratorBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooIntegratorBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooIntegratorBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooIntegratorBinding(void *p) {
      delete ((::RooIntegratorBinding*)p);
   }
   static void deleteArray_RooIntegratorBinding(void *p) {
      delete [] ((::RooIntegratorBinding*)p);
   }
   static void destruct_RooIntegratorBinding(void *p) {
      typedef ::RooIntegratorBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooIntegratorBinding

//______________________________________________________________________________
void RooInt::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooInt.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooInt::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooInt::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooInt(void *p) {
      return  p ? new(p) ::RooInt : new ::RooInt;
   }
   static void *newArray_RooInt(Long_t nElements, void *p) {
      return p ? new(p) ::RooInt[nElements] : new ::RooInt[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooInt(void *p) {
      delete ((::RooInt*)p);
   }
   static void deleteArray_RooInt(void *p) {
      delete [] ((::RooInt*)p);
   }
   static void destruct_RooInt(void *p) {
      typedef ::RooInt current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooInt

//______________________________________________________________________________
void RooInvTransform::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooInvTransform.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooInvTransform::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooInvTransform::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooInvTransform(void *p) {
      delete ((::RooInvTransform*)p);
   }
   static void deleteArray_RooInvTransform(void *p) {
      delete [] ((::RooInvTransform*)p);
   }
   static void destruct_RooInvTransform(void *p) {
      typedef ::RooInvTransform current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooInvTransform

//______________________________________________________________________________
void RooLinearCombination::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinearCombination.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinearCombination::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinearCombination::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinearCombination(void *p) {
      return  p ? new(p) ::RooLinearCombination : new ::RooLinearCombination;
   }
   static void *newArray_RooLinearCombination(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinearCombination[nElements] : new ::RooLinearCombination[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinearCombination(void *p) {
      delete ((::RooLinearCombination*)p);
   }
   static void deleteArray_RooLinearCombination(void *p) {
      delete [] ((::RooLinearCombination*)p);
   }
   static void destruct_RooLinearCombination(void *p) {
      typedef ::RooLinearCombination current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinearCombination

//______________________________________________________________________________
void RooLinTransBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinTransBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinTransBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinTransBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinTransBinning(void *p) {
      return  p ? new(p) ::RooLinTransBinning : new ::RooLinTransBinning;
   }
   static void *newArray_RooLinTransBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinTransBinning[nElements] : new ::RooLinTransBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinTransBinning(void *p) {
      delete ((::RooLinTransBinning*)p);
   }
   static void deleteArray_RooLinTransBinning(void *p) {
      delete [] ((::RooLinTransBinning*)p);
   }
   static void destruct_RooLinTransBinning(void *p) {
      typedef ::RooLinTransBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinTransBinning

//______________________________________________________________________________
void RooLinearVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooLinearVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooLinearVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooLinearVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooLinearVar(void *p) {
      return  p ? new(p) ::RooLinearVar : new ::RooLinearVar;
   }
   static void *newArray_RooLinearVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooLinearVar[nElements] : new ::RooLinearVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooLinearVar(void *p) {
      delete ((::RooLinearVar*)p);
   }
   static void deleteArray_RooLinearVar(void *p) {
      delete [] ((::RooLinearVar*)p);
   }
   static void destruct_RooLinearVar(void *p) {
      typedef ::RooLinearVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooLinearVar

//______________________________________________________________________________
void RooList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooList(void *p) {
      return  p ? new(p) ::RooList : new ::RooList;
   }
   static void *newArray_RooList(Long_t nElements, void *p) {
      return p ? new(p) ::RooList[nElements] : new ::RooList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooList(void *p) {
      delete ((::RooList*)p);
   }
   static void deleteArray_RooList(void *p) {
      delete [] ((::RooList*)p);
   }
   static void destruct_RooList(void *p) {
      typedef ::RooList current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the merge function.
   static Long64_t  merge_RooList(void *obj,TCollection *coll,TFileMergeInfo *) {
      return ((::RooList*)obj)->Merge(coll);
   }
} // end of namespace ROOT for class ::RooList

//______________________________________________________________________________
void RooMappedCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMappedCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMappedCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMappedCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMappedCategory(void *p) {
      return  p ? new(p) ::RooMappedCategory : new ::RooMappedCategory;
   }
   static void *newArray_RooMappedCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooMappedCategory[nElements] : new ::RooMappedCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMappedCategory(void *p) {
      delete ((::RooMappedCategory*)p);
   }
   static void deleteArray_RooMappedCategory(void *p) {
      delete [] ((::RooMappedCategory*)p);
   }
   static void destruct_RooMappedCategory(void *p) {
      typedef ::RooMappedCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMappedCategory

//______________________________________________________________________________
void RooMappedCategory::Entry::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMappedCategory::Entry.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMappedCategory::Entry::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMappedCategory::Entry::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMappedCategorycLcLEntry(void *p) {
      return  p ? new(p) ::RooMappedCategory::Entry : new ::RooMappedCategory::Entry;
   }
   static void *newArray_RooMappedCategorycLcLEntry(Long_t nElements, void *p) {
      return p ? new(p) ::RooMappedCategory::Entry[nElements] : new ::RooMappedCategory::Entry[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMappedCategorycLcLEntry(void *p) {
      delete ((::RooMappedCategory::Entry*)p);
   }
   static void deleteArray_RooMappedCategorycLcLEntry(void *p) {
      delete [] ((::RooMappedCategory::Entry*)p);
   }
   static void destruct_RooMappedCategorycLcLEntry(void *p) {
      typedef ::RooMappedCategory::Entry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMappedCategory::Entry

//______________________________________________________________________________
void RooMCIntegrator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMCIntegrator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMCIntegrator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMCIntegrator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMCIntegrator(void *p) {
      return  p ? new(p) ::RooMCIntegrator : new ::RooMCIntegrator;
   }
   static void *newArray_RooMCIntegrator(Long_t nElements, void *p) {
      return p ? new(p) ::RooMCIntegrator[nElements] : new ::RooMCIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMCIntegrator(void *p) {
      delete ((::RooMCIntegrator*)p);
   }
   static void deleteArray_RooMCIntegrator(void *p) {
      delete [] ((::RooMCIntegrator*)p);
   }
   static void destruct_RooMCIntegrator(void *p) {
      typedef ::RooMCIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMCIntegrator

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinimizerFcn(void *p) {
      delete ((::RooMinimizerFcn*)p);
   }
   static void deleteArray_RooMinimizerFcn(void *p) {
      delete [] ((::RooMinimizerFcn*)p);
   }
   static void destruct_RooMinimizerFcn(void *p) {
      typedef ::RooMinimizerFcn current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinimizerFcn

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSentinel(void *p) {
      delete ((::RooSentinel*)p);
   }
   static void deleteArray_RooSentinel(void *p) {
      delete [] ((::RooSentinel*)p);
   }
   static void destruct_RooSentinel(void *p) {
      typedef ::RooSentinel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSentinel

//______________________________________________________________________________
void RooMinimizer::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMinimizer.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMinimizer::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMinimizer::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinimizer(void *p) {
      delete ((::RooMinimizer*)p);
   }
   static void deleteArray_RooMinimizer(void *p) {
      delete [] ((::RooMinimizer*)p);
   }
   static void destruct_RooMinimizer(void *p) {
      typedef ::RooMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinimizer

//______________________________________________________________________________
void RooMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMoment(void *p) {
      return  p ? new(p) ::RooMoment : new ::RooMoment;
   }
   static void *newArray_RooMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooMoment[nElements] : new ::RooMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMoment(void *p) {
      delete ((::RooMoment*)p);
   }
   static void deleteArray_RooMoment(void *p) {
      delete [] ((::RooMoment*)p);
   }
   static void destruct_RooMoment(void *p) {
      typedef ::RooMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMoment

//______________________________________________________________________________
void RooMPSentinel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMPSentinel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMPSentinel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMPSentinel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMPSentinel(void *p) {
      return  p ? new(p) ::RooMPSentinel : new ::RooMPSentinel;
   }
   static void *newArray_RooMPSentinel(Long_t nElements, void *p) {
      return p ? new(p) ::RooMPSentinel[nElements] : new ::RooMPSentinel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMPSentinel(void *p) {
      delete ((::RooMPSentinel*)p);
   }
   static void deleteArray_RooMPSentinel(void *p) {
      delete [] ((::RooMPSentinel*)p);
   }
   static void destruct_RooMPSentinel(void *p) {
      typedef ::RooMPSentinel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMPSentinel

//______________________________________________________________________________
void RooMultiCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiCategory(void *p) {
      return  p ? new(p) ::RooMultiCategory : new ::RooMultiCategory;
   }
   static void *newArray_RooMultiCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiCategory[nElements] : new ::RooMultiCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiCategory(void *p) {
      delete ((::RooMultiCategory*)p);
   }
   static void deleteArray_RooMultiCategory(void *p) {
      delete [] ((::RooMultiCategory*)p);
   }
   static void destruct_RooMultiCategory(void *p) {
      typedef ::RooMultiCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiCategory

//______________________________________________________________________________
void RooMultiGenFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiGenFunction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiGenFunction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiGenFunction::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMultiGenFunction(void *p) {
      delete ((::RooMultiGenFunction*)p);
   }
   static void deleteArray_RooMultiGenFunction(void *p) {
      delete [] ((::RooMultiGenFunction*)p);
   }
   static void destruct_RooMultiGenFunction(void *p) {
      typedef ::RooMultiGenFunction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiGenFunction

//______________________________________________________________________________
void RooMultiVarGaussian::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMultiVarGaussian.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMultiVarGaussian::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMultiVarGaussian::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussian(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian : new ::RooMultiVarGaussian;
   }
   static void *newArray_RooMultiVarGaussian(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian[nElements] : new ::RooMultiVarGaussian[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussian(void *p) {
      delete ((::RooMultiVarGaussian*)p);
   }
   static void deleteArray_RooMultiVarGaussian(void *p) {
      delete [] ((::RooMultiVarGaussian*)p);
   }
   static void destruct_RooMultiVarGaussian(void *p) {
      typedef ::RooMultiVarGaussian current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian::AnaIntData : new ::RooMultiVarGaussian::AnaIntData;
   }
   static void *newArray_RooMultiVarGaussiancLcLAnaIntData(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian::AnaIntData[nElements] : new ::RooMultiVarGaussian::AnaIntData[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      delete ((::RooMultiVarGaussian::AnaIntData*)p);
   }
   static void deleteArray_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      delete [] ((::RooMultiVarGaussian::AnaIntData*)p);
   }
   static void destruct_RooMultiVarGaussiancLcLAnaIntData(void *p) {
      typedef ::RooMultiVarGaussian::AnaIntData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian::AnaIntData

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooMultiVarGaussiancLcLGenData(void *p) {
      return  p ? new(p) ::RooMultiVarGaussian::GenData : new ::RooMultiVarGaussian::GenData;
   }
   static void *newArray_RooMultiVarGaussiancLcLGenData(Long_t nElements, void *p) {
      return p ? new(p) ::RooMultiVarGaussian::GenData[nElements] : new ::RooMultiVarGaussian::GenData[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooMultiVarGaussiancLcLGenData(void *p) {
      delete ((::RooMultiVarGaussian::GenData*)p);
   }
   static void deleteArray_RooMultiVarGaussiancLcLGenData(void *p) {
      delete [] ((::RooMultiVarGaussian::GenData*)p);
   }
   static void destruct_RooMultiVarGaussiancLcLGenData(void *p) {
      typedef ::RooMultiVarGaussian::GenData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMultiVarGaussian::GenData

//______________________________________________________________________________
void RooNLLVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNLLVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNLLVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNLLVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNLLVar(void *p) {
      return  p ? new(p) ::RooNLLVar : new ::RooNLLVar;
   }
   static void *newArray_RooNLLVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooNLLVar[nElements] : new ::RooNLLVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNLLVar(void *p) {
      delete ((::RooNLLVar*)p);
   }
   static void deleteArray_RooNLLVar(void *p) {
      delete [] ((::RooNLLVar*)p);
   }
   static void destruct_RooNLLVar(void *p) {
      typedef ::RooNLLVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNLLVar

//______________________________________________________________________________
void RooNumRunningInt::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumRunningInt.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumRunningInt::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumRunningInt::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumRunningInt(void *p) {
      delete ((::RooNumRunningInt*)p);
   }
   static void deleteArray_RooNumRunningInt(void *p) {
      delete [] ((::RooNumRunningInt*)p);
   }
   static void destruct_RooNumRunningInt(void *p) {
      typedef ::RooNumRunningInt current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumRunningInt

//______________________________________________________________________________
void RooNumCdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumCdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumCdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumCdf::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumCdf(void *p) {
      delete ((::RooNumCdf*)p);
   }
   static void deleteArray_RooNumCdf(void *p) {
      delete [] ((::RooNumCdf*)p);
   }
   static void destruct_RooNumCdf(void *p) {
      typedef ::RooNumCdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumCdf

//______________________________________________________________________________
void RooNumConvolution::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumConvolution.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumConvolution::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumConvolution::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumConvolution(void *p) {
      return  p ? new(p) ::RooNumConvolution : new ::RooNumConvolution;
   }
   static void *newArray_RooNumConvolution(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumConvolution[nElements] : new ::RooNumConvolution[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumConvolution(void *p) {
      delete ((::RooNumConvolution*)p);
   }
   static void deleteArray_RooNumConvolution(void *p) {
      delete [] ((::RooNumConvolution*)p);
   }
   static void destruct_RooNumConvolution(void *p) {
      typedef ::RooNumConvolution current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumConvolution

//______________________________________________________________________________
void RooNumConvPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumConvPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumConvPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumConvPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumConvPdf(void *p) {
      return  p ? new(p) ::RooNumConvPdf : new ::RooNumConvPdf;
   }
   static void *newArray_RooNumConvPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumConvPdf[nElements] : new ::RooNumConvPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumConvPdf(void *p) {
      delete ((::RooNumConvPdf*)p);
   }
   static void deleteArray_RooNumConvPdf(void *p) {
      delete [] ((::RooNumConvPdf*)p);
   }
   static void destruct_RooNumConvPdf(void *p) {
      typedef ::RooNumConvPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumConvPdf

//______________________________________________________________________________
void RooNumGenConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumGenConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumGenConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumGenConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNumGenConfig(void *p) {
      return  p ? new(p) ::RooNumGenConfig : new ::RooNumGenConfig;
   }
   static void *newArray_RooNumGenConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooNumGenConfig[nElements] : new ::RooNumGenConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNumGenConfig(void *p) {
      delete ((::RooNumGenConfig*)p);
   }
   static void deleteArray_RooNumGenConfig(void *p) {
      delete [] ((::RooNumGenConfig*)p);
   }
   static void destruct_RooNumGenConfig(void *p) {
      typedef ::RooNumGenConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumGenConfig

//______________________________________________________________________________
void RooNumGenFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumGenFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumGenFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumGenFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumGenFactory(void *p) {
      delete ((::RooNumGenFactory*)p);
   }
   static void deleteArray_RooNumGenFactory(void *p) {
      delete [] ((::RooNumGenFactory*)p);
   }
   static void destruct_RooNumGenFactory(void *p) {
      typedef ::RooNumGenFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumGenFactory

//______________________________________________________________________________
void RooNumIntFactory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNumIntFactory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNumIntFactory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNumIntFactory::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooNumIntFactory(void *p) {
      delete ((::RooNumIntFactory*)p);
   }
   static void deleteArray_RooNumIntFactory(void *p) {
      delete [] ((::RooNumIntFactory*)p);
   }
   static void destruct_RooNumIntFactory(void *p) {
      typedef ::RooNumIntFactory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNumIntFactory

//______________________________________________________________________________
void RooParamBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooParamBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooParamBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooParamBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooParamBinning(void *p) {
      return  p ? new(p) ::RooParamBinning : new ::RooParamBinning;
   }
   static void *newArray_RooParamBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooParamBinning[nElements] : new ::RooParamBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooParamBinning(void *p) {
      delete ((::RooParamBinning*)p);
   }
   static void deleteArray_RooParamBinning(void *p) {
      delete [] ((::RooParamBinning*)p);
   }
   static void destruct_RooParamBinning(void *p) {
      typedef ::RooParamBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooParamBinning

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPlot(void *p) {
      return  p ? new(p) ::RooPlot : new ::RooPlot;
   }
   static void *newArray_RooPlot(Long_t nElements, void *p) {
      return p ? new(p) ::RooPlot[nElements] : new ::RooPlot[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPlot(void *p) {
      delete ((::RooPlot*)p);
   }
   static void deleteArray_RooPlot(void *p) {
      delete [] ((::RooPlot*)p);
   }
   static void destruct_RooPlot(void *p) {
      typedef ::RooPlot current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooPlot(TBuffer &buf, void *obj) {
      ((::RooPlot*)obj)->::RooPlot::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooPlot

//______________________________________________________________________________
void RooPolyFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPolyFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPolyFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPolyFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPolyFunc(void *p) {
      return  p ? new(p) ::RooPolyFunc : new ::RooPolyFunc;
   }
   static void *newArray_RooPolyFunc(Long_t nElements, void *p) {
      return p ? new(p) ::RooPolyFunc[nElements] : new ::RooPolyFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPolyFunc(void *p) {
      delete ((::RooPolyFunc*)p);
   }
   static void deleteArray_RooPolyFunc(void *p) {
      delete [] ((::RooPolyFunc*)p);
   }
   static void destruct_RooPolyFunc(void *p) {
      typedef ::RooPolyFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPolyFunc

//______________________________________________________________________________
void RooPolyVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPolyVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPolyVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPolyVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPolyVar(void *p) {
      return  p ? new(p) ::RooPolyVar : new ::RooPolyVar;
   }
   static void *newArray_RooPolyVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooPolyVar[nElements] : new ::RooPolyVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPolyVar(void *p) {
      delete ((::RooPolyVar*)p);
   }
   static void deleteArray_RooPolyVar(void *p) {
      delete [] ((::RooPolyVar*)p);
   }
   static void destruct_RooPolyVar(void *p) {
      typedef ::RooPolyVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPolyVar

//______________________________________________________________________________
void RooProdGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProdGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProdGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProdGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooProdGenContext(void *p) {
      delete ((::RooProdGenContext*)p);
   }
   static void deleteArray_RooProdGenContext(void *p) {
      delete [] ((::RooProdGenContext*)p);
   }
   static void destruct_RooProdGenContext(void *p) {
      typedef ::RooProdGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProdGenContext

//______________________________________________________________________________
void RooProdPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProdPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProdPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProdPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProdPdf(void *p) {
      return  p ? new(p) ::RooProdPdf : new ::RooProdPdf;
   }
   static void *newArray_RooProdPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooProdPdf[nElements] : new ::RooProdPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProdPdf(void *p) {
      delete ((::RooProdPdf*)p);
   }
   static void deleteArray_RooProdPdf(void *p) {
      delete [] ((::RooProdPdf*)p);
   }
   static void destruct_RooProdPdf(void *p) {
      typedef ::RooProdPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProdPdf

//______________________________________________________________________________
void RooProduct::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProduct.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProduct::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProduct::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProduct(void *p) {
      return  p ? new(p) ::RooProduct : new ::RooProduct;
   }
   static void *newArray_RooProduct(Long_t nElements, void *p) {
      return p ? new(p) ::RooProduct[nElements] : new ::RooProduct[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProduct(void *p) {
      delete ((::RooProduct*)p);
   }
   static void deleteArray_RooProduct(void *p) {
      delete [] ((::RooProduct*)p);
   }
   static void destruct_RooProduct(void *p) {
      typedef ::RooProduct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProduct

//______________________________________________________________________________
void RooProfileLL::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProfileLL.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProfileLL::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProfileLL::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProfileLL(void *p) {
      return  p ? new(p) ::RooProfileLL : new ::RooProfileLL;
   }
   static void *newArray_RooProfileLL(Long_t nElements, void *p) {
      return p ? new(p) ::RooProfileLL[nElements] : new ::RooProfileLL[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProfileLL(void *p) {
      delete ((::RooProfileLL*)p);
   }
   static void deleteArray_RooProfileLL(void *p) {
      delete [] ((::RooProfileLL*)p);
   }
   static void destruct_RooProfileLL(void *p) {
      typedef ::RooProfileLL current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProfileLL

//______________________________________________________________________________
void RooProjectedPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProjectedPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProjectedPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProjectedPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProjectedPdf(void *p) {
      return  p ? new(p) ::RooProjectedPdf : new ::RooProjectedPdf;
   }
   static void *newArray_RooProjectedPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooProjectedPdf[nElements] : new ::RooProjectedPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProjectedPdf(void *p) {
      delete ((::RooProjectedPdf*)p);
   }
   static void deleteArray_RooProjectedPdf(void *p) {
      delete [] ((::RooProjectedPdf*)p);
   }
   static void destruct_RooProjectedPdf(void *p) {
      typedef ::RooProjectedPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProjectedPdf

//______________________________________________________________________________
void RooProofDriverSelector::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooProofDriverSelector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooProofDriverSelector::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooProofDriverSelector::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooProofDriverSelector(void *p) {
      return  p ? new(p) ::RooProofDriverSelector : new ::RooProofDriverSelector;
   }
   static void *newArray_RooProofDriverSelector(Long_t nElements, void *p) {
      return p ? new(p) ::RooProofDriverSelector[nElements] : new ::RooProofDriverSelector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooProofDriverSelector(void *p) {
      delete ((::RooProofDriverSelector*)p);
   }
   static void deleteArray_RooProofDriverSelector(void *p) {
      delete [] ((::RooProofDriverSelector*)p);
   }
   static void destruct_RooProofDriverSelector(void *p) {
      typedef ::RooProofDriverSelector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooProofDriverSelector

//______________________________________________________________________________
void RooPullVar::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooPullVar.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooPullVar::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooPullVar::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooPullVar(void *p) {
      return  p ? new(p) ::RooPullVar : new ::RooPullVar;
   }
   static void *newArray_RooPullVar(Long_t nElements, void *p) {
      return p ? new(p) ::RooPullVar[nElements] : new ::RooPullVar[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooPullVar(void *p) {
      delete ((::RooPullVar*)p);
   }
   static void deleteArray_RooPullVar(void *p) {
      delete [] ((::RooPullVar*)p);
   }
   static void destruct_RooPullVar(void *p) {
      typedef ::RooPullVar current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooPullVar

//______________________________________________________________________________
void RooQuasiRandomGenerator::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooQuasiRandomGenerator.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooQuasiRandomGenerator::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooQuasiRandomGenerator::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooQuasiRandomGenerator(void *p) {
      return  p ? new(p) ::RooQuasiRandomGenerator : new ::RooQuasiRandomGenerator;
   }
   static void *newArray_RooQuasiRandomGenerator(Long_t nElements, void *p) {
      return p ? new(p) ::RooQuasiRandomGenerator[nElements] : new ::RooQuasiRandomGenerator[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooQuasiRandomGenerator(void *p) {
      delete ((::RooQuasiRandomGenerator*)p);
   }
   static void deleteArray_RooQuasiRandomGenerator(void *p) {
      delete [] ((::RooQuasiRandomGenerator*)p);
   }
   static void destruct_RooQuasiRandomGenerator(void *p) {
      typedef ::RooQuasiRandomGenerator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooQuasiRandomGenerator

//______________________________________________________________________________
void RooRatio::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRatio.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRatio::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRatio::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRatio(void *p) {
      return  p ? new(p) ::RooRatio : new ::RooRatio;
   }
   static void *newArray_RooRatio(Long_t nElements, void *p) {
      return p ? new(p) ::RooRatio[nElements] : new ::RooRatio[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRatio(void *p) {
      delete ((::RooRatio*)p);
   }
   static void deleteArray_RooRatio(void *p) {
      delete [] ((::RooRatio*)p);
   }
   static void destruct_RooRatio(void *p) {
      typedef ::RooRatio current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRatio

//______________________________________________________________________________
void RooRandom::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRandom.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRandom::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRandom::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRandom(void *p) {
      delete ((::RooRandom*)p);
   }
   static void deleteArray_RooRandom(void *p) {
      delete [] ((::RooRandom*)p);
   }
   static void destruct_RooRandom(void *p) {
      typedef ::RooRandom current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRandom

//______________________________________________________________________________
void RooRandomizeParamMCSModule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRandomizeParamMCSModule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRandomizeParamMCSModule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRandomizeParamMCSModule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRandomizeParamMCSModule(void *p) {
      return  p ? new(p) ::RooRandomizeParamMCSModule : new ::RooRandomizeParamMCSModule;
   }
   static void *newArray_RooRandomizeParamMCSModule(Long_t nElements, void *p) {
      return p ? new(p) ::RooRandomizeParamMCSModule[nElements] : new ::RooRandomizeParamMCSModule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRandomizeParamMCSModule(void *p) {
      delete ((::RooRandomizeParamMCSModule*)p);
   }
   static void deleteArray_RooRandomizeParamMCSModule(void *p) {
      delete [] ((::RooRandomizeParamMCSModule*)p);
   }
   static void destruct_RooRandomizeParamMCSModule(void *p) {
      typedef ::RooRandomizeParamMCSModule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRandomizeParamMCSModule

//______________________________________________________________________________
void RooRangeBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRangeBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRangeBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRangeBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRangeBinning(void *p) {
      return  p ? new(p) ::RooRangeBinning : new ::RooRangeBinning;
   }
   static void *newArray_RooRangeBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooRangeBinning[nElements] : new ::RooRangeBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRangeBinning(void *p) {
      delete ((::RooRangeBinning*)p);
   }
   static void deleteArray_RooRangeBinning(void *p) {
      delete [] ((::RooRangeBinning*)p);
   }
   static void destruct_RooRangeBinning(void *p) {
      typedef ::RooRangeBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRangeBinning

//______________________________________________________________________________
void RooRangeBoolean::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRangeBoolean.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRangeBoolean::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRangeBoolean::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRangeBoolean(void *p) {
      return  p ? new(p) ::RooRangeBoolean : new ::RooRangeBoolean;
   }
   static void *newArray_RooRangeBoolean(Long_t nElements, void *p) {
      return p ? new(p) ::RooRangeBoolean[nElements] : new ::RooRangeBoolean[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRangeBoolean(void *p) {
      delete ((::RooRangeBoolean*)p);
   }
   static void deleteArray_RooRangeBoolean(void *p) {
      delete [] ((::RooRangeBoolean*)p);
   }
   static void destruct_RooRangeBoolean(void *p) {
      typedef ::RooRangeBoolean current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRangeBoolean

//______________________________________________________________________________
void RooRealAnalytic::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealAnalytic.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealAnalytic::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealAnalytic::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealAnalytic(void *p) {
      delete ((::RooRealAnalytic*)p);
   }
   static void deleteArray_RooRealAnalytic(void *p) {
      delete [] ((::RooRealAnalytic*)p);
   }
   static void destruct_RooRealAnalytic(void *p) {
      typedef ::RooRealAnalytic current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealAnalytic

//______________________________________________________________________________
void RooRealConstant::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealConstant.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealConstant::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealConstant::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealConstant(void *p) {
      return  p ? new(p) ::RooRealConstant : new ::RooRealConstant;
   }
   static void *newArray_RooRealConstant(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealConstant[nElements] : new ::RooRealConstant[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealConstant(void *p) {
      delete ((::RooRealConstant*)p);
   }
   static void deleteArray_RooRealConstant(void *p) {
      delete [] ((::RooRealConstant*)p);
   }
   static void destruct_RooRealConstant(void *p) {
      typedef ::RooRealConstant current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealConstant

//______________________________________________________________________________
void RooRealIntegral::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealIntegral.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealIntegral::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealIntegral::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealIntegral(void *p) {
      return  p ? new(p) ::RooRealIntegral : new ::RooRealIntegral;
   }
   static void *newArray_RooRealIntegral(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealIntegral[nElements] : new ::RooRealIntegral[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealIntegral(void *p) {
      delete ((::RooRealIntegral*)p);
   }
   static void deleteArray_RooRealIntegral(void *p) {
      delete [] ((::RooRealIntegral*)p);
   }
   static void destruct_RooRealIntegral(void *p) {
      typedef ::RooRealIntegral current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealIntegral

//______________________________________________________________________________
void RooRealMPFE::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealMPFE.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealMPFE::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealMPFE::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooRealMPFE(void *p) {
      delete ((::RooRealMPFE*)p);
   }
   static void deleteArray_RooRealMPFE(void *p) {
      delete [] ((::RooRealMPFE*)p);
   }
   static void destruct_RooRealMPFE(void *p) {
      typedef ::RooRealMPFE current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealMPFE

//______________________________________________________________________________
void RooRealSumFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealSumFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealSumFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealSumFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealSumFunc(void *p) {
      return  p ? new(p) ::RooRealSumFunc : new ::RooRealSumFunc;
   }
   static void *newArray_RooRealSumFunc(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealSumFunc[nElements] : new ::RooRealSumFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealSumFunc(void *p) {
      delete ((::RooRealSumFunc*)p);
   }
   static void deleteArray_RooRealSumFunc(void *p) {
      delete [] ((::RooRealSumFunc*)p);
   }
   static void destruct_RooRealSumFunc(void *p) {
      typedef ::RooRealSumFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealSumFunc

//______________________________________________________________________________
void RooRealSumPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealSumPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealSumPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealSumPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealSumPdf(void *p) {
      return  p ? new(p) ::RooRealSumPdf : new ::RooRealSumPdf;
   }
   static void *newArray_RooRealSumPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealSumPdf[nElements] : new ::RooRealSumPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealSumPdf(void *p) {
      delete ((::RooRealSumPdf*)p);
   }
   static void deleteArray_RooRealSumPdf(void *p) {
      delete [] ((::RooRealSumPdf*)p);
   }
   static void destruct_RooRealSumPdf(void *p) {
      typedef ::RooRealSumPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealSumPdf

//______________________________________________________________________________
void RooSharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSharedProperties(void *p) {
      return  p ? new(p) ::RooSharedProperties : new ::RooSharedProperties;
   }
   static void *newArray_RooSharedProperties(Long_t nElements, void *p) {
      return p ? new(p) ::RooSharedProperties[nElements] : new ::RooSharedProperties[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSharedProperties(void *p) {
      delete ((::RooSharedProperties*)p);
   }
   static void deleteArray_RooSharedProperties(void *p) {
      delete [] ((::RooSharedProperties*)p);
   }
   static void destruct_RooSharedProperties(void *p) {
      typedef ::RooSharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSharedProperties

//______________________________________________________________________________
void RooRealVarSharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRealVarSharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRealVarSharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRealVarSharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRealVarSharedProperties(void *p) {
      return  p ? new(p) ::RooRealVarSharedProperties : new ::RooRealVarSharedProperties;
   }
   static void *newArray_RooRealVarSharedProperties(Long_t nElements, void *p) {
      return p ? new(p) ::RooRealVarSharedProperties[nElements] : new ::RooRealVarSharedProperties[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRealVarSharedProperties(void *p) {
      delete ((::RooRealVarSharedProperties*)p);
   }
   static void deleteArray_RooRealVarSharedProperties(void *p) {
      delete [] ((::RooRealVarSharedProperties*)p);
   }
   static void destruct_RooRealVarSharedProperties(void *p) {
      typedef ::RooRealVarSharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRealVarSharedProperties

//______________________________________________________________________________
void RooRecursiveFraction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRecursiveFraction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRecursiveFraction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRecursiveFraction::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRecursiveFraction(void *p) {
      return  p ? new(p) ::RooRecursiveFraction : new ::RooRecursiveFraction;
   }
   static void *newArray_RooRecursiveFraction(Long_t nElements, void *p) {
      return p ? new(p) ::RooRecursiveFraction[nElements] : new ::RooRecursiveFraction[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRecursiveFraction(void *p) {
      delete ((::RooRecursiveFraction*)p);
   }
   static void deleteArray_RooRecursiveFraction(void *p) {
      delete [] ((::RooRecursiveFraction*)p);
   }
   static void destruct_RooRecursiveFraction(void *p) {
      typedef ::RooRecursiveFraction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRecursiveFraction

//______________________________________________________________________________
void RooRefCountList::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooRefCountList.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooRefCountList::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooRefCountList::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooRefCountList(void *p) {
      return  p ? new(p) ::RooRefCountList : new ::RooRefCountList;
   }
   static void *newArray_RooRefCountList(Long_t nElements, void *p) {
      return p ? new(p) ::RooRefCountList[nElements] : new ::RooRefCountList[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooRefCountList(void *p) {
      delete ((::RooRefCountList*)p);
   }
   static void deleteArray_RooRefCountList(void *p) {
      delete [] ((::RooRefCountList*)p);
   }
   static void destruct_RooRefCountList(void *p) {
      typedef ::RooRefCountList current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooRefCountList

//______________________________________________________________________________
void RooScaledFunc::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooScaledFunc.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooScaledFunc::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooScaledFunc::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooScaledFunc(void *p) {
      delete ((::RooScaledFunc*)p);
   }
   static void deleteArray_RooScaledFunc(void *p) {
      delete [] ((::RooScaledFunc*)p);
   }
   static void destruct_RooScaledFunc(void *p) {
      typedef ::RooScaledFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooScaledFunc

//______________________________________________________________________________
void RooSecondMoment::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSecondMoment.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSecondMoment::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSecondMoment::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSecondMoment(void *p) {
      return  p ? new(p) ::RooSecondMoment : new ::RooSecondMoment;
   }
   static void *newArray_RooSecondMoment(Long_t nElements, void *p) {
      return p ? new(p) ::RooSecondMoment[nElements] : new ::RooSecondMoment[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSecondMoment(void *p) {
      delete ((::RooSecondMoment*)p);
   }
   static void deleteArray_RooSecondMoment(void *p) {
      delete [] ((::RooSecondMoment*)p);
   }
   static void destruct_RooSecondMoment(void *p) {
      typedef ::RooSecondMoment current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSecondMoment

//______________________________________________________________________________
void RooSegmentedIntegrator1D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSegmentedIntegrator1D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSegmentedIntegrator1D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSegmentedIntegrator1D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSegmentedIntegrator1D(void *p) {
      return  p ? new(p) ::RooSegmentedIntegrator1D : new ::RooSegmentedIntegrator1D;
   }
   static void *newArray_RooSegmentedIntegrator1D(Long_t nElements, void *p) {
      return p ? new(p) ::RooSegmentedIntegrator1D[nElements] : new ::RooSegmentedIntegrator1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSegmentedIntegrator1D(void *p) {
      delete ((::RooSegmentedIntegrator1D*)p);
   }
   static void deleteArray_RooSegmentedIntegrator1D(void *p) {
      delete [] ((::RooSegmentedIntegrator1D*)p);
   }
   static void destruct_RooSegmentedIntegrator1D(void *p) {
      typedef ::RooSegmentedIntegrator1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSegmentedIntegrator1D

//______________________________________________________________________________
void RooSegmentedIntegrator2D::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSegmentedIntegrator2D.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSegmentedIntegrator2D::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSegmentedIntegrator2D::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSegmentedIntegrator2D(void *p) {
      return  p ? new(p) ::RooSegmentedIntegrator2D : new ::RooSegmentedIntegrator2D;
   }
   static void *newArray_RooSegmentedIntegrator2D(Long_t nElements, void *p) {
      return p ? new(p) ::RooSegmentedIntegrator2D[nElements] : new ::RooSegmentedIntegrator2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSegmentedIntegrator2D(void *p) {
      delete ((::RooSegmentedIntegrator2D*)p);
   }
   static void deleteArray_RooSegmentedIntegrator2D(void *p) {
      delete [] ((::RooSegmentedIntegrator2D*)p);
   }
   static void destruct_RooSegmentedIntegrator2D(void *p) {
      typedef ::RooSegmentedIntegrator2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSegmentedIntegrator2D

//______________________________________________________________________________
void RooSimGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimGenContext(void *p) {
      delete ((::RooSimGenContext*)p);
   }
   static void deleteArray_RooSimGenContext(void *p) {
      delete [] ((::RooSimGenContext*)p);
   }
   static void destruct_RooSimGenContext(void *p) {
      typedef ::RooSimGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimGenContext

//______________________________________________________________________________
void RooSimPdfBuilder::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimPdfBuilder.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimPdfBuilder::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimPdfBuilder::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimPdfBuilder(void *p) {
      delete ((::RooSimPdfBuilder*)p);
   }
   static void deleteArray_RooSimPdfBuilder(void *p) {
      delete [] ((::RooSimPdfBuilder*)p);
   }
   static void destruct_RooSimPdfBuilder(void *p) {
      typedef ::RooSimPdfBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimPdfBuilder

//______________________________________________________________________________
void RooSimSplitGenContext::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimSplitGenContext.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimSplitGenContext::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimSplitGenContext::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimSplitGenContext(void *p) {
      delete ((::RooSimSplitGenContext*)p);
   }
   static void deleteArray_RooSimSplitGenContext(void *p) {
      delete [] ((::RooSimSplitGenContext*)p);
   }
   static void destruct_RooSimSplitGenContext(void *p) {
      typedef ::RooSimSplitGenContext current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimSplitGenContext

//______________________________________________________________________________
void RooSimultaneous::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimultaneous.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimultaneous::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimultaneous::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimultaneous(void *p) {
      return  p ? new(p) ::RooSimultaneous : new ::RooSimultaneous;
   }
   static void *newArray_RooSimultaneous(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimultaneous[nElements] : new ::RooSimultaneous[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimultaneous(void *p) {
      delete ((::RooSimultaneous*)p);
   }
   static void deleteArray_RooSimultaneous(void *p) {
      delete [] ((::RooSimultaneous*)p);
   }
   static void destruct_RooSimultaneous(void *p) {
      typedef ::RooSimultaneous current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimultaneous

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooWorkspace(void *p) {
      return  p ? new(p) ::RooWorkspace : new ::RooWorkspace;
   }
   static void *newArray_RooWorkspace(Long_t nElements, void *p) {
      return p ? new(p) ::RooWorkspace[nElements] : new ::RooWorkspace[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooWorkspace(void *p) {
      delete ((::RooWorkspace*)p);
   }
   static void deleteArray_RooWorkspace(void *p) {
      delete [] ((::RooWorkspace*)p);
   }
   static void destruct_RooWorkspace(void *p) {
      typedef ::RooWorkspace current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooWorkspace(TBuffer &buf, void *obj) {
      ((::RooWorkspace*)obj)->::RooWorkspace::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooWorkspace

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooWorkspacecLcLCodeRepo(void *p) {
      return  p ? new(p) ::RooWorkspace::CodeRepo : new ::RooWorkspace::CodeRepo;
   }
   static void *newArray_RooWorkspacecLcLCodeRepo(Long_t nElements, void *p) {
      return p ? new(p) ::RooWorkspace::CodeRepo[nElements] : new ::RooWorkspace::CodeRepo[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooWorkspacecLcLCodeRepo(void *p) {
      delete ((::RooWorkspace::CodeRepo*)p);
   }
   static void deleteArray_RooWorkspacecLcLCodeRepo(void *p) {
      delete [] ((::RooWorkspace::CodeRepo*)p);
   }
   static void destruct_RooWorkspacecLcLCodeRepo(void *p) {
      typedef ::RooWorkspace::CodeRepo current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooWorkspacecLcLCodeRepo(TBuffer &buf, void *obj) {
      ((::RooWorkspace::CodeRepo*)obj)->::RooWorkspace::CodeRepo::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooWorkspace::CodeRepo

//______________________________________________________________________________
void RooWorkspace::WSDir::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooWorkspace::WSDir.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooWorkspace::WSDir::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooWorkspace::WSDir::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooWorkspacecLcLWSDir(void *p) {
      delete ((::RooWorkspace::WSDir*)p);
   }
   static void deleteArray_RooWorkspacecLcLWSDir(void *p) {
      delete [] ((::RooWorkspace::WSDir*)p);
   }
   static void destruct_RooWorkspacecLcLWSDir(void *p) {
      typedef ::RooWorkspace::WSDir current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around the Reset function.
   static void reset_RooWorkspacecLcLWSDir(void *obj,TFileMergeInfo *info) {
      ((::RooWorkspace::WSDir*)obj)->ResetAfterMerge(info);
   }
} // end of namespace ROOT for class ::RooWorkspace::WSDir

//______________________________________________________________________________
void RooSimWSTool::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSTool(void *p) {
      delete ((::RooSimWSTool*)p);
   }
   static void deleteArray_RooSimWSTool(void *p) {
      delete [] ((::RooSimWSTool*)p);
   }
   static void destruct_RooSimWSTool(void *p) {
      typedef ::RooSimWSTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool

//______________________________________________________________________________
void RooSimWSTool::SplitRule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::SplitRule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::SplitRule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::SplitRule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLSplitRule(void *p) {
      return  p ? new(p) ::RooSimWSTool::SplitRule : new ::RooSimWSTool::SplitRule;
   }
   static void *newArray_RooSimWSToolcLcLSplitRule(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::SplitRule[nElements] : new ::RooSimWSTool::SplitRule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLSplitRule(void *p) {
      delete ((::RooSimWSTool::SplitRule*)p);
   }
   static void deleteArray_RooSimWSToolcLcLSplitRule(void *p) {
      delete [] ((::RooSimWSTool::SplitRule*)p);
   }
   static void destruct_RooSimWSToolcLcLSplitRule(void *p) {
      typedef ::RooSimWSTool::SplitRule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::SplitRule

//______________________________________________________________________________
void RooSimWSTool::BuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::BuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::BuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::BuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLBuildConfig(void *p) {
      delete ((::RooSimWSTool::BuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::BuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLBuildConfig(void *p) {
      typedef ::RooSimWSTool::BuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::BuildConfig

//______________________________________________________________________________
void RooSimWSTool::MultiBuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::MultiBuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::MultiBuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::MultiBuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      delete ((::RooSimWSTool::MultiBuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::MultiBuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLMultiBuildConfig(void *p) {
      typedef ::RooSimWSTool::MultiBuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::MultiBuildConfig

//______________________________________________________________________________
void RooSimWSTool::ObjSplitRule::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::ObjSplitRule.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::ObjSplitRule::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::ObjSplitRule::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLObjSplitRule(void *p) {
      return  p ? new(p) ::RooSimWSTool::ObjSplitRule : new ::RooSimWSTool::ObjSplitRule;
   }
   static void *newArray_RooSimWSToolcLcLObjSplitRule(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::ObjSplitRule[nElements] : new ::RooSimWSTool::ObjSplitRule[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLObjSplitRule(void *p) {
      delete ((::RooSimWSTool::ObjSplitRule*)p);
   }
   static void deleteArray_RooSimWSToolcLcLObjSplitRule(void *p) {
      delete [] ((::RooSimWSTool::ObjSplitRule*)p);
   }
   static void destruct_RooSimWSToolcLcLObjSplitRule(void *p) {
      typedef ::RooSimWSTool::ObjSplitRule current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::ObjSplitRule

//______________________________________________________________________________
void RooSimWSTool::ObjBuildConfig::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSimWSTool::ObjBuildConfig.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSimWSTool::ObjBuildConfig::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSimWSTool::ObjBuildConfig::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSimWSToolcLcLObjBuildConfig(void *p) {
      return  p ? new(p) ::RooSimWSTool::ObjBuildConfig : new ::RooSimWSTool::ObjBuildConfig;
   }
   static void *newArray_RooSimWSToolcLcLObjBuildConfig(Long_t nElements, void *p) {
      return p ? new(p) ::RooSimWSTool::ObjBuildConfig[nElements] : new ::RooSimWSTool::ObjBuildConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSimWSToolcLcLObjBuildConfig(void *p) {
      delete ((::RooSimWSTool::ObjBuildConfig*)p);
   }
   static void deleteArray_RooSimWSToolcLcLObjBuildConfig(void *p) {
      delete [] ((::RooSimWSTool::ObjBuildConfig*)p);
   }
   static void destruct_RooSimWSToolcLcLObjBuildConfig(void *p) {
      typedef ::RooSimWSTool::ObjBuildConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSimWSTool::ObjBuildConfig

//______________________________________________________________________________
void RooStreamParser::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStreamParser.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStreamParser::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStreamParser::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooStreamParser(void *p) {
      delete ((::RooStreamParser*)p);
   }
   static void deleteArray_RooStreamParser(void *p) {
      delete [] ((::RooStreamParser*)p);
   }
   static void destruct_RooStreamParser(void *p) {
      typedef ::RooStreamParser current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStreamParser

//______________________________________________________________________________
void RooStudyPackage::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStudyPackage.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStudyPackage::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStudyPackage::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooStudyPackage(void *p) {
      return  p ? new(p) ::RooStudyPackage : new ::RooStudyPackage;
   }
   static void *newArray_RooStudyPackage(Long_t nElements, void *p) {
      return p ? new(p) ::RooStudyPackage[nElements] : new ::RooStudyPackage[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooStudyPackage(void *p) {
      delete ((::RooStudyPackage*)p);
   }
   static void deleteArray_RooStudyPackage(void *p) {
      delete [] ((::RooStudyPackage*)p);
   }
   static void destruct_RooStudyPackage(void *p) {
      typedef ::RooStudyPackage current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStudyPackage

//______________________________________________________________________________
void RooStudyManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooStudyManager.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooStudyManager::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooStudyManager::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooStudyManager(void *p) {
      delete ((::RooStudyManager*)p);
   }
   static void deleteArray_RooStudyManager(void *p) {
      delete [] ((::RooStudyManager*)p);
   }
   static void destruct_RooStudyManager(void *p) {
      typedef ::RooStudyManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooStudyManager

//______________________________________________________________________________
void RooSuperCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSuperCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSuperCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSuperCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSuperCategory(void *p) {
      return  p ? new(p) ::RooSuperCategory : new ::RooSuperCategory;
   }
   static void *newArray_RooSuperCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooSuperCategory[nElements] : new ::RooSuperCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSuperCategory(void *p) {
      delete ((::RooSuperCategory*)p);
   }
   static void deleteArray_RooSuperCategory(void *p) {
      delete [] ((::RooSuperCategory*)p);
   }
   static void destruct_RooSuperCategory(void *p) {
      typedef ::RooSuperCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSuperCategory

//______________________________________________________________________________
void RooTFoamBinding::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTFoamBinding.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTFoamBinding::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTFoamBinding::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTFoamBinding(void *p) {
      delete ((::RooTFoamBinding*)p);
   }
   static void deleteArray_RooTFoamBinding(void *p) {
      delete [] ((::RooTFoamBinding*)p);
   }
   static void destruct_RooTFoamBinding(void *p) {
      typedef ::RooTFoamBinding current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTFoamBinding

//______________________________________________________________________________
void RooThresholdCategory::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooThresholdCategory.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooThresholdCategory::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooThresholdCategory::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooThresholdCategory(void *p) {
      return  p ? new(p) ::RooThresholdCategory : new ::RooThresholdCategory;
   }
   static void *newArray_RooThresholdCategory(Long_t nElements, void *p) {
      return p ? new(p) ::RooThresholdCategory[nElements] : new ::RooThresholdCategory[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooThresholdCategory(void *p) {
      delete ((::RooThresholdCategory*)p);
   }
   static void deleteArray_RooThresholdCategory(void *p) {
      delete [] ((::RooThresholdCategory*)p);
   }
   static void destruct_RooThresholdCategory(void *p) {
      typedef ::RooThresholdCategory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooThresholdCategory

//______________________________________________________________________________
void RooTObjWrap::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTObjWrap.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTObjWrap::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTObjWrap::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTObjWrap(void *p) {
      return  p ? new(p) ::RooTObjWrap : new ::RooTObjWrap;
   }
   static void *newArray_RooTObjWrap(Long_t nElements, void *p) {
      return p ? new(p) ::RooTObjWrap[nElements] : new ::RooTObjWrap[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTObjWrap(void *p) {
      delete ((::RooTObjWrap*)p);
   }
   static void deleteArray_RooTObjWrap(void *p) {
      delete [] ((::RooTObjWrap*)p);
   }
   static void destruct_RooTObjWrap(void *p) {
      typedef ::RooTObjWrap current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTObjWrap

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTreeDataStore(void *p) {
      return  p ? new(p) ::RooTreeDataStore : new ::RooTreeDataStore;
   }
   static void *newArray_RooTreeDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooTreeDataStore[nElements] : new ::RooTreeDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTreeDataStore(void *p) {
      delete ((::RooTreeDataStore*)p);
   }
   static void deleteArray_RooTreeDataStore(void *p) {
      delete [] ((::RooTreeDataStore*)p);
   }
   static void destruct_RooTreeDataStore(void *p) {
      typedef ::RooTreeDataStore current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooTreeDataStore(TBuffer &buf, void *obj) {
      ((::RooTreeDataStore*)obj)->::RooTreeDataStore::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooTreeDataStore

//______________________________________________________________________________
void RooTruthModel::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTruthModel.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTruthModel::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTruthModel::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooTruthModel(void *p) {
      return  p ? new(p) ::RooTruthModel : new ::RooTruthModel;
   }
   static void *newArray_RooTruthModel(Long_t nElements, void *p) {
      return p ? new(p) ::RooTruthModel[nElements] : new ::RooTruthModel[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooTruthModel(void *p) {
      delete ((::RooTruthModel*)p);
   }
   static void deleteArray_RooTruthModel(void *p) {
      delete [] ((::RooTruthModel*)p);
   }
   static void destruct_RooTruthModel(void *p) {
      typedef ::RooTruthModel current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTruthModel

//______________________________________________________________________________
void RooUniformBinning::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooUniformBinning.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooUniformBinning::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooUniformBinning::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooUniformBinning(void *p) {
      return  p ? new(p) ::RooUniformBinning : new ::RooUniformBinning;
   }
   static void *newArray_RooUniformBinning(Long_t nElements, void *p) {
      return p ? new(p) ::RooUniformBinning[nElements] : new ::RooUniformBinning[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooUniformBinning(void *p) {
      delete ((::RooUniformBinning*)p);
   }
   static void deleteArray_RooUniformBinning(void *p) {
      delete [] ((::RooUniformBinning*)p);
   }
   static void destruct_RooUniformBinning(void *p) {
      typedef ::RooUniformBinning current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooUniformBinning

//______________________________________________________________________________
void RooUnitTest::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooUnitTest.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooUnitTest::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooUnitTest::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooUnitTest(void *p) {
      delete ((::RooUnitTest*)p);
   }
   static void deleteArray_RooUnitTest(void *p) {
      delete [] ((::RooUnitTest*)p);
   }
   static void destruct_RooUnitTest(void *p) {
      typedef ::RooUnitTest current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooUnitTest

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStore(void *p) {
      return  p ? new(p) ::RooVectorDataStore : new ::RooVectorDataStore;
   }
   static void *newArray_RooVectorDataStore(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore[nElements] : new ::RooVectorDataStore[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStore(void *p) {
      delete ((::RooVectorDataStore*)p);
   }
   static void deleteArray_RooVectorDataStore(void *p) {
      delete [] ((::RooVectorDataStore*)p);
   }
   static void destruct_RooVectorDataStore(void *p) {
      typedef ::RooVectorDataStore current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStore(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore*)obj)->::RooVectorDataStore::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore

//______________________________________________________________________________
void RooVectorDataStore::RealVector::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooVectorDataStore::RealVector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooVectorDataStore::RealVector::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooVectorDataStore::RealVector::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLRealVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::RealVector : new ::RooVectorDataStore::RealVector;
   }
   static void *newArray_RooVectorDataStorecLcLRealVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::RealVector[nElements] : new ::RooVectorDataStore::RealVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLRealVector(void *p) {
      delete ((::RooVectorDataStore::RealVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLRealVector(void *p) {
      delete [] ((::RooVectorDataStore::RealVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLRealVector(void *p) {
      typedef ::RooVectorDataStore::RealVector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooVectorDataStore::RealVector

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLRealFullVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::RealFullVector : new ::RooVectorDataStore::RealFullVector;
   }
   static void *newArray_RooVectorDataStorecLcLRealFullVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::RealFullVector[nElements] : new ::RooVectorDataStore::RealFullVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLRealFullVector(void *p) {
      delete ((::RooVectorDataStore::RealFullVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLRealFullVector(void *p) {
      delete [] ((::RooVectorDataStore::RealFullVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLRealFullVector(void *p) {
      typedef ::RooVectorDataStore::RealFullVector current_t;
      ((current_t*)p)->~current_t();
   }
   // Wrapper around a custom streamer member function.
   static void streamer_RooVectorDataStorecLcLRealFullVector(TBuffer &buf, void *obj) {
      ((::RooVectorDataStore::RealFullVector*)obj)->::RooVectorDataStore::RealFullVector::Streamer(buf);
   }
} // end of namespace ROOT for class ::RooVectorDataStore::RealFullVector

//______________________________________________________________________________
void RooVectorDataStore::CatVector::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooVectorDataStore::CatVector.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooVectorDataStore::CatVector::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooVectorDataStore::CatVector::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooVectorDataStorecLcLCatVector(void *p) {
      return  p ? new(p) ::RooVectorDataStore::CatVector : new ::RooVectorDataStore::CatVector;
   }
   static void *newArray_RooVectorDataStorecLcLCatVector(Long_t nElements, void *p) {
      return p ? new(p) ::RooVectorDataStore::CatVector[nElements] : new ::RooVectorDataStore::CatVector[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooVectorDataStorecLcLCatVector(void *p) {
      delete ((::RooVectorDataStore::CatVector*)p);
   }
   static void deleteArray_RooVectorDataStorecLcLCatVector(void *p) {
      delete [] ((::RooVectorDataStore::CatVector*)p);
   }
   static void destruct_RooVectorDataStorecLcLCatVector(void *p) {
      typedef ::RooVectorDataStore::CatVector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooVectorDataStore::CatVector

//______________________________________________________________________________
void RooWorkspaceHandle::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooWorkspaceHandle.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooWorkspaceHandle::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooWorkspaceHandle::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooWorkspaceHandle(void *p) {
      delete ((::RooWorkspaceHandle*)p);
   }
   static void deleteArray_RooWorkspaceHandle(void *p) {
      delete [] ((::RooWorkspaceHandle*)p);
   }
   static void destruct_RooWorkspaceHandle(void *p) {
      typedef ::RooWorkspaceHandle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooWorkspaceHandle

//______________________________________________________________________________
void RooXYChi2Var::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooXYChi2Var.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooXYChi2Var::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooXYChi2Var::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooXYChi2Var(void *p) {
      return  p ? new(p) ::RooXYChi2Var : new ::RooXYChi2Var;
   }
   static void *newArray_RooXYChi2Var(Long_t nElements, void *p) {
      return p ? new(p) ::RooXYChi2Var[nElements] : new ::RooXYChi2Var[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooXYChi2Var(void *p) {
      delete ((::RooXYChi2Var*)p);
   }
   static void deleteArray_RooXYChi2Var(void *p) {
      delete [] ((::RooXYChi2Var*)p);
   }
   static void destruct_RooXYChi2Var(void *p) {
      typedef ::RooXYChi2Var current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooXYChi2Var

//______________________________________________________________________________
void RooWrapperPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooWrapperPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooWrapperPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooWrapperPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooWrapperPdf(void *p) {
      return  p ? new(p) ::RooWrapperPdf : new ::RooWrapperPdf;
   }
   static void *newArray_RooWrapperPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooWrapperPdf[nElements] : new ::RooWrapperPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooWrapperPdf(void *p) {
      delete ((::RooWrapperPdf*)p);
   }
   static void deleteArray_RooWrapperPdf(void *p) {
      delete [] ((::RooWrapperPdf*)p);
   }
   static void destruct_RooWrapperPdf(void *p) {
      typedef ::RooWrapperPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooWrapperPdf

//______________________________________________________________________________
void RooBinSamplingPdf::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinSamplingPdf.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinSamplingPdf::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinSamplingPdf::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinSamplingPdf(void *p) {
      return  p ? new(p) ::RooBinSamplingPdf : new ::RooBinSamplingPdf;
   }
   static void *newArray_RooBinSamplingPdf(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinSamplingPdf[nElements] : new ::RooBinSamplingPdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinSamplingPdf(void *p) {
      delete ((::RooBinSamplingPdf*)p);
   }
   static void deleteArray_RooBinSamplingPdf(void *p) {
      delete [] ((::RooBinSamplingPdf*)p);
   }
   static void destruct_RooBinSamplingPdf(void *p) {
      typedef ::RooBinSamplingPdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinSamplingPdf

//______________________________________________________________________________
void RooBinWidthFunction::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooBinWidthFunction.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooBinWidthFunction::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooBinWidthFunction::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooBinWidthFunction(void *p) {
      return  p ? new(p) ::RooBinWidthFunction : new ::RooBinWidthFunction;
   }
   static void *newArray_RooBinWidthFunction(Long_t nElements, void *p) {
      return p ? new(p) ::RooBinWidthFunction[nElements] : new ::RooBinWidthFunction[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooBinWidthFunction(void *p) {
      delete ((::RooBinWidthFunction*)p);
   }
   static void deleteArray_RooBinWidthFunction(void *p) {
      delete [] ((::RooBinWidthFunction*)p);
   }
   static void destruct_RooBinWidthFunction(void *p) {
      typedef ::RooBinWidthFunction current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooBinWidthFunction

//______________________________________________________________________________
void RooCategorySharedProperties::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooCategorySharedProperties.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooCategorySharedProperties::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooCategorySharedProperties::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooCategorySharedProperties(void *p) {
      return  p ? new(p) ::RooCategorySharedProperties : new ::RooCategorySharedProperties;
   }
   static void *newArray_RooCategorySharedProperties(Long_t nElements, void *p) {
      return p ? new(p) ::RooCategorySharedProperties[nElements] : new ::RooCategorySharedProperties[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooCategorySharedProperties(void *p) {
      delete ((::RooCategorySharedProperties*)p);
   }
   static void deleteArray_RooCategorySharedProperties(void *p) {
      delete [] ((::RooCategorySharedProperties*)p);
   }
   static void destruct_RooCategorySharedProperties(void *p) {
      typedef ::RooCategorySharedProperties current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooCategorySharedProperties

//______________________________________________________________________________
void RooHashTable::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooHashTable.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooHashTable::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooHashTable::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooHashTable(void *p) {
      return  p ? new(p) ::RooHashTable : new ::RooHashTable;
   }
   static void *newArray_RooHashTable(Long_t nElements, void *p) {
      return p ? new(p) ::RooHashTable[nElements] : new ::RooHashTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooHashTable(void *p) {
      delete ((::RooHashTable*)p);
   }
   static void deleteArray_RooHashTable(void *p) {
      delete [] ((::RooHashTable*)p);
   }
   static void destruct_RooHashTable(void *p) {
      typedef ::RooHashTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooHashTable

//______________________________________________________________________________
void RooMinuit::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooMinuit.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooMinuit::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooMinuit::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooMinuit(void *p) {
      delete ((::RooMinuit*)p);
   }
   static void deleteArray_RooMinuit(void *p) {
      delete [] ((::RooMinuit*)p);
   }
   static void destruct_RooMinuit(void *p) {
      typedef ::RooMinuit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooMinuit

//______________________________________________________________________________
void RooNameSet::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooNameSet.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooNameSet::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooNameSet::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooNameSet(void *p) {
      return  p ? new(p) ::RooNameSet : new ::RooNameSet;
   }
   static void *newArray_RooNameSet(Long_t nElements, void *p) {
      return p ? new(p) ::RooNameSet[nElements] : new ::RooNameSet[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooNameSet(void *p) {
      delete ((::RooNameSet*)p);
   }
   static void deleteArray_RooNameSet(void *p) {
      delete [] ((::RooNameSet*)p);
   }
   static void destruct_RooNameSet(void *p) {
      typedef ::RooNameSet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooNameSet

//______________________________________________________________________________
void RooSetPair::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooSetPair.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooSetPair::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooSetPair::Class(),this);
   }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_RooSetPair(void *p) {
      return  p ? new(p) ::RooSetPair : new ::RooSetPair;
   }
   static void *newArray_RooSetPair(Long_t nElements, void *p) {
      return p ? new(p) ::RooSetPair[nElements] : new ::RooSetPair[nElements];
   }
   // Wrapper around operator delete
   static void delete_RooSetPair(void *p) {
      delete ((::RooSetPair*)p);
   }
   static void deleteArray_RooSetPair(void *p) {
      delete [] ((::RooSetPair*)p);
   }
   static void destruct_RooSetPair(void *p) {
      typedef ::RooSetPair current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooSetPair

//______________________________________________________________________________
void RooTreeData::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooTreeData.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooTreeData::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooTreeData::Class(),this);
   }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooTreeData(void *p) {
      delete ((::RooTreeData*)p);
   }
   static void deleteArray_RooTreeData(void *p) {
      delete [] ((::RooTreeData*)p);
   }
   static void destruct_RooTreeData(void *p) {
      typedef ::RooTreeData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooTreeData

namespace RooFit {
   namespace TestStatistics {
//______________________________________________________________________________
void RooRealL::Streamer(TBuffer &R__b)
{
   // Stream an object of class RooFit::TestStatistics::RooRealL.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(RooFit::TestStatistics::RooRealL::Class(),this);
   } else {
      R__b.WriteClassBuffer(RooFit::TestStatistics::RooRealL::Class(),this);
   }
}

} // namespace RooFit::TestStatistics
} // namespace RooFit::TestStatistics
namespace ROOT {
   // Wrapper around operator delete
   static void delete_RooFitcLcLTestStatisticscLcLRooRealL(void *p) {
      delete ((::RooFit::TestStatistics::RooRealL*)p);
   }
   static void deleteArray_RooFitcLcLTestStatisticscLcLRooRealL(void *p) {
      delete [] ((::RooFit::TestStatistics::RooRealL*)p);
   }
   static void destruct_RooFitcLcLTestStatisticscLcLRooRealL(void *p) {
      typedef ::RooFit::TestStatistics::RooRealL current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::RooFit::TestStatistics::RooRealL

namespace ROOT {
   static TClass *vectorlEunsignedsPintgR_Dictionary();
   static void vectorlEunsignedsPintgR_TClassManip(TClass*);
   static void *new_vectorlEunsignedsPintgR(void *p = nullptr);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "vector", 386,
                  typeid(vector<unsigned int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));

      ::ROOT::AddClassAlternate("vector<unsigned int>","std::vector<unsigned int, std::allocator<unsigned int> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEunsignedsPintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)nullptr)->GetClass();
      vectorlEunsignedsPintgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEunsignedsPintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

namespace ROOT {
   static TClass *vectorlEstringgR_Dictionary();
   static void vectorlEstringgR_TClassManip(TClass*);
   static void *new_vectorlEstringgR(void *p = nullptr);
   static void *newArray_vectorlEstringgR(Long_t size, void *p);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<string>*)
   {
      vector<string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<string>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<string>", -2, "vector", 386,
                  typeid(vector<string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<string> >()));

      ::ROOT::AddClassAlternate("vector<string>","std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<string>*)nullptr)->GetClass();
      vectorlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<string>[nElements] : new vector<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<string>

namespace ROOT {
   static TClass *vectorlEpairlEstringcOintgRsPgR_Dictionary();
   static void vectorlEpairlEstringcOintgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p = nullptr);
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p);
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<string,int> >*)
   {
      vector<pair<string,int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<string,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<string,int> >", -2, "vector", 386,
                  typeid(vector<pair<string,int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<string,int> >) );
      instance.SetNew(&new_vectorlEpairlEstringcOintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEstringcOintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEstringcOintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<string,int> > >()));

      ::ROOT::AddClassAlternate("vector<pair<string,int> >","std::vector<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<pair<string,int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEstringcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<string,int> >*)nullptr)->GetClass();
      vectorlEpairlEstringcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEstringcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEstringcOintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<string,int> > : new vector<pair<string,int> >;
   }
   static void *newArray_vectorlEpairlEstringcOintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<string,int> >[nElements] : new vector<pair<string,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete ((vector<pair<string,int> >*)p);
   }
   static void deleteArray_vectorlEpairlEstringcOintgRsPgR(void *p) {
      delete [] ((vector<pair<string,int> >*)p);
   }
   static void destruct_vectorlEpairlEstringcOintgRsPgR(void *p) {
      typedef vector<pair<string,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<string,int> >

namespace ROOT {
   static TClass *vectorlEpairlEdoublecOintgRsPgR_Dictionary();
   static void vectorlEpairlEdoublecOintgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEdoublecOintgRsPgR(void *p = nullptr);
   static void *newArray_vectorlEpairlEdoublecOintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEdoublecOintgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEdoublecOintgRsPgR(void *p);
   static void destruct_vectorlEpairlEdoublecOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<double,int> >*)
   {
      vector<pair<double,int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<double,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<double,int> >", -2, "vector", 386,
                  typeid(vector<pair<double,int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEdoublecOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<pair<double,int> >) );
      instance.SetNew(&new_vectorlEpairlEdoublecOintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEdoublecOintgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEdoublecOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEdoublecOintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEdoublecOintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<double,int> > >()));

      ::ROOT::AddClassAlternate("vector<pair<double,int> >","std::vector<std::pair<double, int>, std::allocator<std::pair<double, int> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<pair<double,int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEdoublecOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<double,int> >*)nullptr)->GetClass();
      vectorlEpairlEdoublecOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEdoublecOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEdoublecOintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<double,int> > : new vector<pair<double,int> >;
   }
   static void *newArray_vectorlEpairlEdoublecOintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<double,int> >[nElements] : new vector<pair<double,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEdoublecOintgRsPgR(void *p) {
      delete ((vector<pair<double,int> >*)p);
   }
   static void deleteArray_vectorlEpairlEdoublecOintgRsPgR(void *p) {
      delete [] ((vector<pair<double,int> >*)p);
   }
   static void destruct_vectorlEpairlEdoublecOintgRsPgR(void *p) {
      typedef vector<pair<double,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<double,int> >

namespace ROOT {
   static TClass *vectorlEintgR_Dictionary();
   static void vectorlEintgR_TClassManip(TClass*);
   static void *new_vectorlEintgR(void *p = nullptr);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "vector", 386,
                  typeid(vector<int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));

      ::ROOT::AddClassAlternate("vector<int>","std::vector<int, std::allocator<int> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<int>*)nullptr)->GetClass();
      vectorlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   static TClass *vectorlEdoublegR_Dictionary();
   static void vectorlEdoublegR_TClassManip(TClass*);
   static void *new_vectorlEdoublegR(void *p = nullptr);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector", 386,
                  typeid(vector<double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));

      ::ROOT::AddClassAlternate("vector<double>","std::vector<double, std::allocator<double> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<double>*)nullptr)->GetClass();
      vectorlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p = nullptr);
   static void *newArray_vectorlERooVectorDataStorecLcLRealVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::RealVector*>*)
   {
      vector<RooVectorDataStore::RealVector*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::RealVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::RealVector*>", -2, "vector", 386,
                  typeid(vector<RooVectorDataStore::RealVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::RealVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLRealVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::RealVector*> >()));

      ::ROOT::AddClassAlternate("vector<RooVectorDataStore::RealVector*>","std::vector<RooVectorDataStore::RealVector*, std::allocator<RooVectorDataStore::RealVector*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealVector*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLRealVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealVector*>*)nullptr)->GetClass();
      vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLRealVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealVector*> : new vector<RooVectorDataStore::RealVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLRealVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealVector*>[nElements] : new vector<RooVectorDataStore::RealVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::RealVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::RealVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLRealVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::RealVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::RealVector*>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p = nullptr);
   static void *newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::RealFullVector*>*)
   {
      vector<RooVectorDataStore::RealFullVector*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::RealFullVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::RealFullVector*>", -2, "vector", 386,
                  typeid(vector<RooVectorDataStore::RealFullVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::RealFullVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::RealFullVector*> >()));

      ::ROOT::AddClassAlternate("vector<RooVectorDataStore::RealFullVector*>","std::vector<RooVectorDataStore::RealFullVector*, std::allocator<RooVectorDataStore::RealFullVector*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealFullVector*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLRealFullVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::RealFullVector*>*)nullptr)->GetClass();
      vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLRealFullVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealFullVector*> : new vector<RooVectorDataStore::RealFullVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::RealFullVector*>[nElements] : new vector<RooVectorDataStore::RealFullVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::RealFullVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::RealFullVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLRealFullVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::RealFullVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::RealFullVector*>

namespace ROOT {
   static TClass *vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary();
   static void vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(TClass*);
   static void *new_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p = nullptr);
   static void *newArray_vectorlERooVectorDataStorecLcLCatVectormUgR(Long_t size, void *p);
   static void delete_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);
   static void deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);
   static void destruct_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooVectorDataStore::CatVector*>*)
   {
      vector<RooVectorDataStore::CatVector*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooVectorDataStore::CatVector*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooVectorDataStore::CatVector*>", -2, "vector", 386,
                  typeid(vector<RooVectorDataStore::CatVector*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooVectorDataStore::CatVector*>) );
      instance.SetNew(&new_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetNewArray(&newArray_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDelete(&delete_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.SetDestructor(&destruct_vectorlERooVectorDataStorecLcLCatVectormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooVectorDataStore::CatVector*> >()));

      ::ROOT::AddClassAlternate("vector<RooVectorDataStore::CatVector*>","std::vector<RooVectorDataStore::CatVector*, std::allocator<RooVectorDataStore::CatVector*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooVectorDataStore::CatVector*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooVectorDataStorecLcLCatVectormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooVectorDataStore::CatVector*>*)nullptr)->GetClass();
      vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooVectorDataStorecLcLCatVectormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::CatVector*> : new vector<RooVectorDataStore::CatVector*>;
   }
   static void *newArray_vectorlERooVectorDataStorecLcLCatVectormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooVectorDataStore::CatVector*>[nElements] : new vector<RooVectorDataStore::CatVector*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      delete ((vector<RooVectorDataStore::CatVector*>*)p);
   }
   static void deleteArray_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      delete [] ((vector<RooVectorDataStore::CatVector*>*)p);
   }
   static void destruct_vectorlERooVectorDataStorecLcLCatVectormUgR(void *p) {
      typedef vector<RooVectorDataStore::CatVector*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooVectorDataStore::CatVector*>

namespace ROOT {
   static TClass *vectorlERooListProxymUgR_Dictionary();
   static void vectorlERooListProxymUgR_TClassManip(TClass*);
   static void *new_vectorlERooListProxymUgR(void *p = nullptr);
   static void *newArray_vectorlERooListProxymUgR(Long_t size, void *p);
   static void delete_vectorlERooListProxymUgR(void *p);
   static void deleteArray_vectorlERooListProxymUgR(void *p);
   static void destruct_vectorlERooListProxymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooListProxy*>*)
   {
      vector<RooListProxy*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooListProxy*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooListProxy*>", -2, "vector", 386,
                  typeid(vector<RooListProxy*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooListProxymUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooListProxy*>) );
      instance.SetNew(&new_vectorlERooListProxymUgR);
      instance.SetNewArray(&newArray_vectorlERooListProxymUgR);
      instance.SetDelete(&delete_vectorlERooListProxymUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooListProxymUgR);
      instance.SetDestructor(&destruct_vectorlERooListProxymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooListProxy*> >()));

      ::ROOT::AddClassAlternate("vector<RooListProxy*>","std::vector<RooListProxy*, std::allocator<RooListProxy*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooListProxy*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooListProxymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooListProxy*>*)nullptr)->GetClass();
      vectorlERooListProxymUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooListProxymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooListProxymUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooListProxy*> : new vector<RooListProxy*>;
   }
   static void *newArray_vectorlERooListProxymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooListProxy*>[nElements] : new vector<RooListProxy*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooListProxymUgR(void *p) {
      delete ((vector<RooListProxy*>*)p);
   }
   static void deleteArray_vectorlERooListProxymUgR(void *p) {
      delete [] ((vector<RooListProxy*>*)p);
   }
   static void destruct_vectorlERooListProxymUgR(void *p) {
      typedef vector<RooListProxy*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooListProxy*>

namespace ROOT {
   static TClass *vectorlERooArgSetmUgR_Dictionary();
   static void vectorlERooArgSetmUgR_TClassManip(TClass*);
   static void *new_vectorlERooArgSetmUgR(void *p = nullptr);
   static void *newArray_vectorlERooArgSetmUgR(Long_t size, void *p);
   static void delete_vectorlERooArgSetmUgR(void *p);
   static void deleteArray_vectorlERooArgSetmUgR(void *p);
   static void destruct_vectorlERooArgSetmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooArgSet*>*)
   {
      vector<RooArgSet*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooArgSet*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooArgSet*>", -2, "vector", 386,
                  typeid(vector<RooArgSet*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooArgSetmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooArgSet*>) );
      instance.SetNew(&new_vectorlERooArgSetmUgR);
      instance.SetNewArray(&newArray_vectorlERooArgSetmUgR);
      instance.SetDelete(&delete_vectorlERooArgSetmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooArgSetmUgR);
      instance.SetDestructor(&destruct_vectorlERooArgSetmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooArgSet*> >()));

      ::ROOT::AddClassAlternate("vector<RooArgSet*>","std::vector<RooArgSet*, std::allocator<RooArgSet*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooArgSet*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooArgSetmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooArgSet*>*)nullptr)->GetClass();
      vectorlERooArgSetmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooArgSetmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooArgSetmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooArgSet*> : new vector<RooArgSet*>;
   }
   static void *newArray_vectorlERooArgSetmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooArgSet*>[nElements] : new vector<RooArgSet*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooArgSetmUgR(void *p) {
      delete ((vector<RooArgSet*>*)p);
   }
   static void deleteArray_vectorlERooArgSetmUgR(void *p) {
      delete [] ((vector<RooArgSet*>*)p);
   }
   static void destruct_vectorlERooArgSetmUgR(void *p) {
      typedef vector<RooArgSet*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooArgSet*>

namespace ROOT {
   static TClass *vectorlERooAbsArgmUgR_Dictionary();
   static void vectorlERooAbsArgmUgR_TClassManip(TClass*);
   static void *new_vectorlERooAbsArgmUgR(void *p = nullptr);
   static void *newArray_vectorlERooAbsArgmUgR(Long_t size, void *p);
   static void delete_vectorlERooAbsArgmUgR(void *p);
   static void deleteArray_vectorlERooAbsArgmUgR(void *p);
   static void destruct_vectorlERooAbsArgmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<RooAbsArg*>*)
   {
      vector<RooAbsArg*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<RooAbsArg*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<RooAbsArg*>", -2, "vector", 386,
                  typeid(vector<RooAbsArg*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlERooAbsArgmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<RooAbsArg*>) );
      instance.SetNew(&new_vectorlERooAbsArgmUgR);
      instance.SetNewArray(&newArray_vectorlERooAbsArgmUgR);
      instance.SetDelete(&delete_vectorlERooAbsArgmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlERooAbsArgmUgR);
      instance.SetDestructor(&destruct_vectorlERooAbsArgmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<RooAbsArg*> >()));

      ::ROOT::AddClassAlternate("vector<RooAbsArg*>","std::vector<RooAbsArg*, std::allocator<RooAbsArg*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const vector<RooAbsArg*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlERooAbsArgmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<RooAbsArg*>*)nullptr)->GetClass();
      vectorlERooAbsArgmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlERooAbsArgmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlERooAbsArgmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooAbsArg*> : new vector<RooAbsArg*>;
   }
   static void *newArray_vectorlERooAbsArgmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<RooAbsArg*>[nElements] : new vector<RooAbsArg*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlERooAbsArgmUgR(void *p) {
      delete ((vector<RooAbsArg*>*)p);
   }
   static void deleteArray_vectorlERooAbsArgmUgR(void *p) {
      delete [] ((vector<RooAbsArg*>*)p);
   }
   static void destruct_vectorlERooAbsArgmUgR(void *p) {
      typedef vector<RooAbsArg*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<RooAbsArg*>

namespace ROOT {
   static TClass *unordered_maplEstringcORooAbsBinningmUgR_Dictionary();
   static void unordered_maplEstringcORooAbsBinningmUgR_TClassManip(TClass*);
   static void *new_unordered_maplEstringcORooAbsBinningmUgR(void *p = nullptr);
   static void *newArray_unordered_maplEstringcORooAbsBinningmUgR(Long_t size, void *p);
   static void delete_unordered_maplEstringcORooAbsBinningmUgR(void *p);
   static void deleteArray_unordered_maplEstringcORooAbsBinningmUgR(void *p);
   static void destruct_unordered_maplEstringcORooAbsBinningmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const unordered_map<string,RooAbsBinning*>*)
   {
      unordered_map<string,RooAbsBinning*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(unordered_map<string,RooAbsBinning*>));
      static ::ROOT::TGenericClassInfo 
         instance("unordered_map<string,RooAbsBinning*>", -2, "unordered_map", 102,
                  typeid(unordered_map<string,RooAbsBinning*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &unordered_maplEstringcORooAbsBinningmUgR_Dictionary, isa_proxy, 0,
                  sizeof(unordered_map<string,RooAbsBinning*>) );
      instance.SetNew(&new_unordered_maplEstringcORooAbsBinningmUgR);
      instance.SetNewArray(&newArray_unordered_maplEstringcORooAbsBinningmUgR);
      instance.SetDelete(&delete_unordered_maplEstringcORooAbsBinningmUgR);
      instance.SetDeleteArray(&deleteArray_unordered_maplEstringcORooAbsBinningmUgR);
      instance.SetDestructor(&destruct_unordered_maplEstringcORooAbsBinningmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< unordered_map<string,RooAbsBinning*> >()));

      ::ROOT::AddClassAlternate("unordered_map<string,RooAbsBinning*>","std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsBinning*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooAbsBinning*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const unordered_map<string,RooAbsBinning*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unordered_maplEstringcORooAbsBinningmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const unordered_map<string,RooAbsBinning*>*)nullptr)->GetClass();
      unordered_maplEstringcORooAbsBinningmUgR_TClassManip(theClass);
   return theClass;
   }

   static void unordered_maplEstringcORooAbsBinningmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_unordered_maplEstringcORooAbsBinningmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<string,RooAbsBinning*> : new unordered_map<string,RooAbsBinning*>;
   }
   static void *newArray_unordered_maplEstringcORooAbsBinningmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) unordered_map<string,RooAbsBinning*>[nElements] : new unordered_map<string,RooAbsBinning*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unordered_maplEstringcORooAbsBinningmUgR(void *p) {
      delete ((unordered_map<string,RooAbsBinning*>*)p);
   }
   static void deleteArray_unordered_maplEstringcORooAbsBinningmUgR(void *p) {
      delete [] ((unordered_map<string,RooAbsBinning*>*)p);
   }
   static void destruct_unordered_maplEstringcORooAbsBinningmUgR(void *p) {
      typedef unordered_map<string,RooAbsBinning*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class unordered_map<string,RooAbsBinning*>

namespace ROOT {
   static TClass *setlEstringgR_Dictionary();
   static void setlEstringgR_TClassManip(TClass*);
   static void *new_setlEstringgR(void *p = nullptr);
   static void *newArray_setlEstringgR(Long_t size, void *p);
   static void delete_setlEstringgR(void *p);
   static void deleteArray_setlEstringgR(void *p);
   static void destruct_setlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const set<string>*)
   {
      set<string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(set<string>));
      static ::ROOT::TGenericClassInfo 
         instance("set<string>", -2, "set", 94,
                  typeid(set<string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &setlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(set<string>) );
      instance.SetNew(&new_setlEstringgR);
      instance.SetNewArray(&newArray_setlEstringgR);
      instance.SetDelete(&delete_setlEstringgR);
      instance.SetDeleteArray(&deleteArray_setlEstringgR);
      instance.SetDestructor(&destruct_setlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Insert< set<string> >()));

      ::ROOT::AddClassAlternate("set<string>","std::set<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const set<string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *setlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const set<string>*)nullptr)->GetClass();
      setlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void setlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_setlEstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) set<string> : new set<string>;
   }
   static void *newArray_setlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) set<string>[nElements] : new set<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_setlEstringgR(void *p) {
      delete ((set<string>*)p);
   }
   static void deleteArray_setlEstringgR(void *p) {
      delete [] ((set<string>*)p);
   }
   static void destruct_setlEstringgR(void *p) {
      typedef set<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class set<string>

namespace ROOT {
   static TClass *maplEstringcOvectorlEintgRsPgR_Dictionary();
   static void maplEstringcOvectorlEintgRsPgR_TClassManip(TClass*);
   static void *new_maplEstringcOvectorlEintgRsPgR(void *p = nullptr);
   static void *newArray_maplEstringcOvectorlEintgRsPgR(Long_t size, void *p);
   static void delete_maplEstringcOvectorlEintgRsPgR(void *p);
   static void deleteArray_maplEstringcOvectorlEintgRsPgR(void *p);
   static void destruct_maplEstringcOvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,vector<int> >*)
   {
      map<string,vector<int> > *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,vector<int> >", -2, "map", 100,
                  typeid(map<string,vector<int> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,vector<int> >) );
      instance.SetNew(&new_maplEstringcOvectorlEintgRsPgR);
      instance.SetNewArray(&newArray_maplEstringcOvectorlEintgRsPgR);
      instance.SetDelete(&delete_maplEstringcOvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOvectorlEintgRsPgR);
      instance.SetDestructor(&destruct_maplEstringcOvectorlEintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,vector<int> > >()));

      ::ROOT::AddClassAlternate("map<string,vector<int> >","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<int, std::allocator<int> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::vector<int, std::allocator<int> > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,vector<int> >*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,vector<int> >*)nullptr)->GetClass();
      maplEstringcOvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOvectorlEintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,vector<int> > : new map<string,vector<int> >;
   }
   static void *newArray_maplEstringcOvectorlEintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,vector<int> >[nElements] : new map<string,vector<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOvectorlEintgRsPgR(void *p) {
      delete ((map<string,vector<int> >*)p);
   }
   static void deleteArray_maplEstringcOvectorlEintgRsPgR(void *p) {
      delete [] ((map<string,vector<int> >*)p);
   }
   static void destruct_maplEstringcOvectorlEintgRsPgR(void *p) {
      typedef map<string,vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,vector<int> >

namespace ROOT {
   static TClass *maplEstringcOstringgR_Dictionary();
   static void maplEstringcOstringgR_TClassManip(TClass*);
   static void *new_maplEstringcOstringgR(void *p = nullptr);
   static void *newArray_maplEstringcOstringgR(Long_t size, void *p);
   static void delete_maplEstringcOstringgR(void *p);
   static void deleteArray_maplEstringcOstringgR(void *p);
   static void destruct_maplEstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,string>*)
   {
      map<string,string> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,string>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string>", -2, "map", 100,
                  typeid(map<string,string>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOstringgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,string>) );
      instance.SetNew(&new_maplEstringcOstringgR);
      instance.SetNewArray(&newArray_maplEstringcOstringgR);
      instance.SetDelete(&delete_maplEstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringgR);
      instance.SetDestructor(&destruct_maplEstringcOstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,string> >()));

      ::ROOT::AddClassAlternate("map<string,string>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,string>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,string>*)nullptr)->GetClass();
      maplEstringcOstringgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,string> : new map<string,string>;
   }
   static void *newArray_maplEstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,string>[nElements] : new map<string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOstringgR(void *p) {
      delete ((map<string,string>*)p);
   }
   static void deleteArray_maplEstringcOstringgR(void *p) {
      delete [] ((map<string,string>*)p);
   }
   static void destruct_maplEstringcOstringgR(void *p) {
      typedef map<string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,string>

namespace ROOT {
   static TClass *maplEstringcOintgR_Dictionary();
   static void maplEstringcOintgR_TClassManip(TClass*);
   static void *new_maplEstringcOintgR(void *p = nullptr);
   static void *newArray_maplEstringcOintgR(Long_t size, void *p);
   static void delete_maplEstringcOintgR(void *p);
   static void deleteArray_maplEstringcOintgR(void *p);
   static void destruct_maplEstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,int>*)
   {
      map<string,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,int>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,int>", -2, "map", 100,
                  typeid(map<string,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOintgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,int>) );
      instance.SetNew(&new_maplEstringcOintgR);
      instance.SetNewArray(&newArray_maplEstringcOintgR);
      instance.SetDelete(&delete_maplEstringcOintgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOintgR);
      instance.SetDestructor(&destruct_maplEstringcOintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,int> >()));

      ::ROOT::AddClassAlternate("map<string,int>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,int>*)nullptr)->GetClass();
      maplEstringcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,int> : new map<string,int>;
   }
   static void *newArray_maplEstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,int>[nElements] : new map<string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOintgR(void *p) {
      delete ((map<string,int>*)p);
   }
   static void deleteArray_maplEstringcOintgR(void *p) {
      delete [] ((map<string,int>*)p);
   }
   static void destruct_maplEstringcOintgR(void *p) {
      typedef map<string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,int>

namespace ROOT {
   static TClass *maplEstringcOTH1mUgR_Dictionary();
   static void maplEstringcOTH1mUgR_TClassManip(TClass*);
   static void *new_maplEstringcOTH1mUgR(void *p = nullptr);
   static void *newArray_maplEstringcOTH1mUgR(Long_t size, void *p);
   static void delete_maplEstringcOTH1mUgR(void *p);
   static void deleteArray_maplEstringcOTH1mUgR(void *p);
   static void destruct_maplEstringcOTH1mUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,TH1*>*)
   {
      map<string,TH1*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,TH1*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,TH1*>", -2, "map", 100,
                  typeid(map<string,TH1*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcOTH1mUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,TH1*>) );
      instance.SetNew(&new_maplEstringcOTH1mUgR);
      instance.SetNewArray(&newArray_maplEstringcOTH1mUgR);
      instance.SetDelete(&delete_maplEstringcOTH1mUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOTH1mUgR);
      instance.SetDestructor(&destruct_maplEstringcOTH1mUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,TH1*> >()));

      ::ROOT::AddClassAlternate("map<string,TH1*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, TH1*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, TH1*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,TH1*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOTH1mUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,TH1*>*)nullptr)->GetClass();
      maplEstringcOTH1mUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOTH1mUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOTH1mUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,TH1*> : new map<string,TH1*>;
   }
   static void *newArray_maplEstringcOTH1mUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,TH1*>[nElements] : new map<string,TH1*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOTH1mUgR(void *p) {
      delete ((map<string,TH1*>*)p);
   }
   static void deleteArray_maplEstringcOTH1mUgR(void *p) {
      delete [] ((map<string,TH1*>*)p);
   }
   static void destruct_maplEstringcOTH1mUgR(void *p) {
      typedef map<string,TH1*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,TH1*>

namespace ROOT {
   static TClass *maplEstringcORooMappedCategorycLcLEntrygR_Dictionary();
   static void maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(TClass*);
   static void *new_maplEstringcORooMappedCategorycLcLEntrygR(void *p = nullptr);
   static void *newArray_maplEstringcORooMappedCategorycLcLEntrygR(Long_t size, void *p);
   static void delete_maplEstringcORooMappedCategorycLcLEntrygR(void *p);
   static void deleteArray_maplEstringcORooMappedCategorycLcLEntrygR(void *p);
   static void destruct_maplEstringcORooMappedCategorycLcLEntrygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooMappedCategory::Entry>*)
   {
      map<string,RooMappedCategory::Entry> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooMappedCategory::Entry>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooMappedCategory::Entry>", -2, "map", 100,
                  typeid(map<string,RooMappedCategory::Entry>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooMappedCategorycLcLEntrygR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooMappedCategory::Entry>) );
      instance.SetNew(&new_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetNewArray(&newArray_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDelete(&delete_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.SetDestructor(&destruct_maplEstringcORooMappedCategorycLcLEntrygR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooMappedCategory::Entry> >()));

      ::ROOT::AddClassAlternate("map<string,RooMappedCategory::Entry>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooMappedCategory::Entry, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooMappedCategory::Entry> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooMappedCategory::Entry>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooMappedCategorycLcLEntrygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooMappedCategory::Entry>*)nullptr)->GetClass();
      maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooMappedCategorycLcLEntrygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooMappedCategory::Entry> : new map<string,RooMappedCategory::Entry>;
   }
   static void *newArray_maplEstringcORooMappedCategorycLcLEntrygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooMappedCategory::Entry>[nElements] : new map<string,RooMappedCategory::Entry>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      delete ((map<string,RooMappedCategory::Entry>*)p);
   }
   static void deleteArray_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      delete [] ((map<string,RooMappedCategory::Entry>*)p);
   }
   static void destruct_maplEstringcORooMappedCategorycLcLEntrygR(void *p) {
      typedef map<string,RooMappedCategory::Entry> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooMappedCategory::Entry>

namespace ROOT {
   static TClass *maplEstringcORooDataSetmUgR_Dictionary();
   static void maplEstringcORooDataSetmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooDataSetmUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooDataSetmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooDataSetmUgR(void *p);
   static void deleteArray_maplEstringcORooDataSetmUgR(void *p);
   static void destruct_maplEstringcORooDataSetmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooDataSet*>*)
   {
      map<string,RooDataSet*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooDataSet*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooDataSet*>", -2, "map", 100,
                  typeid(map<string,RooDataSet*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooDataSetmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooDataSet*>) );
      instance.SetNew(&new_maplEstringcORooDataSetmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooDataSetmUgR);
      instance.SetDelete(&delete_maplEstringcORooDataSetmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooDataSetmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooDataSetmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooDataSet*> >()));

      ::ROOT::AddClassAlternate("map<string,RooDataSet*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooDataSet*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooDataSet*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooDataSet*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooDataSetmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooDataSet*>*)nullptr)->GetClass();
      maplEstringcORooDataSetmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooDataSetmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooDataSetmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataSet*> : new map<string,RooDataSet*>;
   }
   static void *newArray_maplEstringcORooDataSetmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataSet*>[nElements] : new map<string,RooDataSet*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooDataSetmUgR(void *p) {
      delete ((map<string,RooDataSet*>*)p);
   }
   static void deleteArray_maplEstringcORooDataSetmUgR(void *p) {
      delete [] ((map<string,RooDataSet*>*)p);
   }
   static void destruct_maplEstringcORooDataSetmUgR(void *p) {
      typedef map<string,RooDataSet*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooDataSet*>

namespace ROOT {
   static TClass *maplEstringcORooDataHistmUgR_Dictionary();
   static void maplEstringcORooDataHistmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooDataHistmUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooDataHistmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooDataHistmUgR(void *p);
   static void deleteArray_maplEstringcORooDataHistmUgR(void *p);
   static void destruct_maplEstringcORooDataHistmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooDataHist*>*)
   {
      map<string,RooDataHist*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooDataHist*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooDataHist*>", -2, "map", 100,
                  typeid(map<string,RooDataHist*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooDataHistmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooDataHist*>) );
      instance.SetNew(&new_maplEstringcORooDataHistmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooDataHistmUgR);
      instance.SetDelete(&delete_maplEstringcORooDataHistmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooDataHistmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooDataHistmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooDataHist*> >()));

      ::ROOT::AddClassAlternate("map<string,RooDataHist*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooDataHist*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooDataHist*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooDataHist*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooDataHistmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooDataHist*>*)nullptr)->GetClass();
      maplEstringcORooDataHistmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooDataHistmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooDataHistmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataHist*> : new map<string,RooDataHist*>;
   }
   static void *newArray_maplEstringcORooDataHistmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooDataHist*>[nElements] : new map<string,RooDataHist*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooDataHistmUgR(void *p) {
      delete ((map<string,RooDataHist*>*)p);
   }
   static void deleteArray_maplEstringcORooDataHistmUgR(void *p) {
      delete [] ((map<string,RooDataHist*>*)p);
   }
   static void destruct_maplEstringcORooDataHistmUgR(void *p) {
      typedef map<string,RooDataHist*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooDataHist*>

namespace ROOT {
   static TClass *maplEstringcORooArgSetgR_Dictionary();
   static void maplEstringcORooArgSetgR_TClassManip(TClass*);
   static void *new_maplEstringcORooArgSetgR(void *p = nullptr);
   static void *newArray_maplEstringcORooArgSetgR(Long_t size, void *p);
   static void delete_maplEstringcORooArgSetgR(void *p);
   static void deleteArray_maplEstringcORooArgSetgR(void *p);
   static void destruct_maplEstringcORooArgSetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooArgSet>*)
   {
      map<string,RooArgSet> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooArgSet>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooArgSet>", -2, "map", 100,
                  typeid(map<string,RooArgSet>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooArgSetgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooArgSet>) );
      instance.SetNew(&new_maplEstringcORooArgSetgR);
      instance.SetNewArray(&newArray_maplEstringcORooArgSetgR);
      instance.SetDelete(&delete_maplEstringcORooArgSetgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooArgSetgR);
      instance.SetDestructor(&destruct_maplEstringcORooArgSetgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooArgSet> >()));

      ::ROOT::AddClassAlternate("map<string,RooArgSet>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooArgSet, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooArgSet> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooArgSet>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooArgSetgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooArgSet>*)nullptr)->GetClass();
      maplEstringcORooArgSetgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooArgSetgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooArgSetgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooArgSet> : new map<string,RooArgSet>;
   }
   static void *newArray_maplEstringcORooArgSetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooArgSet>[nElements] : new map<string,RooArgSet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooArgSetgR(void *p) {
      delete ((map<string,RooArgSet>*)p);
   }
   static void deleteArray_maplEstringcORooArgSetgR(void *p) {
      delete [] ((map<string,RooArgSet>*)p);
   }
   static void destruct_maplEstringcORooArgSetgR(void *p) {
      typedef map<string,RooArgSet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooArgSet>

namespace ROOT {
   static TClass *maplEstringcORooAbsPdfmUgR_Dictionary();
   static void maplEstringcORooAbsPdfmUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsPdfmUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooAbsPdfmUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsPdfmUgR(void *p);
   static void deleteArray_maplEstringcORooAbsPdfmUgR(void *p);
   static void destruct_maplEstringcORooAbsPdfmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsPdf*>*)
   {
      map<string,RooAbsPdf*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsPdf*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsPdf*>", -2, "map", 100,
                  typeid(map<string,RooAbsPdf*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsPdfmUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsPdf*>) );
      instance.SetNew(&new_maplEstringcORooAbsPdfmUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsPdfmUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsPdfmUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsPdfmUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsPdfmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsPdf*> >()));

      ::ROOT::AddClassAlternate("map<string,RooAbsPdf*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsPdf*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooAbsPdf*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsPdf*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsPdfmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsPdf*>*)nullptr)->GetClass();
      maplEstringcORooAbsPdfmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsPdfmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsPdfmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsPdf*> : new map<string,RooAbsPdf*>;
   }
   static void *newArray_maplEstringcORooAbsPdfmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsPdf*>[nElements] : new map<string,RooAbsPdf*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsPdfmUgR(void *p) {
      delete ((map<string,RooAbsPdf*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsPdfmUgR(void *p) {
      delete [] ((map<string,RooAbsPdf*>*)p);
   }
   static void destruct_maplEstringcORooAbsPdfmUgR(void *p) {
      typedef map<string,RooAbsPdf*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsPdf*>

namespace ROOT {
   static TClass *maplEstringcORooAbsNumGeneratormUgR_Dictionary();
   static void maplEstringcORooAbsNumGeneratormUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsNumGeneratormUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooAbsNumGeneratormUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsNumGeneratormUgR(void *p);
   static void deleteArray_maplEstringcORooAbsNumGeneratormUgR(void *p);
   static void destruct_maplEstringcORooAbsNumGeneratormUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsNumGenerator*>*)
   {
      map<string,RooAbsNumGenerator*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsNumGenerator*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsNumGenerator*>", -2, "map", 100,
                  typeid(map<string,RooAbsNumGenerator*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsNumGeneratormUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,RooAbsNumGenerator*>) );
      instance.SetNew(&new_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsNumGeneratormUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsNumGeneratormUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsNumGenerator*> >()));

      ::ROOT::AddClassAlternate("map<string,RooAbsNumGenerator*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsNumGenerator*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooAbsNumGenerator*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsNumGenerator*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsNumGeneratormUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsNumGenerator*>*)nullptr)->GetClass();
      maplEstringcORooAbsNumGeneratormUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsNumGeneratormUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsNumGenerator*> : new map<string,RooAbsNumGenerator*>;
   }
   static void *newArray_maplEstringcORooAbsNumGeneratormUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsNumGenerator*>[nElements] : new map<string,RooAbsNumGenerator*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      delete ((map<string,RooAbsNumGenerator*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      delete [] ((map<string,RooAbsNumGenerator*>*)p);
   }
   static void destruct_maplEstringcORooAbsNumGeneratormUgR(void *p) {
      typedef map<string,RooAbsNumGenerator*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsNumGenerator*>

namespace ROOT {
   static TClass *maplEstringcORooAbsDataStoremUgR_Dictionary();
   static void maplEstringcORooAbsDataStoremUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsDataStoremUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooAbsDataStoremUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsDataStoremUgR(void *p);
   static void deleteArray_maplEstringcORooAbsDataStoremUgR(void *p);
   static void destruct_maplEstringcORooAbsDataStoremUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsDataStore*>*)
   {
      map<string,RooAbsDataStore*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsDataStore*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsDataStore*>", -2, "map", 100,
                  typeid(map<string,RooAbsDataStore*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsDataStoremUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsDataStore*>) );
      instance.SetNew(&new_maplEstringcORooAbsDataStoremUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsDataStoremUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsDataStoremUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsDataStoremUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsDataStoremUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsDataStore*> >()));

      ::ROOT::AddClassAlternate("map<string,RooAbsDataStore*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsDataStore*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooAbsDataStore*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsDataStore*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsDataStoremUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsDataStore*>*)nullptr)->GetClass();
      maplEstringcORooAbsDataStoremUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsDataStoremUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsDataStoremUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsDataStore*> : new map<string,RooAbsDataStore*>;
   }
   static void *newArray_maplEstringcORooAbsDataStoremUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsDataStore*>[nElements] : new map<string,RooAbsDataStore*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsDataStoremUgR(void *p) {
      delete ((map<string,RooAbsDataStore*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsDataStoremUgR(void *p) {
      delete [] ((map<string,RooAbsDataStore*>*)p);
   }
   static void destruct_maplEstringcORooAbsDataStoremUgR(void *p) {
      typedef map<string,RooAbsDataStore*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsDataStore*>

namespace ROOT {
   static TClass *maplEstringcORooAbsDatamUgR_Dictionary();
   static void maplEstringcORooAbsDatamUgR_TClassManip(TClass*);
   static void *new_maplEstringcORooAbsDatamUgR(void *p = nullptr);
   static void *newArray_maplEstringcORooAbsDatamUgR(Long_t size, void *p);
   static void delete_maplEstringcORooAbsDatamUgR(void *p);
   static void deleteArray_maplEstringcORooAbsDatamUgR(void *p);
   static void destruct_maplEstringcORooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,RooAbsData*>*)
   {
      map<string,RooAbsData*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,RooAbsData*>", -2, "map", 100,
                  typeid(map<string,RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEstringcORooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,RooAbsData*>) );
      instance.SetNew(&new_maplEstringcORooAbsDatamUgR);
      instance.SetNewArray(&newArray_maplEstringcORooAbsDatamUgR);
      instance.SetDelete(&delete_maplEstringcORooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcORooAbsDatamUgR);
      instance.SetDestructor(&destruct_maplEstringcORooAbsDatamUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,RooAbsData*> >()));

      ::ROOT::AddClassAlternate("map<string,RooAbsData*>","std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooAbsData*, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, RooAbsData*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<string,RooAbsData*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcORooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,RooAbsData*>*)nullptr)->GetClass();
      maplEstringcORooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcORooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcORooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsData*> : new map<string,RooAbsData*>;
   }
   static void *newArray_maplEstringcORooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<string,RooAbsData*>[nElements] : new map<string,RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcORooAbsDatamUgR(void *p) {
      delete ((map<string,RooAbsData*>*)p);
   }
   static void deleteArray_maplEstringcORooAbsDatamUgR(void *p) {
      delete [] ((map<string,RooAbsData*>*)p);
   }
   static void destruct_maplEstringcORooAbsDatamUgR(void *p) {
      typedef map<string,RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,RooAbsData*>

namespace ROOT {
   static TClass *maplEintcORooAbsDataStoremUgR_Dictionary();
   static void maplEintcORooAbsDataStoremUgR_TClassManip(TClass*);
   static void *new_maplEintcORooAbsDataStoremUgR(void *p = nullptr);
   static void *newArray_maplEintcORooAbsDataStoremUgR(Long_t size, void *p);
   static void delete_maplEintcORooAbsDataStoremUgR(void *p);
   static void deleteArray_maplEintcORooAbsDataStoremUgR(void *p);
   static void destruct_maplEintcORooAbsDataStoremUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<int,RooAbsDataStore*>*)
   {
      map<int,RooAbsDataStore*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<int,RooAbsDataStore*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<int,RooAbsDataStore*>", -2, "map", 100,
                  typeid(map<int,RooAbsDataStore*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEintcORooAbsDataStoremUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<int,RooAbsDataStore*>) );
      instance.SetNew(&new_maplEintcORooAbsDataStoremUgR);
      instance.SetNewArray(&newArray_maplEintcORooAbsDataStoremUgR);
      instance.SetDelete(&delete_maplEintcORooAbsDataStoremUgR);
      instance.SetDeleteArray(&deleteArray_maplEintcORooAbsDataStoremUgR);
      instance.SetDestructor(&destruct_maplEintcORooAbsDataStoremUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<int,RooAbsDataStore*> >()));

      ::ROOT::AddClassAlternate("map<int,RooAbsDataStore*>","std::map<int, RooAbsDataStore*, std::less<int>, std::allocator<std::pair<int const, RooAbsDataStore*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<int,RooAbsDataStore*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEintcORooAbsDataStoremUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<int,RooAbsDataStore*>*)nullptr)->GetClass();
      maplEintcORooAbsDataStoremUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEintcORooAbsDataStoremUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEintcORooAbsDataStoremUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<int,RooAbsDataStore*> : new map<int,RooAbsDataStore*>;
   }
   static void *newArray_maplEintcORooAbsDataStoremUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<int,RooAbsDataStore*>[nElements] : new map<int,RooAbsDataStore*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEintcORooAbsDataStoremUgR(void *p) {
      delete ((map<int,RooAbsDataStore*>*)p);
   }
   static void deleteArray_maplEintcORooAbsDataStoremUgR(void *p) {
      delete [] ((map<int,RooAbsDataStore*>*)p);
   }
   static void destruct_maplEintcORooAbsDataStoremUgR(void *p) {
      typedef map<int,RooAbsDataStore*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<int,RooAbsDataStore*>

namespace ROOT {
   static TClass *maplETStringcOintgR_Dictionary();
   static void maplETStringcOintgR_TClassManip(TClass*);
   static void *new_maplETStringcOintgR(void *p = nullptr);
   static void *newArray_maplETStringcOintgR(Long_t size, void *p);
   static void delete_maplETStringcOintgR(void *p);
   static void deleteArray_maplETStringcOintgR(void *p);
   static void destruct_maplETStringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,int>*)
   {
      map<TString,int> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,int>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,int>", -2, "map", 100,
                  typeid(map<TString,int>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcOintgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,int>) );
      instance.SetNew(&new_maplETStringcOintgR);
      instance.SetNewArray(&newArray_maplETStringcOintgR);
      instance.SetDelete(&delete_maplETStringcOintgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcOintgR);
      instance.SetDestructor(&destruct_maplETStringcOintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,int> >()));

      ::ROOT::AddClassAlternate("map<TString,int>","std::map<TString, int, std::less<TString>, std::allocator<std::pair<TString const, int> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,int>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcOintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,int>*)nullptr)->GetClass();
      maplETStringcOintgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcOintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcOintgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,int> : new map<TString,int>;
   }
   static void *newArray_maplETStringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,int>[nElements] : new map<TString,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcOintgR(void *p) {
      delete ((map<TString,int>*)p);
   }
   static void deleteArray_maplETStringcOintgR(void *p) {
      delete [] ((map<TString,int>*)p);
   }
   static void destruct_maplETStringcOintgR(void *p) {
      typedef map<TString,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,int>

namespace ROOT {
   static TClass *maplETStringcOdoublegR_Dictionary();
   static void maplETStringcOdoublegR_TClassManip(TClass*);
   static void *new_maplETStringcOdoublegR(void *p = nullptr);
   static void *newArray_maplETStringcOdoublegR(Long_t size, void *p);
   static void delete_maplETStringcOdoublegR(void *p);
   static void deleteArray_maplETStringcOdoublegR(void *p);
   static void destruct_maplETStringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,double>*)
   {
      map<TString,double> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,double>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,double>", -2, "map", 100,
                  typeid(map<TString,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcOdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,double>) );
      instance.SetNew(&new_maplETStringcOdoublegR);
      instance.SetNewArray(&newArray_maplETStringcOdoublegR);
      instance.SetDelete(&delete_maplETStringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_maplETStringcOdoublegR);
      instance.SetDestructor(&destruct_maplETStringcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,double> >()));

      ::ROOT::AddClassAlternate("map<TString,double>","std::map<TString, double, std::less<TString>, std::allocator<std::pair<TString const, double> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,double>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,double>*)nullptr)->GetClass();
      maplETStringcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,double> : new map<TString,double>;
   }
   static void *newArray_maplETStringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,double>[nElements] : new map<TString,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcOdoublegR(void *p) {
      delete ((map<TString,double>*)p);
   }
   static void deleteArray_maplETStringcOdoublegR(void *p) {
      delete [] ((map<TString,double>*)p);
   }
   static void destruct_maplETStringcOdoublegR(void *p) {
      typedef map<TString,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,double>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p = nullptr);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)
   {
      map<TString,RooWorkspace::CodeRepo::ExtraHeader> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ExtraHeader>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ExtraHeader>", -2, "map", 100,
                  typeid(map<TString,RooWorkspace::CodeRepo::ExtraHeader>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ExtraHeader>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ExtraHeader> >()));

      ::ROOT::AddClassAlternate("map<TString,RooWorkspace::CodeRepo::ExtraHeader>","std::map<TString, RooWorkspace::CodeRepo::ExtraHeader, std::less<TString>, std::allocator<std::pair<TString const, RooWorkspace::CodeRepo::ExtraHeader> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)nullptr)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ExtraHeader> : new map<TString,RooWorkspace::CodeRepo::ExtraHeader>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ExtraHeader>[nElements] : new map<TString,RooWorkspace::CodeRepo::ExtraHeader>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ExtraHeader>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLExtraHeadergR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ExtraHeader> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ExtraHeader>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p = nullptr);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)
   {
      map<TString,RooWorkspace::CodeRepo::ClassRelInfo> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ClassRelInfo>", -2, "map", 100,
                  typeid(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ClassRelInfo>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ClassRelInfo> >()));

      ::ROOT::AddClassAlternate("map<TString,RooWorkspace::CodeRepo::ClassRelInfo>","std::map<TString, RooWorkspace::CodeRepo::ClassRelInfo, std::less<TString>, std::allocator<std::pair<TString const, RooWorkspace::CodeRepo::ClassRelInfo> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)nullptr)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassRelInfo> : new map<TString,RooWorkspace::CodeRepo::ClassRelInfo>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassRelInfo>[nElements] : new map<TString,RooWorkspace::CodeRepo::ClassRelInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ClassRelInfo>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassRelInfogR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ClassRelInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ClassRelInfo>

namespace ROOT {
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary();
   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(TClass*);
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p = nullptr);
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(Long_t size, void *p);
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)
   {
      map<TString,RooWorkspace::CodeRepo::ClassFiles> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooWorkspace::CodeRepo::ClassFiles>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooWorkspace::CodeRepo::ClassFiles>", -2, "map", 100,
                  typeid(map<TString,RooWorkspace::CodeRepo::ClassFiles>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooWorkspace::CodeRepo::ClassFiles>) );
      instance.SetNew(&new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetNewArray(&newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDelete(&delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.SetDestructor(&destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooWorkspace::CodeRepo::ClassFiles> >()));

      ::ROOT::AddClassAlternate("map<TString,RooWorkspace::CodeRepo::ClassFiles>","std::map<TString, RooWorkspace::CodeRepo::ClassFiles, std::less<TString>, std::allocator<std::pair<TString const, RooWorkspace::CodeRepo::ClassFiles> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooWorkspace::CodeRepo::ClassFiles>*)nullptr)->GetClass();
      maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassFiles> : new map<TString,RooWorkspace::CodeRepo::ClassFiles>;
   }
   static void *newArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooWorkspace::CodeRepo::ClassFiles>[nElements] : new map<TString,RooWorkspace::CodeRepo::ClassFiles>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      delete ((map<TString,RooWorkspace::CodeRepo::ClassFiles>*)p);
   }
   static void deleteArray_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      delete [] ((map<TString,RooWorkspace::CodeRepo::ClassFiles>*)p);
   }
   static void destruct_maplETStringcORooWorkspacecLcLCodeRepocLcLClassFilesgR(void *p) {
      typedef map<TString,RooWorkspace::CodeRepo::ClassFiles> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooWorkspace::CodeRepo::ClassFiles>

namespace ROOT {
   static TClass *maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary();
   static void maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(TClass*);
   static void *new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p = nullptr);
   static void *newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(Long_t size, void *p);
   static void delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);
   static void deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);
   static void destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)
   {
      map<TString,RooExpensiveObjectCache::ExpensiveObject*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<TString,RooExpensiveObjectCache::ExpensiveObject*>));
      static ::ROOT::TGenericClassInfo 
         instance("map<TString,RooExpensiveObjectCache::ExpensiveObject*>", -2, "map", 100,
                  typeid(map<TString,RooExpensiveObjectCache::ExpensiveObject*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary, isa_proxy, 0,
                  sizeof(map<TString,RooExpensiveObjectCache::ExpensiveObject*>) );
      instance.SetNew(&new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetNewArray(&newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDelete(&delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.SetDestructor(&destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<TString,RooExpensiveObjectCache::ExpensiveObject*> >()));

      ::ROOT::AddClassAlternate("map<TString,RooExpensiveObjectCache::ExpensiveObject*>","std::map<TString, RooExpensiveObjectCache::ExpensiveObject*, std::less<TString>, std::allocator<std::pair<TString const, RooExpensiveObjectCache::ExpensiveObject*> > >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)nullptr)->GetClass();
      maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(theClass);
   return theClass;
   }

   static void maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooExpensiveObjectCache::ExpensiveObject*> : new map<TString,RooExpensiveObjectCache::ExpensiveObject*>;
   }
   static void *newArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<TString,RooExpensiveObjectCache::ExpensiveObject*>[nElements] : new map<TString,RooExpensiveObjectCache::ExpensiveObject*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      delete ((map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)p);
   }
   static void deleteArray_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      delete [] ((map<TString,RooExpensiveObjectCache::ExpensiveObject*>*)p);
   }
   static void destruct_maplETStringcORooExpensiveObjectCachecLcLExpensiveObjectmUgR(void *p) {
      typedef map<TString,RooExpensiveObjectCache::ExpensiveObject*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,RooExpensiveObjectCache::ExpensiveObject*>

namespace ROOT {
   static TClass *listlETObjectmUgR_Dictionary();
   static void listlETObjectmUgR_TClassManip(TClass*);
   static void *new_listlETObjectmUgR(void *p = nullptr);
   static void *newArray_listlETObjectmUgR(Long_t size, void *p);
   static void delete_listlETObjectmUgR(void *p);
   static void deleteArray_listlETObjectmUgR(void *p);
   static void destruct_listlETObjectmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<TObject*>*)
   {
      list<TObject*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<TObject*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<TObject*>", -2, "list", 552,
                  typeid(list<TObject*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlETObjectmUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<TObject*>) );
      instance.SetNew(&new_listlETObjectmUgR);
      instance.SetNewArray(&newArray_listlETObjectmUgR);
      instance.SetDelete(&delete_listlETObjectmUgR);
      instance.SetDeleteArray(&deleteArray_listlETObjectmUgR);
      instance.SetDestructor(&destruct_listlETObjectmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<TObject*> >()));

      ::ROOT::AddClassAlternate("list<TObject*>","std::__cxx11::list<TObject*, std::allocator<TObject*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<TObject*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlETObjectmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<TObject*>*)nullptr)->GetClass();
      listlETObjectmUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlETObjectmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlETObjectmUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<TObject*> : new list<TObject*>;
   }
   static void *newArray_listlETObjectmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<TObject*>[nElements] : new list<TObject*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlETObjectmUgR(void *p) {
      delete ((list<TObject*>*)p);
   }
   static void deleteArray_listlETObjectmUgR(void *p) {
      delete [] ((list<TObject*>*)p);
   }
   static void destruct_listlETObjectmUgR(void *p) {
      typedef list<TObject*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<TObject*>

namespace ROOT {
   static TClass *listlERooAbsStudymUgR_Dictionary();
   static void listlERooAbsStudymUgR_TClassManip(TClass*);
   static void *new_listlERooAbsStudymUgR(void *p = nullptr);
   static void *newArray_listlERooAbsStudymUgR(Long_t size, void *p);
   static void delete_listlERooAbsStudymUgR(void *p);
   static void deleteArray_listlERooAbsStudymUgR(void *p);
   static void destruct_listlERooAbsStudymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<RooAbsStudy*>*)
   {
      list<RooAbsStudy*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<RooAbsStudy*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<RooAbsStudy*>", -2, "list", 552,
                  typeid(list<RooAbsStudy*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlERooAbsStudymUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<RooAbsStudy*>) );
      instance.SetNew(&new_listlERooAbsStudymUgR);
      instance.SetNewArray(&newArray_listlERooAbsStudymUgR);
      instance.SetDelete(&delete_listlERooAbsStudymUgR);
      instance.SetDeleteArray(&deleteArray_listlERooAbsStudymUgR);
      instance.SetDestructor(&destruct_listlERooAbsStudymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<RooAbsStudy*> >()));

      ::ROOT::AddClassAlternate("list<RooAbsStudy*>","std::__cxx11::list<RooAbsStudy*, std::allocator<RooAbsStudy*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<RooAbsStudy*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlERooAbsStudymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<RooAbsStudy*>*)nullptr)->GetClass();
      listlERooAbsStudymUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlERooAbsStudymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlERooAbsStudymUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsStudy*> : new list<RooAbsStudy*>;
   }
   static void *newArray_listlERooAbsStudymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsStudy*>[nElements] : new list<RooAbsStudy*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlERooAbsStudymUgR(void *p) {
      delete ((list<RooAbsStudy*>*)p);
   }
   static void deleteArray_listlERooAbsStudymUgR(void *p) {
      delete [] ((list<RooAbsStudy*>*)p);
   }
   static void destruct_listlERooAbsStudymUgR(void *p) {
      typedef list<RooAbsStudy*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<RooAbsStudy*>

namespace ROOT {
   static TClass *listlERooAbsDatamUgR_Dictionary();
   static void listlERooAbsDatamUgR_TClassManip(TClass*);
   static void *new_listlERooAbsDatamUgR(void *p = nullptr);
   static void *newArray_listlERooAbsDatamUgR(Long_t size, void *p);
   static void delete_listlERooAbsDatamUgR(void *p);
   static void deleteArray_listlERooAbsDatamUgR(void *p);
   static void destruct_listlERooAbsDatamUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<RooAbsData*>*)
   {
      list<RooAbsData*> *ptr = nullptr;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<RooAbsData*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<RooAbsData*>", -2, "list", 552,
                  typeid(list<RooAbsData*>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &listlERooAbsDatamUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<RooAbsData*>) );
      instance.SetNew(&new_listlERooAbsDatamUgR);
      instance.SetNewArray(&newArray_listlERooAbsDatamUgR);
      instance.SetDelete(&delete_listlERooAbsDatamUgR);
      instance.SetDeleteArray(&deleteArray_listlERooAbsDatamUgR);
      instance.SetDestructor(&destruct_listlERooAbsDatamUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<RooAbsData*> >()));

      ::ROOT::AddClassAlternate("list<RooAbsData*>","std::__cxx11::list<RooAbsData*, std::allocator<RooAbsData*> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_DICT_(Init) = GenerateInitInstanceLocal((const list<RooAbsData*>*)nullptr); R__UseDummy(_R__UNIQUE_DICT_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlERooAbsDatamUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<RooAbsData*>*)nullptr)->GetClass();
      listlERooAbsDatamUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlERooAbsDatamUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlERooAbsDatamUgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsData*> : new list<RooAbsData*>;
   }
   static void *newArray_listlERooAbsDatamUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) list<RooAbsData*>[nElements] : new list<RooAbsData*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlERooAbsDatamUgR(void *p) {
      delete ((list<RooAbsData*>*)p);
   }
   static void deleteArray_listlERooAbsDatamUgR(void *p) {
      delete [] ((list<RooAbsData*>*)p);
   }
   static void destruct_listlERooAbsDatamUgR(void *p) {
      typedef list<RooAbsData*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<RooAbsData*>

namespace {
  void TriggerDictionaryInitialization_libRooFitCore_Impl() {
    static const char* headers[] = {
nullptr
    };
    static const char* includePaths[] = {
nullptr
    };
    static const char* fwdDeclCode = "";
    static const char* payloadCode = "";
    static const char* classesHeaders[] = {
""
};
    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("libRooFitCore",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_libRooFitCore_Impl, {}, classesHeaders, /*hasCxxModule*/true);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_libRooFitCore_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_libRooFitCore() {
  TriggerDictionaryInitialization_libRooFitCore_Impl();
}
